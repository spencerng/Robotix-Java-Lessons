{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Raider Robotix Scouting Welcome to the hub for Raider Robotix Scouting! Here you'll find the latest info from the Scouting Subteam, from app programming and scout training resources, to scouting rotations and standings for the current season. Of course, click here to visit the team website. This site will be hosted on the team's GitHub repository in the future. Sitemap Here's a guide to everything on this site: For Scouts Standings : view your standings for the season and learn about how you're scored Game Resources : explore resources for this year's game Assessments : take the theory and skill assessments for this year's game App Usage : learn how to use this year's scouting app History : learn about the scouting team's history For Developers Open Source: learn about software development tools that are essential for working as a team and maintaining the scouting system. Lesson 1: What is Git? Lesson 2: Collaboration Lesson 3: Build Tools Lesson 4: Documentation Java: learn the essentials of Java needed for Android development and to maintain the scouting system Lesson 1: Intro to Java Lesson 2: Loops, Strings, Math Lesson 3: Methods Lesson 4: Objects Lesson 5: Arrays & Dictionaries Lesson 6: Advanced Java Lesson 7: Advanced OOP Miscellaneous: assorted topics in computer science that are needed to work on parts of the scouting system or to maintain this site File I/O JSON HTTP The Blue Alliance API Java Swing Regex HTML & JavaScript Android: learn everything about Android that you'll need to work on the scouting app Lesson 1: Intro to Android Lesson 2: GUI Components Lesson 3: UX Design Lesson 4: Advanced Techniques Scouting System Maintenance: learn the necessary changes to the system between seasons Lesson 1: The Scouting App Lesson 2: The Scouting Client Lesson 3: The Blue Alliance Library For Strategists: Game Strategy: learn how to win competitions through strategy and the intersections between you, developers, and the drive team Lesson 1: Kickoff! Lesson 2: Metrics Lesson 3: Pre-Scouting Lesson 4: Competition! Lesson 5: Picklisting Scouting System Usage: learn how to use the scouting system as an analysist Lesson 1: The Scouting App Lesson 2: The Scouting Client Lesson 3: Tableau Lesson 4: Excel For Scouting Leads Scout Management: learn how to manage scouts throughout the year Lesson 1: Pre-Season Lesson 2: Kickoff! Lesson 3: Competition Lesson 4: Traveling Scout Assessment: learn how to assess scouts and form the travel team Lesson 1: Evaluation System Lesson 2: Theory Lesson 3: Week Zero Lesson 4: The Travel Team","title":"Home"},{"location":"#raider-robotix-scouting","text":"Welcome to the hub for Raider Robotix Scouting! Here you'll find the latest info from the Scouting Subteam, from app programming and scout training resources, to scouting rotations and standings for the current season. Of course, click here to visit the team website. This site will be hosted on the team's GitHub repository in the future.","title":"Raider Robotix Scouting"},{"location":"#sitemap","text":"Here's a guide to everything on this site:","title":"Sitemap"},{"location":"#for-scouts","text":"Standings : view your standings for the season and learn about how you're scored Game Resources : explore resources for this year's game Assessments : take the theory and skill assessments for this year's game App Usage : learn how to use this year's scouting app History : learn about the scouting team's history","title":"For Scouts"},{"location":"#for-developers","text":"Open Source: learn about software development tools that are essential for working as a team and maintaining the scouting system. Lesson 1: What is Git? Lesson 2: Collaboration Lesson 3: Build Tools Lesson 4: Documentation Java: learn the essentials of Java needed for Android development and to maintain the scouting system Lesson 1: Intro to Java Lesson 2: Loops, Strings, Math Lesson 3: Methods Lesson 4: Objects Lesson 5: Arrays & Dictionaries Lesson 6: Advanced Java Lesson 7: Advanced OOP Miscellaneous: assorted topics in computer science that are needed to work on parts of the scouting system or to maintain this site File I/O JSON HTTP The Blue Alliance API Java Swing Regex HTML & JavaScript Android: learn everything about Android that you'll need to work on the scouting app Lesson 1: Intro to Android Lesson 2: GUI Components Lesson 3: UX Design Lesson 4: Advanced Techniques Scouting System Maintenance: learn the necessary changes to the system between seasons Lesson 1: The Scouting App Lesson 2: The Scouting Client Lesson 3: The Blue Alliance Library","title":"For Developers"},{"location":"#for-strategists","text":"Game Strategy: learn how to win competitions through strategy and the intersections between you, developers, and the drive team Lesson 1: Kickoff! Lesson 2: Metrics Lesson 3: Pre-Scouting Lesson 4: Competition! Lesson 5: Picklisting Scouting System Usage: learn how to use the scouting system as an analysist Lesson 1: The Scouting App Lesson 2: The Scouting Client Lesson 3: Tableau Lesson 4: Excel","title":"For Strategists:"},{"location":"#for-scouting-leads","text":"Scout Management: learn how to manage scouts throughout the year Lesson 1: Pre-Season Lesson 2: Kickoff! Lesson 3: Competition Lesson 4: Traveling Scout Assessment: learn how to assess scouts and form the travel team Lesson 1: Evaluation System Lesson 2: Theory Lesson 3: Week Zero Lesson 4: The Travel Team","title":"For Scouting Leads"},{"location":"develop/android/L1/","text":"Lesson 1 - Introduction to Java Raider Robotix and Java FRC Team 25, Raider Robotix , uses the Java programming language for programming both the robot and the scouting system. Java is also taught in NBTHS's computer science courses. These lessons will provide you with the building blocks of Java that are necessary to program, maintain, and understand the scouting system. It currently has two components: * Android scouting app - collects data from scouts during events and exports it in JSON (JavaScript Object Notation) files * Every year, this needs to be updated with the correct metrics, events, game manual, and other options, as necessary * Desktop scouting client - compiles the JSON files from the app and outputs spreadsheets of each scouting entry and aggregated statistics for each team * Every year, this needs to be updated with the correct metrics, which includes averages, percentages, probabilities, and standard deviations, in addition to those in the scouting app Starting from the 2017 season, Tableau is used to visualize and analyze the data from the spreadsheets generated by the client. The goal is to have you understand how the scouting system works and be comfortable with changing its code by next season's kickoff. If you want to work on robot programming instead, additional knowledge of WPILib API will be needed. Lesson Structure Generally, several concepts will be explained and grouped together to form a lesson. As each concept is taught, several practice exercises are given for you to check your understanding. At the end of the lesson, one or two problems will be assigned on HackerRank that test your understanding of all concepts in the lesson. The site allows you to check your program against several test cases and will \"grade\" it (pass or fail) instantly. Java Code Structure Java source files have a . java extension and each contain a class , which acts like an object (we'll get to this later). Each class/source file is located in a package , which acts as a folder to organize various files. Inside an executable program is a main method , in which the code inside it executes. In a desktop Java program, the method signature public static void main ( String [] args ) is used, followed by a set of curly braces. Below is an example inside a file called Example . java : // Place import statements here public class Example { public static void main ( String [] args ){ // Write your code to execute here } } As seen above line comments can be written if they are proceeded with two forward slashes ( // ). Anything following the two slashes will be ignored by the compiler when your program executes. Block comments may also be written like this: /* Hi! * I'm a block comment. */ Note the two slashes showing the beginning/end of the comment and the asterisk on each line. Variables Any data or value you use in Java is stored in a variable . A variable can have one of many different datatypes . The following are common datatypes: * int - an integer with a value between -2^31 - 1 and 2^31 -1 ( 123 , 25 , - 900 , 0 , etc.) * double - a positive or negative decimal number ( 1.23 , - 2.5 , 1.0005 , etc.) * boolean - has either a true or false value * String - a sequence of characters, enclosed in a set of quotation marks ( \"Hello World\" , \"1+1=2\" , \"Raider Robotix\" , etc.) You can declare variables with its datatype, followed by a space and its identifier , then a semicolon. The identifier must start with a letter or underscore, then be followed by more letters, underscores, or numbers, with no spaces. Valid identifiers include: * _t * motor1 * MOTOR_SPEED Generally, variables are named in a camelCase notation, where the first word is lowercase, then the remaining words are uppercase. Examples of variable declarations with camelCase naming include: int teleOpGearsCollected ; double avgKpaPerGame ; boolean baselineCrossed ; String robotComment , pilotComment ; //multiple variables can be declared with a comma separating them On the other hand, variables that are constant throughout a program should be named with only uppercase letters and underscores. Examples of these variables include: double TURN_ANGLE_TOLERANCE ; int LEFT_JOYSTICK_PORT ; String RULES_FILEPATH ; int VERSION_NUMBER ; Keep in mind that variables should not have generic identifiers like x or var1 , but ones that are descriptive. A variable can be assigned a value with its identifier followed by the assignment operator , = , and its value. This value can be literal or that of another variable. A variable may be assigned a value and declared at the same time as well. Some examples: int teleOpGearsCollected ; // declaration double avgHighGoalsTeleOp = 12.555 ; // variable declared and value of 12.555 assigned teleOpGearsCollected = 4 ; // assignment afterwards boolean baselineCrossed = true , readyTakeoff = false ; // two variables declared and assigned value String robotComment = \"This is a good robot\" ; double avgTeleOpKpa = avgHighGoalsTeleOp / 3 ; //value dependent on another variable Output Output to the console in Java can be executed with the following statement : System . out . println ( < some value > ); This calls the println method on a value, where < some value > can be a literal value or a variable. Remember to terminate the print statement with a semicolon. For example, executing System . out . println ( teleOpGearsCollected ); System . out . println ( \"gears collected in tele-op in match\" ); System . out . println ( 25 ); will result in the following output: 4 gears collected in tele - op in match 25 If you don't want a new line after the output, the System . out . print ( < some value > ) method may be used. Executing System . out . print ( teleOpGearsCollected ); System . out . println ( \" gears collected in tele-op.\" ); System . out . println ( \"Robots are cool\" ); will result in the following output: 4 gears collected in tele - op . Robots are cool An IDE An IDE (Integrated Development Environment) will be used to program in Java. It allows you to write code, execute, and debug it in one application. I recommend using Eclipse , as NBTHS and the WPILib API uses it, though alternatives like InteliJ and BlueJ exist. We will be using Android Studio as our IDE for Android development. To get started with Eclipse: 1. Download and extract the ZIP file from the link above 2. Run the executable and choose your workspace (default should work) 3. Go to File > New > Java Project and name your project 4. Close the Welcome window 5. Right click your project and go to New > Class, and name your class (without the . java extension) 6. Write your main method (see above) 7. Try replacing the comment with a statement to print Hello World 8. Press the green \"Play\" button to execute your program If there are any syntax errors in your program, Eclipse will underline them in red, and the program will not run. Try fixing them by reading the error message and reviewing your code or by using Google. A Brief Exercise : Assign the values of true , \"Raider Robotix\" , and 25 to variables. Use print statements with the variables and literal values to generate the output Hello World ! It is true that I am on Team 25 , Raider Robotix 25 is the Team Number . Input To take user input, you will need to use a Scanner object. First, you will need to import the class by placing the following import statement before the class starts (see example above): import java.util.Scanner ; The Scanner object can be declared and constructed like this to read from the system console: Scanner myScanner = new Scanner ( System . in ); The datatype is Scanner , and myScanner can be any valid identifier. Note the use of the new keyword to create a new object and the parentheses following. Several methods can be accessed through the Scanner object for different datatypes. A method essentially acts like a function and returns a value to the main program. These may be used to let users assign values to variables: int anInteger = myScanner . nextInt (); String aLine = myScanner . next (); // takes the next whole line Essentially, the dot operator ( . ) shows that the methods nextInt () and nextLine () are written in the Scanner class, and you are accessing them from an outside class. More methods for input can be found by reading the documentation for the class . If the wrong datatype is used, there will be an error in your program. By default, spaces and line breaks separating tokens in the input will result two different variables. For example, if the input is Raider Robotix executing String teamName = myScanner . next (); System . out . println ( teamName ); will output Raider while executing String teamName = myScanner . nextLine (); System . out . println ( teamName ); will output Raider Robotix Exercise Write a program that allows prompts a user to input a string, an integer, and a floating point number, then print all three once they are inputted. Operators Operators in Java allow you to interact between different datatypes. For these examples, we will declare int a = 5 , b = 4 ; double c = 2.5 ; String s = \"Hello\" ; Mathematical Evaluating these operators will result in a number of type int if both are integers, or of type double if at least one is a double : + - adds the number (an int or double ) to the left and right of it a + b is equal to 9 , a + c is equal to 7.5 - - subtracts the number on the right from the left b - a is equal to - 1 , b - c is equal to 1.5 * - multiplies the number to the left and right of it a * b is equal to 20 , b * c is equal to 10.0 / - divides the number on the left by the number on the right. However, if both numbers are int s, integer division will occur. That is, the remainder is discarded, and only the quotient remains. a / c is equal to 2.0 , b / c is equal to 1.6 a / b is equal to 1 , b / a is equal to 0 A literal int value ( 1 ) may be converted into a double value by adding a decimal point and a zero ( 1.0 ) % - the modulus operator, a % b returns the remainder of a / b a % b is equal to 1 , b % a is equal to 4 , a % c is equal to 0.0 Exercises : * Write a program that allows the user to input (integer) dimensions of a rectangular prism and outputs its surface area and volume * Write a program that prints the day of the week of a day, given the day of the week of the first day of the month (where 1=Monday, 7=Sunday) * Write a program that calculates the score of a match in FIRST Steamworks, where the user inputs the number of rotors activated during tele-op/autonomous, high/low goals in tele-op/autonomous, the times the baseline was crossed, the times robots took off, and foul points that were incurred by the opposing alliance Relational Evaluating these operators will result in a boolean value ( true or false ): < - less than, <= - less than or equal to b < a is true , 4.5 < 0 is false - 2 <= c is true , 5 <= 5 is true > - greater than, >= - greater than or equal to == - checks for equality. This can only be used for primitive datatypes, and not objects a == 5 is true , 2.0 == a / c is true false == true is false For strings, the method someString . equals ( /*another string*/ ) is used for equality because a string is an object. We'll get into this more in the next lesson. s . equals ( \"Hello\" ) is true , s . equals ( \"World\" ) is false != - checks if the two objects are not equal a != 5 is false , 1 != a / c is true false != true is true Exercise : Write a program to determine if it is true that a quadratic equation of the form 0=ax^2+bx+c has a real solution, where the user inputs a, b, and c. (Hint: For now the best way to square an integer x is x * x , as x ^ 2 will not evaluate correctly) Logical These operate on boolean values and evaluating them will also result in a boolean value: OR Operator - written as a || b , evaluates to true only if either a or b are true a b a \\ | \\ | b false false false false true true true false true true true true AND Operator - written as a && b , evaluates to true only if both a and b are true a b a && b false false false false true false true false false true true true NOT Operator - written as !a , evaluates to true only if a is false a !a false true true false Exercises * Evaluate the following expressions (without actually writing any code) for when boolean a = true , b = false and for when boolean a = true , b = true : * ( a || b ) && ( ! a || ! b ) * ! ( a && ! b ) || ( ! a && b ) * ! ( a && b ) Some Shortcuts You already learned about the assignment operator. Here are some shortcuts used for assignment with operators, if x and y are numbers and both are already declared and assigned values: x += y ; // same as x = x+y x -= y ; // same as x = x-y x /= y ; // same as x = x/y x %= y ; // same as x = x % y x ++ ; // same as x+=1 x -- ; // same as x-=1 Exercise : What is the value of x after the following is executed? int x = 60 , y = 10 ; y /= 5 ; x %= x - y ; x ++ ; x *= 4 ; Boolean Expressions A boolean expression is any expression that evaluates to true or false . It may contain literals, variables, and any of the above operators. The order of operations for evaluation are: Parentheses NOT Multiplication, division, modulus Addition, subtraction Greater/less than (or equal to) Equivalence/not equivalent AND OR The following are valid boolean expressions if x and y are numbers and b is a boolean : * x >= 5 + y && ! ( y + 5 == 7 || y < 0 || ! b ) * takeoffPercentage / avgTakeoffPercentage + 0.1 >= 1.2 && ( avgKpa >= 30 || avgGears >= 4 ) && teamNum != 25 && ! droppedGearOften Exercises * The XOR (exclusive-or) operator evaluates to be true if either A or B are true, but not both. Write an expression that is logically equivalent to \"A XOR B\" using the AND, OR, and NOT operators * Write a boolean expression to determine if at least 3 ranking points were earned by the red alliance in a match of FIRST Steamworks, given the scores of both the red and blue alliances, the number of gears delivered by the red alliance, whether or not the reserve gear was used, and the number of high/low goals into the red boiler in autonomous/tele-op. Use appropriate identifiers for variables and declare multiple, intermediate boolean expressions as necessary. Conditionals A conditional statement is one that executes if a particular boolean expression is true. The if , else , and else - if statements are written and used as follows: boolean a = < some expression > ; if ( a ){ //Code here executes if expression a is true } else if ( < some boolean expression b > ){ // Code here executes if expression b is true and a is false } else { // Code here executes if a and b are both false } Note that an if statement may be written without any else statements, but else and else - if statements must follow an if statement or an else statement. The boolean expression may also be placed inside the parentheses, rather than assigning its value to a boolean variable. These conditional statements may also be nested inside each other as follows: boolean a = < some expression > ; boolean b = < some expression > ; boolean c = < some expression > ; if ( a ){ if ( c ){ // Code here executes if a and c are true } else { //Code here executes if a is true and c is false } // Code here executes as long as a is true, no matter what the value of c is } else if ( b ){ // Code here executes if expression b is true and a is false, no matter what the value of c is if ( ! c ){ //Code here executes if a is false, b is true, and c is false } } else { // Code here executes if a and b are both false } Exercises * Write a program to determine if a number is even or odd * Write a program that prints the month, given its numerical value (1 to 12) * Write a program that converts a day of the week to a number (Monday = 1, Sunday = 7) * Write a program that converts feet to yards and vice-versa, depending on what the user wants Assignment Download Eclipse and complete the exercises above as necessary to check your understanding. Afterwards, sign up for a HackerRank account and complete the \"A School Day\" program here . I suggest that you write and test the program on Eclipse, then check if it works on HackerRank.","title":"Lesson 1: Intro to Android"},{"location":"develop/android/L1/#lesson-1-introduction-to-java","text":"","title":"Lesson 1 - Introduction to Java"},{"location":"develop/android/L1/#raider-robotix-and-java","text":"FRC Team 25, Raider Robotix , uses the Java programming language for programming both the robot and the scouting system. Java is also taught in NBTHS's computer science courses. These lessons will provide you with the building blocks of Java that are necessary to program, maintain, and understand the scouting system. It currently has two components: * Android scouting app - collects data from scouts during events and exports it in JSON (JavaScript Object Notation) files * Every year, this needs to be updated with the correct metrics, events, game manual, and other options, as necessary * Desktop scouting client - compiles the JSON files from the app and outputs spreadsheets of each scouting entry and aggregated statistics for each team * Every year, this needs to be updated with the correct metrics, which includes averages, percentages, probabilities, and standard deviations, in addition to those in the scouting app Starting from the 2017 season, Tableau is used to visualize and analyze the data from the spreadsheets generated by the client. The goal is to have you understand how the scouting system works and be comfortable with changing its code by next season's kickoff. If you want to work on robot programming instead, additional knowledge of WPILib API will be needed.","title":"Raider Robotix and Java"},{"location":"develop/android/L1/#lesson-structure","text":"Generally, several concepts will be explained and grouped together to form a lesson. As each concept is taught, several practice exercises are given for you to check your understanding. At the end of the lesson, one or two problems will be assigned on HackerRank that test your understanding of all concepts in the lesson. The site allows you to check your program against several test cases and will \"grade\" it (pass or fail) instantly.","title":"Lesson Structure"},{"location":"develop/android/L1/#java-code-structure","text":"Java source files have a . java extension and each contain a class , which acts like an object (we'll get to this later). Each class/source file is located in a package , which acts as a folder to organize various files. Inside an executable program is a main method , in which the code inside it executes. In a desktop Java program, the method signature public static void main ( String [] args ) is used, followed by a set of curly braces. Below is an example inside a file called Example . java : // Place import statements here public class Example { public static void main ( String [] args ){ // Write your code to execute here } } As seen above line comments can be written if they are proceeded with two forward slashes ( // ). Anything following the two slashes will be ignored by the compiler when your program executes. Block comments may also be written like this: /* Hi! * I'm a block comment. */ Note the two slashes showing the beginning/end of the comment and the asterisk on each line.","title":"Java Code Structure"},{"location":"develop/android/L1/#variables","text":"Any data or value you use in Java is stored in a variable . A variable can have one of many different datatypes . The following are common datatypes: * int - an integer with a value between -2^31 - 1 and 2^31 -1 ( 123 , 25 , - 900 , 0 , etc.) * double - a positive or negative decimal number ( 1.23 , - 2.5 , 1.0005 , etc.) * boolean - has either a true or false value * String - a sequence of characters, enclosed in a set of quotation marks ( \"Hello World\" , \"1+1=2\" , \"Raider Robotix\" , etc.) You can declare variables with its datatype, followed by a space and its identifier , then a semicolon. The identifier must start with a letter or underscore, then be followed by more letters, underscores, or numbers, with no spaces. Valid identifiers include: * _t * motor1 * MOTOR_SPEED Generally, variables are named in a camelCase notation, where the first word is lowercase, then the remaining words are uppercase. Examples of variable declarations with camelCase naming include: int teleOpGearsCollected ; double avgKpaPerGame ; boolean baselineCrossed ; String robotComment , pilotComment ; //multiple variables can be declared with a comma separating them On the other hand, variables that are constant throughout a program should be named with only uppercase letters and underscores. Examples of these variables include: double TURN_ANGLE_TOLERANCE ; int LEFT_JOYSTICK_PORT ; String RULES_FILEPATH ; int VERSION_NUMBER ; Keep in mind that variables should not have generic identifiers like x or var1 , but ones that are descriptive. A variable can be assigned a value with its identifier followed by the assignment operator , = , and its value. This value can be literal or that of another variable. A variable may be assigned a value and declared at the same time as well. Some examples: int teleOpGearsCollected ; // declaration double avgHighGoalsTeleOp = 12.555 ; // variable declared and value of 12.555 assigned teleOpGearsCollected = 4 ; // assignment afterwards boolean baselineCrossed = true , readyTakeoff = false ; // two variables declared and assigned value String robotComment = \"This is a good robot\" ; double avgTeleOpKpa = avgHighGoalsTeleOp / 3 ; //value dependent on another variable","title":"Variables"},{"location":"develop/android/L1/#output","text":"Output to the console in Java can be executed with the following statement : System . out . println ( < some value > ); This calls the println method on a value, where < some value > can be a literal value or a variable. Remember to terminate the print statement with a semicolon. For example, executing System . out . println ( teleOpGearsCollected ); System . out . println ( \"gears collected in tele-op in match\" ); System . out . println ( 25 ); will result in the following output: 4 gears collected in tele - op in match 25 If you don't want a new line after the output, the System . out . print ( < some value > ) method may be used. Executing System . out . print ( teleOpGearsCollected ); System . out . println ( \" gears collected in tele-op.\" ); System . out . println ( \"Robots are cool\" ); will result in the following output: 4 gears collected in tele - op . Robots are cool","title":"Output"},{"location":"develop/android/L1/#an-ide","text":"An IDE (Integrated Development Environment) will be used to program in Java. It allows you to write code, execute, and debug it in one application. I recommend using Eclipse , as NBTHS and the WPILib API uses it, though alternatives like InteliJ and BlueJ exist. We will be using Android Studio as our IDE for Android development. To get started with Eclipse: 1. Download and extract the ZIP file from the link above 2. Run the executable and choose your workspace (default should work) 3. Go to File > New > Java Project and name your project 4. Close the Welcome window 5. Right click your project and go to New > Class, and name your class (without the . java extension) 6. Write your main method (see above) 7. Try replacing the comment with a statement to print Hello World 8. Press the green \"Play\" button to execute your program If there are any syntax errors in your program, Eclipse will underline them in red, and the program will not run. Try fixing them by reading the error message and reviewing your code or by using Google. A Brief Exercise : Assign the values of true , \"Raider Robotix\" , and 25 to variables. Use print statements with the variables and literal values to generate the output Hello World ! It is true that I am on Team 25 , Raider Robotix 25 is the Team Number .","title":"An IDE"},{"location":"develop/android/L1/#input","text":"To take user input, you will need to use a Scanner object. First, you will need to import the class by placing the following import statement before the class starts (see example above): import java.util.Scanner ; The Scanner object can be declared and constructed like this to read from the system console: Scanner myScanner = new Scanner ( System . in ); The datatype is Scanner , and myScanner can be any valid identifier. Note the use of the new keyword to create a new object and the parentheses following. Several methods can be accessed through the Scanner object for different datatypes. A method essentially acts like a function and returns a value to the main program. These may be used to let users assign values to variables: int anInteger = myScanner . nextInt (); String aLine = myScanner . next (); // takes the next whole line Essentially, the dot operator ( . ) shows that the methods nextInt () and nextLine () are written in the Scanner class, and you are accessing them from an outside class. More methods for input can be found by reading the documentation for the class . If the wrong datatype is used, there will be an error in your program. By default, spaces and line breaks separating tokens in the input will result two different variables. For example, if the input is Raider Robotix executing String teamName = myScanner . next (); System . out . println ( teamName ); will output Raider while executing String teamName = myScanner . nextLine (); System . out . println ( teamName ); will output Raider Robotix Exercise Write a program that allows prompts a user to input a string, an integer, and a floating point number, then print all three once they are inputted.","title":"Input"},{"location":"develop/android/L1/#operators","text":"Operators in Java allow you to interact between different datatypes. For these examples, we will declare int a = 5 , b = 4 ; double c = 2.5 ; String s = \"Hello\" ;","title":"Operators"},{"location":"develop/android/L1/#mathematical","text":"Evaluating these operators will result in a number of type int if both are integers, or of type double if at least one is a double : + - adds the number (an int or double ) to the left and right of it a + b is equal to 9 , a + c is equal to 7.5 - - subtracts the number on the right from the left b - a is equal to - 1 , b - c is equal to 1.5 * - multiplies the number to the left and right of it a * b is equal to 20 , b * c is equal to 10.0 / - divides the number on the left by the number on the right. However, if both numbers are int s, integer division will occur. That is, the remainder is discarded, and only the quotient remains. a / c is equal to 2.0 , b / c is equal to 1.6 a / b is equal to 1 , b / a is equal to 0 A literal int value ( 1 ) may be converted into a double value by adding a decimal point and a zero ( 1.0 ) % - the modulus operator, a % b returns the remainder of a / b a % b is equal to 1 , b % a is equal to 4 , a % c is equal to 0.0 Exercises : * Write a program that allows the user to input (integer) dimensions of a rectangular prism and outputs its surface area and volume * Write a program that prints the day of the week of a day, given the day of the week of the first day of the month (where 1=Monday, 7=Sunday) * Write a program that calculates the score of a match in FIRST Steamworks, where the user inputs the number of rotors activated during tele-op/autonomous, high/low goals in tele-op/autonomous, the times the baseline was crossed, the times robots took off, and foul points that were incurred by the opposing alliance","title":"Mathematical"},{"location":"develop/android/L1/#relational","text":"Evaluating these operators will result in a boolean value ( true or false ): < - less than, <= - less than or equal to b < a is true , 4.5 < 0 is false - 2 <= c is true , 5 <= 5 is true > - greater than, >= - greater than or equal to == - checks for equality. This can only be used for primitive datatypes, and not objects a == 5 is true , 2.0 == a / c is true false == true is false For strings, the method someString . equals ( /*another string*/ ) is used for equality because a string is an object. We'll get into this more in the next lesson. s . equals ( \"Hello\" ) is true , s . equals ( \"World\" ) is false != - checks if the two objects are not equal a != 5 is false , 1 != a / c is true false != true is true Exercise : Write a program to determine if it is true that a quadratic equation of the form 0=ax^2+bx+c has a real solution, where the user inputs a, b, and c. (Hint: For now the best way to square an integer x is x * x , as x ^ 2 will not evaluate correctly)","title":"Relational"},{"location":"develop/android/L1/#logical","text":"These operate on boolean values and evaluating them will also result in a boolean value: OR Operator - written as a || b , evaluates to true only if either a or b are true a b a \\ | \\ | b false false false false true true true false true true true true AND Operator - written as a && b , evaluates to true only if both a and b are true a b a && b false false false false true false true false false true true true NOT Operator - written as !a , evaluates to true only if a is false a !a false true true false Exercises * Evaluate the following expressions (without actually writing any code) for when boolean a = true , b = false and for when boolean a = true , b = true : * ( a || b ) && ( ! a || ! b ) * ! ( a && ! b ) || ( ! a && b ) * ! ( a && b )","title":"Logical"},{"location":"develop/android/L1/#some-shortcuts","text":"You already learned about the assignment operator. Here are some shortcuts used for assignment with operators, if x and y are numbers and both are already declared and assigned values: x += y ; // same as x = x+y x -= y ; // same as x = x-y x /= y ; // same as x = x/y x %= y ; // same as x = x % y x ++ ; // same as x+=1 x -- ; // same as x-=1 Exercise : What is the value of x after the following is executed? int x = 60 , y = 10 ; y /= 5 ; x %= x - y ; x ++ ; x *= 4 ;","title":"Some Shortcuts"},{"location":"develop/android/L1/#boolean-expressions","text":"A boolean expression is any expression that evaluates to true or false . It may contain literals, variables, and any of the above operators. The order of operations for evaluation are: Parentheses NOT Multiplication, division, modulus Addition, subtraction Greater/less than (or equal to) Equivalence/not equivalent AND OR The following are valid boolean expressions if x and y are numbers and b is a boolean : * x >= 5 + y && ! ( y + 5 == 7 || y < 0 || ! b ) * takeoffPercentage / avgTakeoffPercentage + 0.1 >= 1.2 && ( avgKpa >= 30 || avgGears >= 4 ) && teamNum != 25 && ! droppedGearOften Exercises * The XOR (exclusive-or) operator evaluates to be true if either A or B are true, but not both. Write an expression that is logically equivalent to \"A XOR B\" using the AND, OR, and NOT operators * Write a boolean expression to determine if at least 3 ranking points were earned by the red alliance in a match of FIRST Steamworks, given the scores of both the red and blue alliances, the number of gears delivered by the red alliance, whether or not the reserve gear was used, and the number of high/low goals into the red boiler in autonomous/tele-op. Use appropriate identifiers for variables and declare multiple, intermediate boolean expressions as necessary.","title":"Boolean Expressions"},{"location":"develop/android/L1/#conditionals","text":"A conditional statement is one that executes if a particular boolean expression is true. The if , else , and else - if statements are written and used as follows: boolean a = < some expression > ; if ( a ){ //Code here executes if expression a is true } else if ( < some boolean expression b > ){ // Code here executes if expression b is true and a is false } else { // Code here executes if a and b are both false } Note that an if statement may be written without any else statements, but else and else - if statements must follow an if statement or an else statement. The boolean expression may also be placed inside the parentheses, rather than assigning its value to a boolean variable. These conditional statements may also be nested inside each other as follows: boolean a = < some expression > ; boolean b = < some expression > ; boolean c = < some expression > ; if ( a ){ if ( c ){ // Code here executes if a and c are true } else { //Code here executes if a is true and c is false } // Code here executes as long as a is true, no matter what the value of c is } else if ( b ){ // Code here executes if expression b is true and a is false, no matter what the value of c is if ( ! c ){ //Code here executes if a is false, b is true, and c is false } } else { // Code here executes if a and b are both false } Exercises * Write a program to determine if a number is even or odd * Write a program that prints the month, given its numerical value (1 to 12) * Write a program that converts a day of the week to a number (Monday = 1, Sunday = 7) * Write a program that converts feet to yards and vice-versa, depending on what the user wants","title":"Conditionals"},{"location":"develop/android/L1/#assignment","text":"Download Eclipse and complete the exercises above as necessary to check your understanding. Afterwards, sign up for a HackerRank account and complete the \"A School Day\" program here . I suggest that you write and test the program on Eclipse, then check if it works on HackerRank.","title":"Assignment"},{"location":"develop/android/L2/","text":"Lesson 2 - Loops, Strings, Math After a (probably pretty long) first lesson, let's explore a couple more features of Java and see what you can do with everything that you learned. Loops Loops are used to execute a block of code enclosed in a set of braces ( {} ) multiple times. After all, computers are very good at doing the same thing over and over again! The number of times a block executes depends on a boolean expression. while Loops while loops execute as long as a boolean expression is true . It may not execute at all if the expression is false before entering the loop. while ( /*some boolean expression*/ ){ //Execute code here multiple times as long as the expression is true } Remember that the boolean expression should become false at some point during the execution of the code in the loop. Otherwise, an infinite loop will be created. For example, the following will print the numbers from 1 to 10 (inclusive): int counter = 1 ; while ( counter <= 10 ){ System . out . println ( counter ); counter ++ ; } do - while loops may also be written. The main difference between these and while loops is that the boolean expression must be true at the end of the loop, not at the beginning. The following prints the numbers from 1 to 10 (inclusive): int counter = - 1 ; do { counter ++ ; System . out . println ( counter ); } while ( counter < 10 ); for Loops for loops provide a more controlled way for iterating through a loop multiple times. There are three components to the for loop: the initial statement, the exit condition (boolean expression), and the post-excution statement. The example for ( /*initial statement*/ ; /*exit condition*/ ; /*post-execution statement*/ ){ //Code to be executed each loop } is essentially equal to the following while loop: //Initial statement while ( /*exit condition*/ ){ //Code to be executed each loop //Post-execution statement } The for loop is commonly used to execute a loop a certain number of times. Below, the loop prints the numbers from 0 to 9 (10 iterations): for ( int count = 0 ; i < 10 ; count ++ ){ System . out . println ( count ); } Keep in mind that the variable count is declared within the loop, and it cannot accessed outside it. Loops may also be placed inside each other. For example, executing for ( int row = 1 ; row <= 12 ; row ++ ){ for ( int col = 1 ; col <= 12 ; col ++ ){ System . out . print ( row * col ); System . out . print ( \" \" ); //adds a space } System . out . println (); //line break } will print a (poorly formatted) times table. Note that all three parts of a for loop are optional. That is, a loop like for (;;) { //something } will execute forever. Questions Determine the number of times the following for loops will execute. for ( int i = 4 ; i <= 8 ; i += 2 ) { /*do something*/ } for ( int i = 10 ; i >= 0 ; i -= 3 ) { /*do something*/ } for ( int j = 2 ; j >= 4 ; j ++ ) { /*do something*/ } Exercises Write a program that computes the sum of all odd integers from 1 to a number specified by the user Write a program that computes b^e (a number raised to the power of an exponent), where b and e are positive integers Write a program that allows the user to enter a number, setSize . setSize numbers, num , follow and are inputted by the user. Print the average, largest, and smallest of the numbers. Loop Control There are two control statements that are used with loops: break The break statement will immediately exit a while or for loop. This can be useful if you're looking for a specific value, and you want the loop to end after you've found that value. For instance, in the below example, the loop will terminate immediately after the value key is found: int key = 8 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( i == key ) { System . out . println ( \"Found\" ); break ; } System . out . println ( \"Not found...\" ); } As a result, Not found ... will be printed out eight times at first, followed by Found . The loop will then terminate. The break statement will be more useful after you learn about arrays. continue The continue statement will immediately go to the next iteration of a for or while loop, bypassing all statements after it. This could be used when you only want to execute a loop for some values. Of course, an if - else statement can often accomplish the same thing, but break and continue statements can prevent too many nested blocks of code. For instance, the following block of code for ( int i = 0 ; i < 4 ; i ++ ) { System . out . println ( \"Going... \" + i ); if ( i >= 2 ) { continue ; } System . out . println ( \"Here\" ); } will print Going ... 0 Here Going ... 1 Here Going ... 2 Going ... 3 Characters In addition to the primitive data types ( boolean , int , double ) we learned about before, char s represent one of the 256 ASCII characters . These include the numbers, standard symbols and punctuation on a keyboard, and both uppercase and lowercase letters. A char is assigned a value with the declaration char allianceColor = 'R' ; Note the use of single quotation marks rather than double quotation marks (which are used for String s) and that a variable of type char may only contain a single character. Escape characters are the first 32 ASCII characters, which serve special functions. The most commonly used is '\\n' , which creates a line break. In addition, quotation marks must be escaped. Thus, executing the following code char quote1 = '\\'' ; char quote2 = '\\\"' ; char newLine = '\\n' System . out . print ( quote1 ); System . out . print ( newLine ); System . out . print ( quote2 ); will print ' \" Note that strings can be thought of as a series of char s concatenated together. For instance, executing String someText = \"Kickoff, 2017 \\n As we anticipated the new game, the livestream blared, \\\" STEAM POWERED! STEAM POWERED! STEAM POWERED! \\\" \" ; System . out . println ( someText ); will print Kickoff , 2017 As we anticipated the new game , the livestream blared , \"STEAM POWERED! STEAM POWERED! STEAM POWERED!\" The value of characters may be compared with the equivalence ( == ) operator. For example, allianceColor == 'R' is true . Note, however, that a character is not equal its int equivalent. That is, '1' == 1 is false . String Manipulation The String class in Java contains many methods to manipulate strings. We will present an overview of the most useful ones, though you may read the full documentation here . Concatenation A string can be concatenated , or joined together, with other strings or primitive datatypes (and literals) with the + operator. For example, executing the following: String mascot = \"Raider\" ; int teamNum = 25 ; String teamName = mascot + \" Robotix\" ; System . out . println ( \"The year is \" + 2017 ); System . out . println ( \"I am on Team \" + teamNum + \", \" + teamName ); will print The year is 2017 I am on Team 25 , Raider Robotix You may also concatenate a string onto the end of another with the += operator. Executing String s = \"Hello\" ; s += \" World!\" ; System . out . println ( s ); will print Hello World ! . String Properties You can check the length of a string (number of characters) with the string . length () method. Executing String s = \"Hello\" ; System . out . println ( s + \" is \" + s . length () + \" characters long\" ); System . out . print ( \"World!\" . length ()); will print Hello is 5 characters long 6 You can also check if a string contains a specific character sequence with the string . contains ( < character sequence > ) method, which returns a boolean value. If String s = \"Hello\" ; is declared, s . contains ( \"ell\" ) returns true , while s . contains ( \"f\" ) returns false . Parsing a String You may want to parse through a string sometimes, or check the sequence of its characters. The string . charAt ( /*index*/ ) method will return the character currently at the index. There are two things you should know about the method: The method will return a value of type char (character), rather than String . The index is a value that is greater than or equal to 0 and less than string . length () . That is, the index of the first character in the string is 0 , and the index of the last character in the string is string . length () - 1 . If String s = \"World\" ; is declared, s . charAt ( 0 ) returns 'W' , s . charAt ( 3 ) returns 'l' , and s . charAt ( 4 ) returns 'd' . A standard way to parse through all of the characters of a string is with the following for loop: String str = \"Hello World!\" ; for ( int i = 0 ; i < str . length (); i ++ ){ char currentChar = str . charAt ( i ); //Do something here } Substrings Suppose you want to return a slice of a string, known as a substring, such as the first letter four letters of String s = \"Raider Robotix\" ; . An easy-to-understand way would be to use string parsing, similar to what we did above: String s = \"Raider Robotix\" ; String result = \"\" ; // an empty string for ( int i = 0 ; i < 4 && i < s . length (); i ++ ){ result += s . charAt ( i ); } System . out . println ( result ); This would print out Raid . Note that the expression i < s . length () was still present in the exit condition in order to prevent errors if s was an input string that was less than four characters long. However, a faster way to get result would be to use the substring ( beginIndex , endIndex ) method, in which beginIndex and endIndex are integers that represent the indicies that you want to search. Similar to the for loop above, beginIndex is inclusive, while endIndex is exclusive. Here are some examples: s . substring ( 0 , 4 ); returns Raid s . substring ( 7 , s . length ()); returns Robotix \"hamburger\" . substring ( 4 , 8 ); returns urge Miscellaneous String Functions Assume that String s = \"Hello\" ; is declared in the following examples: s . toLowerCase (); returns hello s . toUpperCase (); returns HELLO s . indexOf ( \"l\" ); returns 2 (the first occurence of l in s ), while s . lastIndexOf ( \"l\" ) returns 3 s . concat ( \"world\" ); returns Helloworld As mentioned before, string equality is checked with s . equals ( \"Hello\" ); , which would return true . On the other hand, after declaring String anotherString = \"Hello\" ; , the boolean expression s == anotherString || s == \"Hello\" would be false , as string are objects , not primitives . Exercises * Write a program to reverse a string if it has an R in it. * Write a program to check if a string is a palindrome (reads the same backward as forward, such as racecar) * Write a program to replaces all commas from a string with semicolons The Math Class The Math class contains several methods that you may find helpful. It is imported by default, and documentation is found here . For these examples, we will declare double a = 4.5 , b = - 2.5 ; Math . abs ( b ) : takes the absolute value of a number, returns 2.5 in the example Math . ceil ( a ) : takes the ceiling of a number (rounds it up if it is a decimal), returns 5 in the example Math . floor ( a ) : takes the floor of a number (rounds it down if it is a decimal), returns 4 in the example Math . pow ( a - 0.5 , - b + 0.5 ) : takes the first number to the power of the second number, returns 125.0 in the example Math . sqrt ( a - 0.5 ) : takes the square root of a number, returns 2.0 in this example Math . PI : returns the value of pi (3.141592653589793) Math . random () : returns a random double in the interval [0.0, 1.0). This can be used to generate a random integer within a particular range by clamping the number down, then casting it to an int . For example, if you want a random integer in the interval [ lower , upper ], you would declare int randInt = ( int ) ( Math . random () * ( upper - lower )) + lower ; . Try it out! Exercises * Write a program that solves quadratic equations of the form 0=ax^2+bx+c for x, where a, b, and c are coefficients given by the user * Write a program that calculates the average of a data set, given the numbers in the set and its length * Write a program to find the surface area and volume of a square pyramid, given its side length and height * Write a program to round a number to a specific number of decimal places Assignment Complete the \"Raider Robotix Printer\" and \"Binary Converter\" programs on HackerRank.","title":"Lesson 2: GUI Components"},{"location":"develop/android/L2/#lesson-2-loops-strings-math","text":"After a (probably pretty long) first lesson, let's explore a couple more features of Java and see what you can do with everything that you learned.","title":"Lesson 2 - Loops, Strings, Math"},{"location":"develop/android/L2/#loops","text":"Loops are used to execute a block of code enclosed in a set of braces ( {} ) multiple times. After all, computers are very good at doing the same thing over and over again! The number of times a block executes depends on a boolean expression.","title":"Loops"},{"location":"develop/android/L2/#while-loops","text":"while loops execute as long as a boolean expression is true . It may not execute at all if the expression is false before entering the loop. while ( /*some boolean expression*/ ){ //Execute code here multiple times as long as the expression is true } Remember that the boolean expression should become false at some point during the execution of the code in the loop. Otherwise, an infinite loop will be created. For example, the following will print the numbers from 1 to 10 (inclusive): int counter = 1 ; while ( counter <= 10 ){ System . out . println ( counter ); counter ++ ; } do - while loops may also be written. The main difference between these and while loops is that the boolean expression must be true at the end of the loop, not at the beginning. The following prints the numbers from 1 to 10 (inclusive): int counter = - 1 ; do { counter ++ ; System . out . println ( counter ); } while ( counter < 10 );","title":"while Loops"},{"location":"develop/android/L2/#for-loops","text":"for loops provide a more controlled way for iterating through a loop multiple times. There are three components to the for loop: the initial statement, the exit condition (boolean expression), and the post-excution statement. The example for ( /*initial statement*/ ; /*exit condition*/ ; /*post-execution statement*/ ){ //Code to be executed each loop } is essentially equal to the following while loop: //Initial statement while ( /*exit condition*/ ){ //Code to be executed each loop //Post-execution statement } The for loop is commonly used to execute a loop a certain number of times. Below, the loop prints the numbers from 0 to 9 (10 iterations): for ( int count = 0 ; i < 10 ; count ++ ){ System . out . println ( count ); } Keep in mind that the variable count is declared within the loop, and it cannot accessed outside it. Loops may also be placed inside each other. For example, executing for ( int row = 1 ; row <= 12 ; row ++ ){ for ( int col = 1 ; col <= 12 ; col ++ ){ System . out . print ( row * col ); System . out . print ( \" \" ); //adds a space } System . out . println (); //line break } will print a (poorly formatted) times table. Note that all three parts of a for loop are optional. That is, a loop like for (;;) { //something } will execute forever. Questions Determine the number of times the following for loops will execute. for ( int i = 4 ; i <= 8 ; i += 2 ) { /*do something*/ } for ( int i = 10 ; i >= 0 ; i -= 3 ) { /*do something*/ } for ( int j = 2 ; j >= 4 ; j ++ ) { /*do something*/ } Exercises Write a program that computes the sum of all odd integers from 1 to a number specified by the user Write a program that computes b^e (a number raised to the power of an exponent), where b and e are positive integers Write a program that allows the user to enter a number, setSize . setSize numbers, num , follow and are inputted by the user. Print the average, largest, and smallest of the numbers.","title":"for Loops"},{"location":"develop/android/L2/#loop-control","text":"There are two control statements that are used with loops:","title":"Loop Control"},{"location":"develop/android/L2/#break","text":"The break statement will immediately exit a while or for loop. This can be useful if you're looking for a specific value, and you want the loop to end after you've found that value. For instance, in the below example, the loop will terminate immediately after the value key is found: int key = 8 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( i == key ) { System . out . println ( \"Found\" ); break ; } System . out . println ( \"Not found...\" ); } As a result, Not found ... will be printed out eight times at first, followed by Found . The loop will then terminate. The break statement will be more useful after you learn about arrays.","title":"break"},{"location":"develop/android/L2/#continue","text":"The continue statement will immediately go to the next iteration of a for or while loop, bypassing all statements after it. This could be used when you only want to execute a loop for some values. Of course, an if - else statement can often accomplish the same thing, but break and continue statements can prevent too many nested blocks of code. For instance, the following block of code for ( int i = 0 ; i < 4 ; i ++ ) { System . out . println ( \"Going... \" + i ); if ( i >= 2 ) { continue ; } System . out . println ( \"Here\" ); } will print Going ... 0 Here Going ... 1 Here Going ... 2 Going ... 3","title":"continue"},{"location":"develop/android/L2/#characters","text":"In addition to the primitive data types ( boolean , int , double ) we learned about before, char s represent one of the 256 ASCII characters . These include the numbers, standard symbols and punctuation on a keyboard, and both uppercase and lowercase letters. A char is assigned a value with the declaration char allianceColor = 'R' ; Note the use of single quotation marks rather than double quotation marks (which are used for String s) and that a variable of type char may only contain a single character. Escape characters are the first 32 ASCII characters, which serve special functions. The most commonly used is '\\n' , which creates a line break. In addition, quotation marks must be escaped. Thus, executing the following code char quote1 = '\\'' ; char quote2 = '\\\"' ; char newLine = '\\n' System . out . print ( quote1 ); System . out . print ( newLine ); System . out . print ( quote2 ); will print ' \" Note that strings can be thought of as a series of char s concatenated together. For instance, executing String someText = \"Kickoff, 2017 \\n As we anticipated the new game, the livestream blared, \\\" STEAM POWERED! STEAM POWERED! STEAM POWERED! \\\" \" ; System . out . println ( someText ); will print Kickoff , 2017 As we anticipated the new game , the livestream blared , \"STEAM POWERED! STEAM POWERED! STEAM POWERED!\" The value of characters may be compared with the equivalence ( == ) operator. For example, allianceColor == 'R' is true . Note, however, that a character is not equal its int equivalent. That is, '1' == 1 is false .","title":"Characters"},{"location":"develop/android/L2/#string-manipulation","text":"The String class in Java contains many methods to manipulate strings. We will present an overview of the most useful ones, though you may read the full documentation here .","title":"String Manipulation"},{"location":"develop/android/L2/#concatenation","text":"A string can be concatenated , or joined together, with other strings or primitive datatypes (and literals) with the + operator. For example, executing the following: String mascot = \"Raider\" ; int teamNum = 25 ; String teamName = mascot + \" Robotix\" ; System . out . println ( \"The year is \" + 2017 ); System . out . println ( \"I am on Team \" + teamNum + \", \" + teamName ); will print The year is 2017 I am on Team 25 , Raider Robotix You may also concatenate a string onto the end of another with the += operator. Executing String s = \"Hello\" ; s += \" World!\" ; System . out . println ( s ); will print Hello World ! .","title":"Concatenation"},{"location":"develop/android/L2/#string-properties","text":"You can check the length of a string (number of characters) with the string . length () method. Executing String s = \"Hello\" ; System . out . println ( s + \" is \" + s . length () + \" characters long\" ); System . out . print ( \"World!\" . length ()); will print Hello is 5 characters long 6 You can also check if a string contains a specific character sequence with the string . contains ( < character sequence > ) method, which returns a boolean value. If String s = \"Hello\" ; is declared, s . contains ( \"ell\" ) returns true , while s . contains ( \"f\" ) returns false .","title":"String Properties"},{"location":"develop/android/L2/#parsing-a-string","text":"You may want to parse through a string sometimes, or check the sequence of its characters. The string . charAt ( /*index*/ ) method will return the character currently at the index. There are two things you should know about the method: The method will return a value of type char (character), rather than String . The index is a value that is greater than or equal to 0 and less than string . length () . That is, the index of the first character in the string is 0 , and the index of the last character in the string is string . length () - 1 . If String s = \"World\" ; is declared, s . charAt ( 0 ) returns 'W' , s . charAt ( 3 ) returns 'l' , and s . charAt ( 4 ) returns 'd' . A standard way to parse through all of the characters of a string is with the following for loop: String str = \"Hello World!\" ; for ( int i = 0 ; i < str . length (); i ++ ){ char currentChar = str . charAt ( i ); //Do something here }","title":"Parsing a String"},{"location":"develop/android/L2/#substrings","text":"Suppose you want to return a slice of a string, known as a substring, such as the first letter four letters of String s = \"Raider Robotix\" ; . An easy-to-understand way would be to use string parsing, similar to what we did above: String s = \"Raider Robotix\" ; String result = \"\" ; // an empty string for ( int i = 0 ; i < 4 && i < s . length (); i ++ ){ result += s . charAt ( i ); } System . out . println ( result ); This would print out Raid . Note that the expression i < s . length () was still present in the exit condition in order to prevent errors if s was an input string that was less than four characters long. However, a faster way to get result would be to use the substring ( beginIndex , endIndex ) method, in which beginIndex and endIndex are integers that represent the indicies that you want to search. Similar to the for loop above, beginIndex is inclusive, while endIndex is exclusive. Here are some examples: s . substring ( 0 , 4 ); returns Raid s . substring ( 7 , s . length ()); returns Robotix \"hamburger\" . substring ( 4 , 8 ); returns urge","title":"Substrings"},{"location":"develop/android/L2/#miscellaneous-string-functions","text":"Assume that String s = \"Hello\" ; is declared in the following examples: s . toLowerCase (); returns hello s . toUpperCase (); returns HELLO s . indexOf ( \"l\" ); returns 2 (the first occurence of l in s ), while s . lastIndexOf ( \"l\" ) returns 3 s . concat ( \"world\" ); returns Helloworld As mentioned before, string equality is checked with s . equals ( \"Hello\" ); , which would return true . On the other hand, after declaring String anotherString = \"Hello\" ; , the boolean expression s == anotherString || s == \"Hello\" would be false , as string are objects , not primitives . Exercises * Write a program to reverse a string if it has an R in it. * Write a program to check if a string is a palindrome (reads the same backward as forward, such as racecar) * Write a program to replaces all commas from a string with semicolons","title":"Miscellaneous String Functions"},{"location":"develop/android/L2/#the-math-class","text":"The Math class contains several methods that you may find helpful. It is imported by default, and documentation is found here . For these examples, we will declare double a = 4.5 , b = - 2.5 ; Math . abs ( b ) : takes the absolute value of a number, returns 2.5 in the example Math . ceil ( a ) : takes the ceiling of a number (rounds it up if it is a decimal), returns 5 in the example Math . floor ( a ) : takes the floor of a number (rounds it down if it is a decimal), returns 4 in the example Math . pow ( a - 0.5 , - b + 0.5 ) : takes the first number to the power of the second number, returns 125.0 in the example Math . sqrt ( a - 0.5 ) : takes the square root of a number, returns 2.0 in this example Math . PI : returns the value of pi (3.141592653589793) Math . random () : returns a random double in the interval [0.0, 1.0). This can be used to generate a random integer within a particular range by clamping the number down, then casting it to an int . For example, if you want a random integer in the interval [ lower , upper ], you would declare int randInt = ( int ) ( Math . random () * ( upper - lower )) + lower ; . Try it out! Exercises * Write a program that solves quadratic equations of the form 0=ax^2+bx+c for x, where a, b, and c are coefficients given by the user * Write a program that calculates the average of a data set, given the numbers in the set and its length * Write a program to find the surface area and volume of a square pyramid, given its side length and height * Write a program to round a number to a specific number of decimal places","title":"The Math Class"},{"location":"develop/android/L2/#assignment","text":"Complete the \"Raider Robotix Printer\" and \"Binary Converter\" programs on HackerRank.","title":"Assignment"},{"location":"develop/android/L3/","text":"Lesson 3 - Methods Here's a short lesson on one of the building blocks of Java that will prepare you for object-orientated programming: methods. Method signature A method (also known as a function in other languages) is essentially a function, very similar to one that you would encounter in math class. It has an input, an output, and a name (or identifier), though these must have specific data types (think a limited domain/range). Here is a sample method ( isEven ) being declared within a class: public class Example { public boolean isEven ( int num ){ if ( num % 2 == 0 ){ return true ; } return false ; } public static void main ( String [] args ){ //main method //code executed here first } } In this example, the method signature is simply public boolean isEven ( int num ) . It consists of visibility modifiers ( public , private , protected , etc.), a return type ( boolean ), a method identifier ( isEven ), and a set of parameters ( int num ). These parameters must each have a datatype, followed by an identifier, similar to declaring a variable. To list multiple parameters, list each one individually within the parentheses, then separate them with a comma, like in the following example: public int getNumRpPowerUp ( int redScore , int blueScore , boolean autoQuestComplete , int numClimbs , boolean levitateUsed ){ int totalRp = 0 ; if ( redScore > blueScore ) totalRp += 2 ; if ( redScore == blueScore ) totalRp ++ ; if ( autoQuestComplete ) totalRp ++ if ( numClimbs == 3 || numClimbs == 2 && levitateUsed ) totalRp ++ return totalRp ; } Note that a value with the same type as the specified return type ( int in this case) must be returned by the method. This is accomplished by typing the word return followed by a variable or literal value of the specified return type. For instance, the statement return 0 ; would be valid in getNumRpPowerUp as well. Note that the method immediately ends once a return statement is executed. It it possible for a method to have no parameters and/or return type as well. With no parameters, simply leave the contents of the parentheses following the method name blank: public String getInfoString (){ return \"Hello World!\" ; } If you don't want to return a value from the method, the return type should be specified as void . A return statement is not necessary: public void printInfo ( int currentMatchNum , String scoutName ){ System . out . println ( scoutName + \" - Match \" + currentMatchNum ); } You've already used methods to find properties of an object or to compute values, such as with str . length () or Math . pow ( base , power ) . In general, a method call is accomplished by typing the method name, followed by its parameters. The return value (if there is one) can then be used, either within a conditional statement, loop, or assigned to a variable: int red = 200 , blue = 30 , climbs = 1 ; boolean levitated = true ; int rpGained = getNumRpPowerUp ( red , blue , true , climbs , levitated ); while ( isEven ( rpGained )){ //do something } Why methods? So, why are methods so important if they're just executing a block of pre-written code? Well, creating multiple methods in an application or program allows you to break down a problem and do certain tasks repeatedly. For instance, if you wanted to test if a series of numbers were even in different parts of a program, it would be easier to make a call to isEven ( num ) rather than remembering that if a number mod 2 is 0, it is even. Another way to structure an application is to have methods responsible for specific tasks, such as saving a file or verifying if a password matches the one that was stored. As long as you test a method after you write it and ensure it gives the correct output for a variety of input parameters, you can use it throughout an application without needing to refer back to the actual method's source code. That also makes it easy to collaborate with each other, as each person working on a project could be responsible for writing and testing one method; as long as those work independently, you could implement them together in the final product. Overloading methods Sometimes, a method should be able to have different set of parameters, of different data types. In this case, the parameter list will need to be modfied: public double average ( int num1 , int num2 ){ return ( num1 + num2 ) / 2.0 ; } public double average ( double a , double b ){ return ( a + b ) / 2.0 ; } Depending on the datatypes of the parameters when you make the method call, the compiler will know which method to execute. Note that the return type for a particular method name must always be the same, and a method cannot be overloaded if its signature is otherwise identical (parameters have the same datatypes, in the same order). Recursion Like in math, methods can call themselves or other methods within the body of their code. For instance, the following returns the n th Fibonacci number (1, 1, 2, 3, 5, ...): int fib ( int n ){ if ( n == 1 ) return 1 ; if ( n == 2 ) return 1 ; return fib ( n - 1 ) + fib ( n - 2 ); } Recursion is useful for creating simple methods, but their running time can sometimes be slow, and you must always ensure that you reach a base case ( n == 1 or n == 2 in this example) that returns a literal value. Refer to the binary search method if you want to see a more complex example of recursion. Algorithmic challenges Do as many as you want, until you get a good feel of when to implement methods and how to break down a problem: Write a recursive method to compute the factorial of a number. Note that 0! is equal to 1. Write a program that takes any English sentence without punctuation as an input, then converts it to Pig Latin . Implement a more efficient (non-recursive) algorithm to find the n th Fibonacci number Determine the sum of all prime numbers from 2 to a number specified by the user. A number is superb if and only if the sum of all of its factors (excluding itself) is less than a number. Write a program to determine the number of superb numbers between two numbers (e.g. 1 and 100) that are specified by the user. Given a series of variable identifiers in camelCase, identify the number of actual words in the string (e.g. numberOfRankingPoints has four actual words). Given the length of a set of integers S, followed the elements (numbers) of S, determine if S contains only consecutive integers, without repeats (e.g. {3, 5, 4, 6} does, while {6, 4, 3} and {1, 2, 2, 3} do not). Given a series of lowercase strings without spaces or punctuation, determine if any two adjacent strings (inputted right after each other) are anagrams of each other. Write a program to determine if a number is a palindrome. Write methods that compute the least common multiple and greatest common factor of two positive integers. Please email or DM me via Slack any challenges that you finish for feedback!","title":"Lesson 3: UX Design"},{"location":"develop/android/L3/#lesson-3-methods","text":"Here's a short lesson on one of the building blocks of Java that will prepare you for object-orientated programming: methods.","title":"Lesson 3 - Methods"},{"location":"develop/android/L3/#method-signature","text":"A method (also known as a function in other languages) is essentially a function, very similar to one that you would encounter in math class. It has an input, an output, and a name (or identifier), though these must have specific data types (think a limited domain/range). Here is a sample method ( isEven ) being declared within a class: public class Example { public boolean isEven ( int num ){ if ( num % 2 == 0 ){ return true ; } return false ; } public static void main ( String [] args ){ //main method //code executed here first } } In this example, the method signature is simply public boolean isEven ( int num ) . It consists of visibility modifiers ( public , private , protected , etc.), a return type ( boolean ), a method identifier ( isEven ), and a set of parameters ( int num ). These parameters must each have a datatype, followed by an identifier, similar to declaring a variable. To list multiple parameters, list each one individually within the parentheses, then separate them with a comma, like in the following example: public int getNumRpPowerUp ( int redScore , int blueScore , boolean autoQuestComplete , int numClimbs , boolean levitateUsed ){ int totalRp = 0 ; if ( redScore > blueScore ) totalRp += 2 ; if ( redScore == blueScore ) totalRp ++ ; if ( autoQuestComplete ) totalRp ++ if ( numClimbs == 3 || numClimbs == 2 && levitateUsed ) totalRp ++ return totalRp ; } Note that a value with the same type as the specified return type ( int in this case) must be returned by the method. This is accomplished by typing the word return followed by a variable or literal value of the specified return type. For instance, the statement return 0 ; would be valid in getNumRpPowerUp as well. Note that the method immediately ends once a return statement is executed. It it possible for a method to have no parameters and/or return type as well. With no parameters, simply leave the contents of the parentheses following the method name blank: public String getInfoString (){ return \"Hello World!\" ; } If you don't want to return a value from the method, the return type should be specified as void . A return statement is not necessary: public void printInfo ( int currentMatchNum , String scoutName ){ System . out . println ( scoutName + \" - Match \" + currentMatchNum ); } You've already used methods to find properties of an object or to compute values, such as with str . length () or Math . pow ( base , power ) . In general, a method call is accomplished by typing the method name, followed by its parameters. The return value (if there is one) can then be used, either within a conditional statement, loop, or assigned to a variable: int red = 200 , blue = 30 , climbs = 1 ; boolean levitated = true ; int rpGained = getNumRpPowerUp ( red , blue , true , climbs , levitated ); while ( isEven ( rpGained )){ //do something }","title":"Method signature"},{"location":"develop/android/L3/#why-methods","text":"So, why are methods so important if they're just executing a block of pre-written code? Well, creating multiple methods in an application or program allows you to break down a problem and do certain tasks repeatedly. For instance, if you wanted to test if a series of numbers were even in different parts of a program, it would be easier to make a call to isEven ( num ) rather than remembering that if a number mod 2 is 0, it is even. Another way to structure an application is to have methods responsible for specific tasks, such as saving a file or verifying if a password matches the one that was stored. As long as you test a method after you write it and ensure it gives the correct output for a variety of input parameters, you can use it throughout an application without needing to refer back to the actual method's source code. That also makes it easy to collaborate with each other, as each person working on a project could be responsible for writing and testing one method; as long as those work independently, you could implement them together in the final product.","title":"Why methods?"},{"location":"develop/android/L3/#overloading-methods","text":"Sometimes, a method should be able to have different set of parameters, of different data types. In this case, the parameter list will need to be modfied: public double average ( int num1 , int num2 ){ return ( num1 + num2 ) / 2.0 ; } public double average ( double a , double b ){ return ( a + b ) / 2.0 ; } Depending on the datatypes of the parameters when you make the method call, the compiler will know which method to execute. Note that the return type for a particular method name must always be the same, and a method cannot be overloaded if its signature is otherwise identical (parameters have the same datatypes, in the same order).","title":"Overloading methods"},{"location":"develop/android/L3/#recursion","text":"Like in math, methods can call themselves or other methods within the body of their code. For instance, the following returns the n th Fibonacci number (1, 1, 2, 3, 5, ...): int fib ( int n ){ if ( n == 1 ) return 1 ; if ( n == 2 ) return 1 ; return fib ( n - 1 ) + fib ( n - 2 ); } Recursion is useful for creating simple methods, but their running time can sometimes be slow, and you must always ensure that you reach a base case ( n == 1 or n == 2 in this example) that returns a literal value. Refer to the binary search method if you want to see a more complex example of recursion.","title":"Recursion"},{"location":"develop/android/L3/#algorithmic-challenges","text":"Do as many as you want, until you get a good feel of when to implement methods and how to break down a problem: Write a recursive method to compute the factorial of a number. Note that 0! is equal to 1. Write a program that takes any English sentence without punctuation as an input, then converts it to Pig Latin . Implement a more efficient (non-recursive) algorithm to find the n th Fibonacci number Determine the sum of all prime numbers from 2 to a number specified by the user. A number is superb if and only if the sum of all of its factors (excluding itself) is less than a number. Write a program to determine the number of superb numbers between two numbers (e.g. 1 and 100) that are specified by the user. Given a series of variable identifiers in camelCase, identify the number of actual words in the string (e.g. numberOfRankingPoints has four actual words). Given the length of a set of integers S, followed the elements (numbers) of S, determine if S contains only consecutive integers, without repeats (e.g. {3, 5, 4, 6} does, while {6, 4, 3} and {1, 2, 2, 3} do not). Given a series of lowercase strings without spaces or punctuation, determine if any two adjacent strings (inputted right after each other) are anagrams of each other. Write a program to determine if a number is a palindrome. Write methods that compute the least common multiple and greatest common factor of two positive integers. Please email or DM me via Slack any challenges that you finish for feedback!","title":"Algorithmic challenges"},{"location":"develop/android/L4/","text":"Lesson 4 - Object Orientated Design We explored String s in previous lessons, which was your first look at an object in Java. In fact, you've been writing programs inside of a main function, which is a method inside a function! In this lesson, we'll see what an object really is and why they're so useful. Why objects? Objects have both state , variables that remain constant until you modify them, and behavior , which are seen through callable methods that either feed your main method information about that object or operate on its state. As programmers, you need to design objects so that their state and behavior are appropriate for what you're trying to accomplish, while breaking down code into testable and understandable building blocks. It's probably easiest to think of an object like an object in the real world, such as a person or a dog. It could have states like a name, age, favorite color, and friends. Similarly, a Person object could have behaviors like befriending another person if they have the same favorite color, increasing its age every year, or saying its name. Objects may also want to keep some state variables private , such as a credit card number. These are just examples, but you'll see as we go about modeling a person in this lesson. In essence, objects make programming real-world mechanisms and representing real-world entities a lot easier. You could have a Robot object drive a certain distance, deposit and earn interest in a BankAccount , or read the state of an Actuator on a Robot . Constructors and member variables A class is the blueprint behind an object, which is something you should already be familiar with from writing programs. Each class should generally be in its own . java file, called ClassName . java . It's possible to have multiple classes within a file, but we'll get to that later. Inside Person . java : // Import statements come first import java.util.Scanner ; public class Person { public static void main ( String [] args ){ // do stuff here } } This is probably what you're familiar with right now. Now, we'll add in some fields, called member variables , to the Person class that will help identify it: public class Person { String name , favoriteColor ; int age , numFriends ; } To initialize these attributes, we'll also need a constructor , which is essentially a method that returns an instance of that class while assigning values to as many member variables as you'd like. public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } Note that the identifier for a constructor is simply the name of the class, though the parameters can be any datatype, and there is no return statement. Like other methods, constructors can also be overloaded with arguments of different datatypes. An empty constructor is automatically created if no constructor is declared for a class, which simply doesn't set any member variables. To access member variables, we use the keyword this , referring to the new instance of the object, followed by the dot operator and the identifiers of the variables you want to modify. This also distinguishes the name variable in the parameter of the constructor with the name variable that's part of the object's state. Member variables must be assigned a value, either explicitly through the code of the class or via a constructor, before their value can be accessed. They can also either be objects or primitive values. Declaring objects So, how exactly do you create an object with the constructor? Well, it's similar to declaring any other variable in Java, complete with a datatype and identifier, except you'll need to use the new keyword: public static void main ( String [] args ){ Person mentor = new Person ( \"Cokeley\" ); } This creates an instance of a Person , which is stored in mentor . Now, if you want to access or modify attributes of mentor , you'll use the same dot operator that was used in the constructor: mentor . age = 25 ; System . out . println ( mentor . name + \" is \" + mentor . age + \" years old\" ); This will print out Cokeley is 25 years old . Class methods While having objects as a simple data structure with various attributes is useful, sometimes you want a little more interactivity. That's when we can create our own methods in a class. We can spice up the Person class by adding in the following: public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } boolean makeFriends ( Person possibleFriend ){ if ( possibleFriend . favoriteColor . equals ( this . favoriteColor )){ this . numFriends ++ ; possibleFriend . numFriends ++ ; return true ; } return false ; } } This makeFriends method mutually has two people become friends if their favoriteColor is the same, then returns true if they've become friends, or false otherwise. Another example can be seen with this RightTriangle class: class RightTriangle { double legOne , legTwo , hypotenuse ; RightTriangle ( double side1 , double side2 , double side3 ){ this . hypotenuse = Math . max ( Math . max ( side1 , side2 ), side3 ); this . legOne = Math . min ( Math . min ( side1 , side2 ), side3 ); this . legTwo = side1 + side2 + side3 - this . legOne - this . hypotenuse ; } double getArea (){ return 0.5 * this . legOne * this . legTwo ; } double getPerimeter (){ return this . legOne + this . legTwo + this . hypotenuse ; } // Returns smaller acute angle in radians double getSmallerAngle (){ return Math . atan ( this . legOne / this . legTwo ); } // Returns larger acute angle in radians double getLargerAngle (){ return Math . PI / 2 - this . getSmallerAngle (); } // Extends the length of the shorter leg and // adjusts the length of the hypotenuse accordingly void extendLegOne ( double newLength ){ if ( newLength > this . legTwo ){ this . legOne = this . legTwo ; this . legTwo = newLength ; } else this . legOne = newLength ; this . hypotenuse = Math . sqrt ( Math . pow ( this . legOne , 2 ) + Math . pow ( this . legTwo , 2 )); } } Here, after initializing a RightTriangle object, we can use its different instance methods to get and modify its properties. For instance, executing the following in the main method RightTriangle tri = new RightTriangle ( 4 , 3 , 5 ); System . out . println ( \"Perimeter: \" + tri . getPerimeter ()); System . out . println ( \"Area: \" + tri . getArea ()); System . out . println ( \"Smaller Angle: \" + tri . getSmallestAngle () + \" rad\" ); tri . extendLegOne ( 10 ); System . out . println ( \"New Perimeter: \" + tri . getPerimeter ()); will print Perimeter : 12.0 Area : 6.0 Smallest Angle : 0.6435011087932844 rad New Perimeter : 24.77032961426901 Visibility Sometimes it is desirable to reduce the access and visibility of object methods or instance variables. For example, you generally wouldn't want a main method to be able to change a Person object's name explicitly, or perhaps you want to modify a BankAccount object's balance only through withdrawal and deposit methods, each requiring a PIN code. In that case, it's best to leave member variables private instead of public . To do this, simply put the visibility modifier in front of the variable identifier, like so: public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } That way, private level access only allows those variables to be accessed and modified within the same class (such as within the constructor or other class methods). On the other hand, public level access allows all classes to modify a variable or call a method, while default access (not putting any modifier) only allows classes of the same package to access variables/methods. We'll get into packages later on, but just know that they're ways of grouping similar classes for now. So, how are we supposed to modify and access attributes like favoriteColor so the method makeFriends can still function properly? For the first case, we'll use a special type of method called a setter , while we create a getter to do the latter: private public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } public void setFavoriteColor ( String favoriteColor ){ this . favoriteColor = favoriteColor ; } public String getFavoriteColor (){ return this . favoriteColor ; } } It's pretty simple: a setter has an argument datatype that's the same as the member variable, sets the member variable, then returns nothing. Meanwhile, a getter has the same return type as the member variable, has no parameters, and simply returns the value of the member variable. In fact, these methods are so common (as it's good practice to set variables as private ) that most IDEs (including Eclipse) have a way to automatically generate setters and getters for a class. Finally, static methods and variables are called directly on a class, rather than on an instance of a class. You've already seen examples of these in the Math class: the variable Math . PI and the method Math . pow ( base , exp ) can be called without declaring an instance of a Math object via the new keyword. It's important to note that static variables are shared by all instances of a given class (and thus can be used as temporary storage). Also, static methods cannot access non- static variables or methods. You can make a static method private or public by putting the visibility modifier in front of the word static , such as in public static void main ( String [] args ) . Scope Our last topic is something that we've used throughout this lesson without realizing it; variable identifiers often come in conflict with each other. In that case, which value do we use? The smallest scope is in a loop: for ( int i = 1 ; i < 5 ; i ++ ){ double area = Math . pow ( i , 2 ); } In this case, both i and area have block scope and cannot be modified or accessed outside of the for loop. You'll see that a set of curly braces generally denotes scope. Note that variables with the identifier i or area cannot exist outside of the loop either. Next up are local variables, also known as method scope : public void setSideLength ( int sideLength ){ double squareArea = Math . pow ( sideLength , 2 ); this . sideLength = sideLength ; } Both sideLength and squareArea can be accessed/modified only within the method setSideLength . However, using the keyword this and the dot operator will refer to the member variable sideLength of the class, rather than the one passed in as an argument. All variables other than member variables cannot be accessed outside of a class, which then follow the visibility rules discussed before. HW: Modeling Bank Accounts We've discussed bank accounts throughout this lesson. Now it's time to implement one! Each BankAccount object has the following attributes, which should all be private : balance : a double indicating the amount of money in the bank account. Cannot be negative. pin : a four-digit code that authenticates a user. May contain leading zeroes (i.e. 0000 is a valid PIN) name : the name of the bank account owner interestRate : the percent of interest earned by a user in a given year, shared across all bank accounts Challenge : id : a random, five-digit code that's generated upon the creation of the bank account to identify it. Does not contain leading zeroes. You may want to refer back to the Math . random method from Lesson 2. Methods should be provided to do the following: Construct a BankAccount with a PIN, owner, and initial balance Challenge : Construct a BankAccount with a PIN, owner, and initial balance of $0.00 Get the name of the owner of an account Get the id of the account Change the PIN of the account, given the old PIN and the new PIN. Should return some form of feedback to determine if the PIN was successfully changed Withdraw money from an account, given its PIN and the amount desired. Should indicate if withdrawal was successful and should not allow it if the account doesn't have enough money Deposit a given amount of money into the account Earn interest for the year, based on the interestRate Challenge : Transfer money from one account to another, given another BankAccount object and its PIN You do not need to submit a main method as a driver for your class, though you will need to write one to test if your class works. Next lesson, you'll write one to complete specific tasks when you learn about arrays and HashMaps to create a network of bank accounts. Please email me your completed class or DM me via Slack.","title":"Lesson 4: Advanced Techniques"},{"location":"develop/android/L4/#lesson-4-object-orientated-design","text":"We explored String s in previous lessons, which was your first look at an object in Java. In fact, you've been writing programs inside of a main function, which is a method inside a function! In this lesson, we'll see what an object really is and why they're so useful.","title":"Lesson 4 - Object Orientated Design"},{"location":"develop/android/L4/#why-objects","text":"Objects have both state , variables that remain constant until you modify them, and behavior , which are seen through callable methods that either feed your main method information about that object or operate on its state. As programmers, you need to design objects so that their state and behavior are appropriate for what you're trying to accomplish, while breaking down code into testable and understandable building blocks. It's probably easiest to think of an object like an object in the real world, such as a person or a dog. It could have states like a name, age, favorite color, and friends. Similarly, a Person object could have behaviors like befriending another person if they have the same favorite color, increasing its age every year, or saying its name. Objects may also want to keep some state variables private , such as a credit card number. These are just examples, but you'll see as we go about modeling a person in this lesson. In essence, objects make programming real-world mechanisms and representing real-world entities a lot easier. You could have a Robot object drive a certain distance, deposit and earn interest in a BankAccount , or read the state of an Actuator on a Robot .","title":"Why objects?"},{"location":"develop/android/L4/#constructors-and-member-variables","text":"A class is the blueprint behind an object, which is something you should already be familiar with from writing programs. Each class should generally be in its own . java file, called ClassName . java . It's possible to have multiple classes within a file, but we'll get to that later. Inside Person . java : // Import statements come first import java.util.Scanner ; public class Person { public static void main ( String [] args ){ // do stuff here } } This is probably what you're familiar with right now. Now, we'll add in some fields, called member variables , to the Person class that will help identify it: public class Person { String name , favoriteColor ; int age , numFriends ; } To initialize these attributes, we'll also need a constructor , which is essentially a method that returns an instance of that class while assigning values to as many member variables as you'd like. public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } Note that the identifier for a constructor is simply the name of the class, though the parameters can be any datatype, and there is no return statement. Like other methods, constructors can also be overloaded with arguments of different datatypes. An empty constructor is automatically created if no constructor is declared for a class, which simply doesn't set any member variables. To access member variables, we use the keyword this , referring to the new instance of the object, followed by the dot operator and the identifiers of the variables you want to modify. This also distinguishes the name variable in the parameter of the constructor with the name variable that's part of the object's state. Member variables must be assigned a value, either explicitly through the code of the class or via a constructor, before their value can be accessed. They can also either be objects or primitive values.","title":"Constructors and member variables"},{"location":"develop/android/L4/#declaring-objects","text":"So, how exactly do you create an object with the constructor? Well, it's similar to declaring any other variable in Java, complete with a datatype and identifier, except you'll need to use the new keyword: public static void main ( String [] args ){ Person mentor = new Person ( \"Cokeley\" ); } This creates an instance of a Person , which is stored in mentor . Now, if you want to access or modify attributes of mentor , you'll use the same dot operator that was used in the constructor: mentor . age = 25 ; System . out . println ( mentor . name + \" is \" + mentor . age + \" years old\" ); This will print out Cokeley is 25 years old .","title":"Declaring objects"},{"location":"develop/android/L4/#class-methods","text":"While having objects as a simple data structure with various attributes is useful, sometimes you want a little more interactivity. That's when we can create our own methods in a class. We can spice up the Person class by adding in the following: public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } boolean makeFriends ( Person possibleFriend ){ if ( possibleFriend . favoriteColor . equals ( this . favoriteColor )){ this . numFriends ++ ; possibleFriend . numFriends ++ ; return true ; } return false ; } } This makeFriends method mutually has two people become friends if their favoriteColor is the same, then returns true if they've become friends, or false otherwise. Another example can be seen with this RightTriangle class: class RightTriangle { double legOne , legTwo , hypotenuse ; RightTriangle ( double side1 , double side2 , double side3 ){ this . hypotenuse = Math . max ( Math . max ( side1 , side2 ), side3 ); this . legOne = Math . min ( Math . min ( side1 , side2 ), side3 ); this . legTwo = side1 + side2 + side3 - this . legOne - this . hypotenuse ; } double getArea (){ return 0.5 * this . legOne * this . legTwo ; } double getPerimeter (){ return this . legOne + this . legTwo + this . hypotenuse ; } // Returns smaller acute angle in radians double getSmallerAngle (){ return Math . atan ( this . legOne / this . legTwo ); } // Returns larger acute angle in radians double getLargerAngle (){ return Math . PI / 2 - this . getSmallerAngle (); } // Extends the length of the shorter leg and // adjusts the length of the hypotenuse accordingly void extendLegOne ( double newLength ){ if ( newLength > this . legTwo ){ this . legOne = this . legTwo ; this . legTwo = newLength ; } else this . legOne = newLength ; this . hypotenuse = Math . sqrt ( Math . pow ( this . legOne , 2 ) + Math . pow ( this . legTwo , 2 )); } } Here, after initializing a RightTriangle object, we can use its different instance methods to get and modify its properties. For instance, executing the following in the main method RightTriangle tri = new RightTriangle ( 4 , 3 , 5 ); System . out . println ( \"Perimeter: \" + tri . getPerimeter ()); System . out . println ( \"Area: \" + tri . getArea ()); System . out . println ( \"Smaller Angle: \" + tri . getSmallestAngle () + \" rad\" ); tri . extendLegOne ( 10 ); System . out . println ( \"New Perimeter: \" + tri . getPerimeter ()); will print Perimeter : 12.0 Area : 6.0 Smallest Angle : 0.6435011087932844 rad New Perimeter : 24.77032961426901","title":"Class methods"},{"location":"develop/android/L4/#visibility","text":"Sometimes it is desirable to reduce the access and visibility of object methods or instance variables. For example, you generally wouldn't want a main method to be able to change a Person object's name explicitly, or perhaps you want to modify a BankAccount object's balance only through withdrawal and deposit methods, each requiring a PIN code. In that case, it's best to leave member variables private instead of public . To do this, simply put the visibility modifier in front of the variable identifier, like so: public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } That way, private level access only allows those variables to be accessed and modified within the same class (such as within the constructor or other class methods). On the other hand, public level access allows all classes to modify a variable or call a method, while default access (not putting any modifier) only allows classes of the same package to access variables/methods. We'll get into packages later on, but just know that they're ways of grouping similar classes for now. So, how are we supposed to modify and access attributes like favoriteColor so the method makeFriends can still function properly? For the first case, we'll use a special type of method called a setter , while we create a getter to do the latter: private public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } public void setFavoriteColor ( String favoriteColor ){ this . favoriteColor = favoriteColor ; } public String getFavoriteColor (){ return this . favoriteColor ; } } It's pretty simple: a setter has an argument datatype that's the same as the member variable, sets the member variable, then returns nothing. Meanwhile, a getter has the same return type as the member variable, has no parameters, and simply returns the value of the member variable. In fact, these methods are so common (as it's good practice to set variables as private ) that most IDEs (including Eclipse) have a way to automatically generate setters and getters for a class. Finally, static methods and variables are called directly on a class, rather than on an instance of a class. You've already seen examples of these in the Math class: the variable Math . PI and the method Math . pow ( base , exp ) can be called without declaring an instance of a Math object via the new keyword. It's important to note that static variables are shared by all instances of a given class (and thus can be used as temporary storage). Also, static methods cannot access non- static variables or methods. You can make a static method private or public by putting the visibility modifier in front of the word static , such as in public static void main ( String [] args ) .","title":"Visibility"},{"location":"develop/android/L4/#scope","text":"Our last topic is something that we've used throughout this lesson without realizing it; variable identifiers often come in conflict with each other. In that case, which value do we use? The smallest scope is in a loop: for ( int i = 1 ; i < 5 ; i ++ ){ double area = Math . pow ( i , 2 ); } In this case, both i and area have block scope and cannot be modified or accessed outside of the for loop. You'll see that a set of curly braces generally denotes scope. Note that variables with the identifier i or area cannot exist outside of the loop either. Next up are local variables, also known as method scope : public void setSideLength ( int sideLength ){ double squareArea = Math . pow ( sideLength , 2 ); this . sideLength = sideLength ; } Both sideLength and squareArea can be accessed/modified only within the method setSideLength . However, using the keyword this and the dot operator will refer to the member variable sideLength of the class, rather than the one passed in as an argument. All variables other than member variables cannot be accessed outside of a class, which then follow the visibility rules discussed before.","title":"Scope"},{"location":"develop/android/L4/#hw-modeling-bank-accounts","text":"We've discussed bank accounts throughout this lesson. Now it's time to implement one! Each BankAccount object has the following attributes, which should all be private : balance : a double indicating the amount of money in the bank account. Cannot be negative. pin : a four-digit code that authenticates a user. May contain leading zeroes (i.e. 0000 is a valid PIN) name : the name of the bank account owner interestRate : the percent of interest earned by a user in a given year, shared across all bank accounts Challenge : id : a random, five-digit code that's generated upon the creation of the bank account to identify it. Does not contain leading zeroes. You may want to refer back to the Math . random method from Lesson 2. Methods should be provided to do the following: Construct a BankAccount with a PIN, owner, and initial balance Challenge : Construct a BankAccount with a PIN, owner, and initial balance of $0.00 Get the name of the owner of an account Get the id of the account Change the PIN of the account, given the old PIN and the new PIN. Should return some form of feedback to determine if the PIN was successfully changed Withdraw money from an account, given its PIN and the amount desired. Should indicate if withdrawal was successful and should not allow it if the account doesn't have enough money Deposit a given amount of money into the account Earn interest for the year, based on the interestRate Challenge : Transfer money from one account to another, given another BankAccount object and its PIN You do not need to submit a main method as a driver for your class, though you will need to write one to test if your class works. Next lesson, you'll write one to complete specific tasks when you learn about arrays and HashMaps to create a network of bank accounts. Please email me your completed class or DM me via Slack.","title":"HW: Modeling Bank Accounts"},{"location":"develop/java/L1/","text":"Lesson 1 - Introduction to Java Raider Robotix and Java FRC Team 25, Raider Robotix , uses the Java programming language for programming both the robot and the scouting system. Java is also taught in NBTHS's computer science courses. These lessons will provide you with the building blocks of Java that are necessary to program, maintain, and understand the scouting system. It currently has two components: Android scouting app - collects data from scouts during events and exports it in JSON (JavaScript Object Notation) files Every year, this needs to be updated with the correct metrics, events, game manual, and other options, as necessary Desktop scouting client - compiles the JSON files from the app and outputs spreadsheets of each scouting entry and aggregated statistics for each team Every year, this needs to be updated with the correct metrics, which includes averages, percentages, probabilities, and standard deviations, in addition to those in the scouting app Starting from the 2017 season, Tableau is used to visualize and analyze the data from the spreadsheets generated by the client. The goal is to have you understand how the scouting system works and be comfortable with changing its code by next season's kickoff. If you want to work on robot programming instead, additional knowledge of WPILib API will be needed. Lesson Structure Generally, several concepts will be explained and grouped together to form a lesson. As each concept is taught, several practice exercises are given for you to check your understanding. There are solutions provided with the exercises, but please don't check them until you've fully attempted each exercise. At the end of the lesson, one or two problems will be assigned on HackerRank that test your understanding of all concepts in the lesson. The site allows you to check your program against several test cases and will \"grade\" it (pass or fail) instantly. Java Code Structure Java source files have a . java extension and each contain a class , which acts like an object (we'll get to this later). Each class/source file is located in a package , which acts as a folder to organize various files. Inside an executable program is a main method , in which the code inside it executes. In a desktop Java program, the method signature public static void main ( String [] args ) is used, followed by a set of curly braces. Below is an example inside a file called Example . java : // Place import statements here public class Example { public static void main ( String [] args ) { // Write your code to execute here } } As seen above line comments can be written if they are proceeded with two forward slashes ( // ). Anything following the two slashes will be ignored by the compiler when your program executes. Block comments may also be written like this: /* Hi! * I'm a block comment. */ Note the two slashes showing the beginning/end of the comment and the asterisk on each line. Variables Any data or value you use in Java is stored in a variable . A variable can have one of many different datatypes . The following are common datatypes: int : an integer with a value between -2^{31} - 1 -2^{31} - 1 and 2^{31} -1 2^{31} -1 ( 123 , 25 , - 900 , 0 , etc.) double : a positive or negative decimal number ( 1.23 , - 2.5 , 1.0005 , etc.) boolean : has either a true or false value String : a sequence of characters, enclosed in a set of quotation marks ( \"Hello World\" , \"1+1=2\" , \"Raider Robotix\" , etc.) You can declare variables with its datatype, followed by a space and its identifier , then a semicolon. The identifier must start with a letter or underscore, then be followed by more letters, underscores, or numbers, with no spaces. Valid identifiers include: _t motor1 MOTOR_SPEED Generally, variables are named in a camelCase notation, where the first word is lowercase, then the remaining words are uppercase. Examples of variable declarations with camelCase naming include: int teleOpGearsCollected ; double avgKpaPerGame ; boolean baselineCrossed ; //multiple variables can be declared with a comma separating them String robotComment , pilotComment ; On the other hand, variables that are constant throughout a program should be named with only uppercase letters and underscores. Examples of these variables include: double TURN_ANGLE_TOLERANCE ; int LEFT_JOYSTICK_PORT ; String RULES_FILEPATH ; int VERSION_NUMBER ; Keep in mind that variables should not have generic identifiers like x or var1 , but ones that are descriptive. A variable can be assigned a value with its identifier followed by the assignment operator , = , and its value. This value can be literal or that of another variable. A variable may be assigned a value and declared at the same time as well. Some examples: int teleOpGearsCollected ; // declaration double avgHighGoalsTeleOp = 12.555 ; // variable declared and value of 12.555 assigned teleOpGearsCollected = 4 ; // assignment afterwards boolean baselineCrossed = true , readyTakeoff = false ; // two variables declared and assigned value String robotComment = \"This is a good robot\" ; double avgTeleOpKpa = avgHighGoalsTeleOp / 3 ; //value dependent on another variable Output Output to the console in Java can be executed with the following statement : System . out . println ( < some value > ); This calls the println method on a value, where < some value > can be a literal value or a variable. Remember to terminate the print statement with a semicolon. For example, executing System . out . println ( teleOpGearsCollected ); System . out . println ( \"gears collected in tele-op in match\" ); System . out . println ( 25 ); will result in the following output: 4 gears collected in tele - op in match 25 If you don't want a new line after the output, the System . out . print ( < some value > ) method may be used. Executing System . out . print ( teleOpGearsCollected ); System . out . println ( \" gears collected in tele-op.\" ); System . out . println ( \"Robots are cool\" ); will result in the following output: 4 gears collected in tele - op . Robots are cool An IDE An IDE (Integrated Development Environment) will be used to program in Java. It allows you to write code, execute, and debug it in one application. I recommend using Eclipse , as NBTHS and the WPILib API uses it, though alternatives like InteliJ and BlueJ exist. We will be using Android Studio as our IDE for Android development. To get started with Eclipse: 1. Download and extract the ZIP file from the link above 2. Run the executable and choose your workspace (default should work) 3. Go to File > New > Java Project and name your project 4. Close the Welcome window 5. Right click your project and go to New > Class, and name your class (without the . java extension) 6. Write your main method (see above) 7. Try replacing the comment with a statement to print Hello World 8. Press the green \"Play\" button to execute your program If there are any syntax errors in your program, Eclipse will underline them in red, and the program will not run. Try fixing them by reading the error message and reviewing your code or by using Google. A Brief Exercise Assign the values of true , \"Raider Robotix\" , and 25 to variables. Use print statements with the variables and literal values to generate the output Hello World ! It is true that I am on Team 25 , Raider Robotix 25 is the Team Number . Click here for solution public class PrintingExercise { public static void main ( String [] args ) { boolean onTeam = true ; String teamNickname = \"Raider Robotix\" ; int teamNum = 25 ; System . out . println ( \"Hello World!\" ); System . out . print ( \"It is \" ); System . out . print ( onTeam ); System . out . print ( \" that I am on Team \" ); System . out . print ( teamNum ); System . out . print ( \", \" ); System . out . println ( teamNickname ); System . out . print ( teamNum ); System . out . println ( \" is the Team Number\" ); } } Input To take user input, you will need to use a Scanner object. First, you will need to import the class by placing the following import statement before the class starts (see example above): import java.util.Scanner ; The Scanner object can be declared and constructed like this to read from the system console: Scanner myScanner = new Scanner ( System . in ); The datatype is Scanner , and myScanner can be any valid identifier. Note the use of the new keyword to create a new object and the parentheses following. Several methods can be accessed through the Scanner object for different datatypes. A method essentially acts like a function and returns a value to the main program. These may be used to let users assign values to variables: int anInteger = myScanner . nextInt (); String aLine = myScanner . nextLine (); // takes the next whole line Essentially, the dot operator ( . ) shows that the methods nextInt () and nextLine () are written in the Scanner class, and you are accessing them from an outside class. More methods for input can be found by reading the documentation for the class . If the wrong datatype is used, there will be an error in your program. By default, spaces and line breaks separating tokens in the input will result two different variables. For example, if the input is Raider Robotix executing String teamName = myScanner . next (); System . out . println ( teamName ); will output Raider while executing String teamName = myScanner . nextLine (); System . out . println ( teamName ); will output Raider Robotix because a whitespace separates Raider and Robotix in the input. Exercise Write a program that allows prompts a user to input a string, an integer, and a floating point number, then print all three once they are inputted. Click here for a solution import java.util.Scanner ; public class VariableInput { public system void public static void main ( String [] args ) { int anInt ; String aString ; double aDouble ; Scanner scanner = new Scanner ( System . in ); System . out . print ( \"Enter an integer: \" ); anInt = scanner . nextInt (); System . out . print ( \"Enter a string: \" ); aString = scanner . nextLine (); System . out . print ( \"Enter a floating point number: \" ); aDouble = scanner . nextDouble (); System . out . println ( anInt ); System . out . println ( aString ); System . out . println ( aDouble ); } } Operators Operators in Java allow you to interact between different datatypes. For these examples, we will declare int a = 5 , b = 4 ; double c = 2.5 ; String s = \"Hello\" ; Mathematical Evaluating these operators will result in a number of type int if both are integers, or of type double if at least one is a double : + : adds the number (an int or double ) to the left and right of it a + b is equal to 9 , a + c is equal to 7.5 - : subtracts the number on the right from the left b - a is equal to - 1 , b - c is equal to 1.5 * : multiplies the number to the left and right of it a * b is equal to 20 , b * c is equal to 10.0 / : divides the number on the left by the number on the right. However, if both numbers are int s, integer division will occur. That is, the remainder is discarded, and only the quotient remains. a / c is equal to 2.0 , b / c is equal to 1.6 a / b is equal to 1 , b / a is equal to 0 A literal int value ( 1 ) may be converted into a double value by adding a decimal point and a zero ( 1.0 ) % : the modulus operator, a % b returns the remainder of a / b a % b is equal to 1 , b % a is equal to 4 , a % c is equal to 0.0 Exercises : Write a program that allows the user to input (integer) dimensions of a rectangular prism and outputs its surface area and volume Write a program that prints the day of the week of a day, given the day of the week of the first day of the month (where 1=Monday, 7=Sunday) Write a program that calculates the score of a match in FIRST Steamworks, where the user inputs the number of rotors activated during tele-op/autonomous, high/low goals in tele-op/autonomous, the times the baseline was crossed, the times robots took off, and foul points that were incurred by the opposing alliance Rectangular prism solution import java.util.Scanner ; public class RectangularPrismExercise { public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); int length , height , width ; System . out . print ( \"Enter height: \" ); height = sc . nextInt (); System . out . print ( \"Enter length: \" ); length = sc . nextInt (); System . out . print ( \"Enter width: \" ); width = sc . nextInt (); System . out . println ( \"Surface area: \" ); System . out . println ( 2 * ( width * height + width * length + length * height )); System . out . println ( \"Volume: \" + ( height * width * length )); } } Day of the Week Solution import java.util.Scanner ; public class DayWeekExercise { public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); int desiredDay , firstDay ; System . out . print ( \"Day of the week of the first day of the month (1=Monday, 7=Sunday): \" ); firstDay = sc . nextInt (); System . out . print ( \"Day you want the day of the week for: \" ); desiredDay = sc . nextInt (); System . out . print ( \"The day of the week of Day \" ); System . out . print ( desiredDay ); System . out . print ( \" of the month is \" ); System . out . print (( desiredDay + firstDay - 2 ) % 7 + 1 ); } } Steamworks Score Solution import java.util.Scanner ; public class SteamworksExercise { public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); int autoRotors , teleRotors , autoHigh , autoLow , teleHigh , teleLow , baselineCrossCount , takeoffCount , foulPoints ; int AUTO_ROTOR = 60 , TELE_ROTOR = 40 , BASELINE = 5 , TAKEOFF = 40 ; System . out . print ( \"Autonomous rotors: \" ); autoRotors = sc . nextInt (); System . out . print ( \"Tele-op rotors: \" ); teleRotors = sc . nextInt (); System . out . print ( \"Autonomous high goals: \" ); autoHigh = sc . nextInt (); System . out . print ( \"Autonomous low goals: \" ); autoLow = sc . nextInt (); System . out . print ( \"Tele-op high goals: \" ); teleHigh = sc . nextInt (); System . out . print ( \"Tele-op low goals: \" ); teleLow = sc . nextInt (); System . out . print ( \"Baseline cross count: \" ); baselineCrossCount = sc . nextInt (); System . out . print ( \"Takeoff count: \" ); takeoffCount = sc . nextInt (); System . out . print ( \"Foul points: \" ); foulPoints = sc . nextInt (); int score = AUTO_ROTOR * autoRotors + teleRotors * TELE_ROTOR + BASELINE * baselineCrossCount + TAKEOFF * takeoffCount + foulPoints + autoHigh + autoLow / 3 + teleHigh / 3 + teleLow / 9 ; System . out . print ( \"Score: \" + score ); } } Relational Evaluating these operators will result in a boolean value ( true or false ): < : less than, <= - less than or equal to b < a is true , 4.5 < 0 is false - 2 <= c is true , 5 <= 5 is true > : greater than, >= - greater than or equal to == : checks for equality. This can only be used for primitive datatypes, and not objects a == 5 is true , 2.0 == a / c is true false == true is false For strings, the method someString . equals ( /*another string*/ ) is used for equality because a string is an object. We'll get into this more in the next lesson. s . equals ( \"Hello\" ) is true , s . equals ( \"World\" ) is false != : checks if the two objects are not equal a != 5 is false , 1 != a / c is true false != true is true Exercise Write a program to determine if it is true that a quadratic equation of the form 0=ax^2+bx+c 0=ax^2+bx+c has a real solution, where the user inputs a a , b b , and c c . (Hint: For now the best way to square an integer x is x * x , as x ^ 2 will not evaluate correctly) Click for a solution import java.util.Scanner ; public class QuadraticSolutionExistsExercise { public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); int a , b , c ; System . out . print ( \"Enter a: \" ); a = sc . nextInt (); System . out . print ( \"Enter b: \" ); b = sc . nextInt (); System . out . print ( \"Enter c: \" ); c = sc . nextInt (); boolean hasSolution = b * b - 4 * a * c >= 0 System . out . print ( \"It is \" + hasSolution + \"that the equation 0=\" ); System . out . print ( a + \"*x^2 + \" + b + \"*x + \" + c + \" has a solution\" ); } } Logical These operate on boolean values and evaluating them will also result in a boolean value: OR Operator Written as a || b and evaluates to true only if either a or b are true a b a || b false false false false true true true false true true true true AND Operator Written as a && b and evaluates to true only if both a and b are true a b a && b false false false false true false true false false true true true NOT Operator Written as !a and evaluates to true only if a is false a !a false true true false Exercises Evaluate the following expressions (without actually writing any code) for when boolean a = true , b = false and for when boolean a = true , b = true : ( a || b ) && ( ! a || ! b ) ! ( a && ! b ) || ( ! a && b ) ! ( a && b ) Click for the answers Expression/Condition a = true , b = false a = true , b = true ( a || b ) && ( ! a || ! b ) true false ! ( a && ! b ) || ( ! a && b ) false true ! ( a && b ) true false Some Shortcuts You already learned about the assignment operator. Here are some shortcuts used for assignment with operators, if x and y are numbers and both are already declared and assigned values: x += y ; // same as x = x+y x -= y ; // same as x = x-y x /= y ; // same as x = x/y x %= y ; // same as x = x % y x ++ ; // same as x+=1 x -- ; // same as x-=1 Exercise : What is the value of x after the following is executed? int x = 60 , y = 10 ; y /= 5 ; x %= x - y ; x ++ ; x *= 4 ; Click for the answer int x = 60 , y = 10 ; y /= 5 ; // x = 60, y = 2 x %= x - y ; // x = 2, y = 2 x ++ ; // x = 3, y = 2 x *= 4 ; // x = 12, y = 2 The final value of x is 12. Boolean Expressions A boolean expression is any expression that evaluates to true or false . It may contain literals, variables, and any of the above operators. The order of operations for evaluation are: Parentheses NOT Multiplication, division, modulus Addition, subtraction Greater/less than (or equal to) Equivalence/not equivalent AND OR The following are valid boolean expressions if x and y are numbers and b is a boolean : x >= 5 + y && ! ( y + 5 == 7 || y < 0 || ! b ) takeoffPercentage / avgTakeoffPercentage + 0.1 >= 1.2 && ( avgKpa >= 30 || avgGears >= 4 ) && teamNum != 25 && ! droppedGearOften Exercises The XOR (exclusive-or) operator evaluates to be true if either A or B are true, but not both. Write an expression that is logically equivalent to \"A XOR B\" using the AND, OR, and NOT operators Write a boolean expression to determine if at least 3 ranking points were earned by the red alliance in a match of FIRST Steamworks, given the scores of both the red and blue alliances, the number of gears delivered by the red alliance, whether or not the reserve gear was used, and the number of high/low goals into the red boiler in autonomous/tele-op. Use appropriate identifiers for variables and declare multiple, intermediate boolean expressions as necessary. XOR Solution Below is a table of the XOR operator: a b a XOR b false false false false true true true false true true true false Using this, we can write boolean XOR = ( ! a && b ) || ( a && ! b ); Steamworks ranking point solution The following variables are given: int redAllianceScore , blueAllianceScore ; int redGears ; int redHighGoalsAuto , redLowGoalsAuto ; int redHighGoalsTele , redLowGoalsTele ; boolean reserveGearUsed ; 2 ranking points are earned for a win, 1 point for a tie, 1 point for scoring 40 kPa or more, and 1 point for the activation of four rotors. Thus, three or more points are achieved under the following conditions: boolean threePlusRP = ( win && ( kpaReached || fourRotors )) || ( tie && kpaReached && fourRotors ); These are the conditions for the ranking points: boolean win = redAllianceScore > blueAllianceScore ; boolean tie = redAllianceScore == blueAllianceScore ; boolean fourRotors = ( redGears >= 12 && reserveGearUsed ) || redGears >= 13 ; boolean kpaReached = ( redHighGoalsAuto + ( redHighGoalsTele + redLowGoalsAuto ) / 3.0 + redLowGoalsTele / 9.0 ) >= 40 ; Conditionals A conditional statement is one that executes if a particular boolean expression is true. The if , else , and else - if statements are written and used as follows: boolean a = < some expression > ; if ( a ) { //Code here executes if expression a is true } else if ( < some boolean expression b > ) { // Code here executes if expression b is true and a is false } else { // Code here executes if a and b are both false } Note that an if statement may be written without any else statements, but else and else - if statements must follow an if statement or an else statement. The boolean expression may also be placed inside the parentheses, rather than assigning its value to a boolean variable. These conditional statements may also be nested inside each other as follows: boolean a = < some expression > ; boolean b = < some expression > ; boolean c = < some expression > ; if ( a ) { if ( c ) { // Code here executes if a and c are true } else { //Code here executes if a is true and c is false } // Code here executes as long as a is true, no matter what the value of c is } else if ( b ) { // Code here executes if expression b is true and a is false, no matter what the value of c is if ( ! c ) { //Code here executes if a is false, b is true, and c is false } } else { // Code here executes if a and b are both false } Exercises Write a program to determine if a number is even or odd Write a program that prints the month, given its numerical value (1 to 12) Write a program that converts a day of the week to a number (Monday = 1, Sunday = 7) Write a program that converts feet to yards and vice-versa, depending on what the user wants Odd or Even Solution import java.util.Scanner ; public class OddEven { public static void public static void main ( String [] args ) { System . out . print ( \"Enter a number: \" ); Scanner sc = new Scanner ( System . in ); int num ; num = sc . nextInt (); boolean isEven = num % 2 == 0 System . out . print ( num + \" is \" ); if ( isEven ) { System . out . println ( \"even.\" ); } else System . out . println ( \"odd.\" ); } } Number Month Converter Solution import java.util.Scanner ; public class NumberMonthxConverter { public static void public static void main ( String [] args ) { System . out . print ( \"Enter a month: \" ); Scanner sc = new Scanner ( System . in ); String day ; day = sc . next (); int num ; if ( day . equals ( \"Monday\" )) num = 1 ; else if ( day . equals ( \"Tuesday\" )) num = 2 ; else if ( day . equals ( \"Wednesday\" )) num = 3 ; else if ( day . equals ( \"Thursday\" )) num = 4 ; else if ( day . equals ( \"Friday\" )) num = 5 ; else if ( day . equals ( \"Saturday\" )) num = 6 ; else if ( day . equals ( \"Sunday\" )) num = 7 ; System . out . print ( num ); } } Day Number Converter Solution import java.util.Scanner ; public class DayNumberConverter { public static void public static void main ( String [] args ) { System . out . print ( \"Enter a month: \" ); Scanner sc = new Scanner ( System . in ); String day ; day = sc . next (); int num ; if ( day . equals ( \"Monday\" )) num = 1 ; else if ( day . equals ( \"Tuesday\" )) num = 2 ; else if ( day . equals ( \"Wednesday\" )) num = 3 ; else if ( day . equals ( \"Thursday\" )) num = 4 ; else if ( day . equals ( \"Friday\" )) num = 5 ; else if ( day . equals ( \"Saturday\" )) num = 6 ; else if ( day . equals ( \"Sunday\" )) num = 7 ; System . out . print ( num ); } } Feet-Yard Converter Solution import java.util.Scanner ; public class FeetYardConverter { public static void public static void main ( String [] args ) { System . out . println ( \"1) Feet to Yards\" ); System . out . println ( \"2) Yards to Feet\" ); System . out . println ( \"Enter your choice (1 or 2): \" ); Scanner sc = new Scanner ( System . in ); int choice ; choice = sc . nextInt (); if ( choice == 1 ) { System . out . print ( \"Enter the number of feet: \" ); int feet = sc . nextInt (); System . out . println ( feet + \" feet is \" + ( feet / 3.0 ) + \" yards\" ); } else { System . out . print ( \"Enter the number of feet: \" ); int yards = sc . nextInt (); System . out . println ( yards + \" yards is \" + ( yards * 3 ) + \" feet\" ); } } } Assignment Download Eclipse and complete the exercises above as necessary to check your understanding. Afterwards, sign up for a HackerRank account and complete the \"A School Day\" program here . Click here to read the problem statement on this site. I suggest that you write and test the program on Eclipse, then check if it works on HackerRank.","title":"Lesson 1: Intro to Java"},{"location":"develop/java/L1/#lesson-1-introduction-to-java","text":"","title":"Lesson 1 - Introduction to Java"},{"location":"develop/java/L1/#raider-robotix-and-java","text":"FRC Team 25, Raider Robotix , uses the Java programming language for programming both the robot and the scouting system. Java is also taught in NBTHS's computer science courses. These lessons will provide you with the building blocks of Java that are necessary to program, maintain, and understand the scouting system. It currently has two components: Android scouting app - collects data from scouts during events and exports it in JSON (JavaScript Object Notation) files Every year, this needs to be updated with the correct metrics, events, game manual, and other options, as necessary Desktop scouting client - compiles the JSON files from the app and outputs spreadsheets of each scouting entry and aggregated statistics for each team Every year, this needs to be updated with the correct metrics, which includes averages, percentages, probabilities, and standard deviations, in addition to those in the scouting app Starting from the 2017 season, Tableau is used to visualize and analyze the data from the spreadsheets generated by the client. The goal is to have you understand how the scouting system works and be comfortable with changing its code by next season's kickoff. If you want to work on robot programming instead, additional knowledge of WPILib API will be needed.","title":"Raider Robotix and Java"},{"location":"develop/java/L1/#lesson-structure","text":"Generally, several concepts will be explained and grouped together to form a lesson. As each concept is taught, several practice exercises are given for you to check your understanding. There are solutions provided with the exercises, but please don't check them until you've fully attempted each exercise. At the end of the lesson, one or two problems will be assigned on HackerRank that test your understanding of all concepts in the lesson. The site allows you to check your program against several test cases and will \"grade\" it (pass or fail) instantly.","title":"Lesson Structure"},{"location":"develop/java/L1/#java-code-structure","text":"Java source files have a . java extension and each contain a class , which acts like an object (we'll get to this later). Each class/source file is located in a package , which acts as a folder to organize various files. Inside an executable program is a main method , in which the code inside it executes. In a desktop Java program, the method signature public static void main ( String [] args ) is used, followed by a set of curly braces. Below is an example inside a file called Example . java : // Place import statements here public class Example { public static void main ( String [] args ) { // Write your code to execute here } } As seen above line comments can be written if they are proceeded with two forward slashes ( // ). Anything following the two slashes will be ignored by the compiler when your program executes. Block comments may also be written like this: /* Hi! * I'm a block comment. */ Note the two slashes showing the beginning/end of the comment and the asterisk on each line.","title":"Java Code Structure"},{"location":"develop/java/L1/#variables","text":"Any data or value you use in Java is stored in a variable . A variable can have one of many different datatypes . The following are common datatypes: int : an integer with a value between -2^{31} - 1 -2^{31} - 1 and 2^{31} -1 2^{31} -1 ( 123 , 25 , - 900 , 0 , etc.) double : a positive or negative decimal number ( 1.23 , - 2.5 , 1.0005 , etc.) boolean : has either a true or false value String : a sequence of characters, enclosed in a set of quotation marks ( \"Hello World\" , \"1+1=2\" , \"Raider Robotix\" , etc.) You can declare variables with its datatype, followed by a space and its identifier , then a semicolon. The identifier must start with a letter or underscore, then be followed by more letters, underscores, or numbers, with no spaces. Valid identifiers include: _t motor1 MOTOR_SPEED Generally, variables are named in a camelCase notation, where the first word is lowercase, then the remaining words are uppercase. Examples of variable declarations with camelCase naming include: int teleOpGearsCollected ; double avgKpaPerGame ; boolean baselineCrossed ; //multiple variables can be declared with a comma separating them String robotComment , pilotComment ; On the other hand, variables that are constant throughout a program should be named with only uppercase letters and underscores. Examples of these variables include: double TURN_ANGLE_TOLERANCE ; int LEFT_JOYSTICK_PORT ; String RULES_FILEPATH ; int VERSION_NUMBER ; Keep in mind that variables should not have generic identifiers like x or var1 , but ones that are descriptive. A variable can be assigned a value with its identifier followed by the assignment operator , = , and its value. This value can be literal or that of another variable. A variable may be assigned a value and declared at the same time as well. Some examples: int teleOpGearsCollected ; // declaration double avgHighGoalsTeleOp = 12.555 ; // variable declared and value of 12.555 assigned teleOpGearsCollected = 4 ; // assignment afterwards boolean baselineCrossed = true , readyTakeoff = false ; // two variables declared and assigned value String robotComment = \"This is a good robot\" ; double avgTeleOpKpa = avgHighGoalsTeleOp / 3 ; //value dependent on another variable","title":"Variables"},{"location":"develop/java/L1/#output","text":"Output to the console in Java can be executed with the following statement : System . out . println ( < some value > ); This calls the println method on a value, where < some value > can be a literal value or a variable. Remember to terminate the print statement with a semicolon. For example, executing System . out . println ( teleOpGearsCollected ); System . out . println ( \"gears collected in tele-op in match\" ); System . out . println ( 25 ); will result in the following output: 4 gears collected in tele - op in match 25 If you don't want a new line after the output, the System . out . print ( < some value > ) method may be used. Executing System . out . print ( teleOpGearsCollected ); System . out . println ( \" gears collected in tele-op.\" ); System . out . println ( \"Robots are cool\" ); will result in the following output: 4 gears collected in tele - op . Robots are cool","title":"Output"},{"location":"develop/java/L1/#an-ide","text":"An IDE (Integrated Development Environment) will be used to program in Java. It allows you to write code, execute, and debug it in one application. I recommend using Eclipse , as NBTHS and the WPILib API uses it, though alternatives like InteliJ and BlueJ exist. We will be using Android Studio as our IDE for Android development. To get started with Eclipse: 1. Download and extract the ZIP file from the link above 2. Run the executable and choose your workspace (default should work) 3. Go to File > New > Java Project and name your project 4. Close the Welcome window 5. Right click your project and go to New > Class, and name your class (without the . java extension) 6. Write your main method (see above) 7. Try replacing the comment with a statement to print Hello World 8. Press the green \"Play\" button to execute your program If there are any syntax errors in your program, Eclipse will underline them in red, and the program will not run. Try fixing them by reading the error message and reviewing your code or by using Google. A Brief Exercise Assign the values of true , \"Raider Robotix\" , and 25 to variables. Use print statements with the variables and literal values to generate the output Hello World ! It is true that I am on Team 25 , Raider Robotix 25 is the Team Number . Click here for solution public class PrintingExercise { public static void main ( String [] args ) { boolean onTeam = true ; String teamNickname = \"Raider Robotix\" ; int teamNum = 25 ; System . out . println ( \"Hello World!\" ); System . out . print ( \"It is \" ); System . out . print ( onTeam ); System . out . print ( \" that I am on Team \" ); System . out . print ( teamNum ); System . out . print ( \", \" ); System . out . println ( teamNickname ); System . out . print ( teamNum ); System . out . println ( \" is the Team Number\" ); } }","title":"An IDE"},{"location":"develop/java/L1/#input","text":"To take user input, you will need to use a Scanner object. First, you will need to import the class by placing the following import statement before the class starts (see example above): import java.util.Scanner ; The Scanner object can be declared and constructed like this to read from the system console: Scanner myScanner = new Scanner ( System . in ); The datatype is Scanner , and myScanner can be any valid identifier. Note the use of the new keyword to create a new object and the parentheses following. Several methods can be accessed through the Scanner object for different datatypes. A method essentially acts like a function and returns a value to the main program. These may be used to let users assign values to variables: int anInteger = myScanner . nextInt (); String aLine = myScanner . nextLine (); // takes the next whole line Essentially, the dot operator ( . ) shows that the methods nextInt () and nextLine () are written in the Scanner class, and you are accessing them from an outside class. More methods for input can be found by reading the documentation for the class . If the wrong datatype is used, there will be an error in your program. By default, spaces and line breaks separating tokens in the input will result two different variables. For example, if the input is Raider Robotix executing String teamName = myScanner . next (); System . out . println ( teamName ); will output Raider while executing String teamName = myScanner . nextLine (); System . out . println ( teamName ); will output Raider Robotix because a whitespace separates Raider and Robotix in the input. Exercise Write a program that allows prompts a user to input a string, an integer, and a floating point number, then print all three once they are inputted. Click here for a solution import java.util.Scanner ; public class VariableInput { public system void public static void main ( String [] args ) { int anInt ; String aString ; double aDouble ; Scanner scanner = new Scanner ( System . in ); System . out . print ( \"Enter an integer: \" ); anInt = scanner . nextInt (); System . out . print ( \"Enter a string: \" ); aString = scanner . nextLine (); System . out . print ( \"Enter a floating point number: \" ); aDouble = scanner . nextDouble (); System . out . println ( anInt ); System . out . println ( aString ); System . out . println ( aDouble ); } }","title":"Input"},{"location":"develop/java/L1/#operators","text":"Operators in Java allow you to interact between different datatypes. For these examples, we will declare int a = 5 , b = 4 ; double c = 2.5 ; String s = \"Hello\" ;","title":"Operators"},{"location":"develop/java/L1/#mathematical","text":"Evaluating these operators will result in a number of type int if both are integers, or of type double if at least one is a double : + : adds the number (an int or double ) to the left and right of it a + b is equal to 9 , a + c is equal to 7.5 - : subtracts the number on the right from the left b - a is equal to - 1 , b - c is equal to 1.5 * : multiplies the number to the left and right of it a * b is equal to 20 , b * c is equal to 10.0 / : divides the number on the left by the number on the right. However, if both numbers are int s, integer division will occur. That is, the remainder is discarded, and only the quotient remains. a / c is equal to 2.0 , b / c is equal to 1.6 a / b is equal to 1 , b / a is equal to 0 A literal int value ( 1 ) may be converted into a double value by adding a decimal point and a zero ( 1.0 ) % : the modulus operator, a % b returns the remainder of a / b a % b is equal to 1 , b % a is equal to 4 , a % c is equal to 0.0 Exercises : Write a program that allows the user to input (integer) dimensions of a rectangular prism and outputs its surface area and volume Write a program that prints the day of the week of a day, given the day of the week of the first day of the month (where 1=Monday, 7=Sunday) Write a program that calculates the score of a match in FIRST Steamworks, where the user inputs the number of rotors activated during tele-op/autonomous, high/low goals in tele-op/autonomous, the times the baseline was crossed, the times robots took off, and foul points that were incurred by the opposing alliance Rectangular prism solution import java.util.Scanner ; public class RectangularPrismExercise { public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); int length , height , width ; System . out . print ( \"Enter height: \" ); height = sc . nextInt (); System . out . print ( \"Enter length: \" ); length = sc . nextInt (); System . out . print ( \"Enter width: \" ); width = sc . nextInt (); System . out . println ( \"Surface area: \" ); System . out . println ( 2 * ( width * height + width * length + length * height )); System . out . println ( \"Volume: \" + ( height * width * length )); } } Day of the Week Solution import java.util.Scanner ; public class DayWeekExercise { public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); int desiredDay , firstDay ; System . out . print ( \"Day of the week of the first day of the month (1=Monday, 7=Sunday): \" ); firstDay = sc . nextInt (); System . out . print ( \"Day you want the day of the week for: \" ); desiredDay = sc . nextInt (); System . out . print ( \"The day of the week of Day \" ); System . out . print ( desiredDay ); System . out . print ( \" of the month is \" ); System . out . print (( desiredDay + firstDay - 2 ) % 7 + 1 ); } } Steamworks Score Solution import java.util.Scanner ; public class SteamworksExercise { public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); int autoRotors , teleRotors , autoHigh , autoLow , teleHigh , teleLow , baselineCrossCount , takeoffCount , foulPoints ; int AUTO_ROTOR = 60 , TELE_ROTOR = 40 , BASELINE = 5 , TAKEOFF = 40 ; System . out . print ( \"Autonomous rotors: \" ); autoRotors = sc . nextInt (); System . out . print ( \"Tele-op rotors: \" ); teleRotors = sc . nextInt (); System . out . print ( \"Autonomous high goals: \" ); autoHigh = sc . nextInt (); System . out . print ( \"Autonomous low goals: \" ); autoLow = sc . nextInt (); System . out . print ( \"Tele-op high goals: \" ); teleHigh = sc . nextInt (); System . out . print ( \"Tele-op low goals: \" ); teleLow = sc . nextInt (); System . out . print ( \"Baseline cross count: \" ); baselineCrossCount = sc . nextInt (); System . out . print ( \"Takeoff count: \" ); takeoffCount = sc . nextInt (); System . out . print ( \"Foul points: \" ); foulPoints = sc . nextInt (); int score = AUTO_ROTOR * autoRotors + teleRotors * TELE_ROTOR + BASELINE * baselineCrossCount + TAKEOFF * takeoffCount + foulPoints + autoHigh + autoLow / 3 + teleHigh / 3 + teleLow / 9 ; System . out . print ( \"Score: \" + score ); } }","title":"Mathematical"},{"location":"develop/java/L1/#relational","text":"Evaluating these operators will result in a boolean value ( true or false ): < : less than, <= - less than or equal to b < a is true , 4.5 < 0 is false - 2 <= c is true , 5 <= 5 is true > : greater than, >= - greater than or equal to == : checks for equality. This can only be used for primitive datatypes, and not objects a == 5 is true , 2.0 == a / c is true false == true is false For strings, the method someString . equals ( /*another string*/ ) is used for equality because a string is an object. We'll get into this more in the next lesson. s . equals ( \"Hello\" ) is true , s . equals ( \"World\" ) is false != : checks if the two objects are not equal a != 5 is false , 1 != a / c is true false != true is true Exercise Write a program to determine if it is true that a quadratic equation of the form 0=ax^2+bx+c 0=ax^2+bx+c has a real solution, where the user inputs a a , b b , and c c . (Hint: For now the best way to square an integer x is x * x , as x ^ 2 will not evaluate correctly) Click for a solution import java.util.Scanner ; public class QuadraticSolutionExistsExercise { public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); int a , b , c ; System . out . print ( \"Enter a: \" ); a = sc . nextInt (); System . out . print ( \"Enter b: \" ); b = sc . nextInt (); System . out . print ( \"Enter c: \" ); c = sc . nextInt (); boolean hasSolution = b * b - 4 * a * c >= 0 System . out . print ( \"It is \" + hasSolution + \"that the equation 0=\" ); System . out . print ( a + \"*x^2 + \" + b + \"*x + \" + c + \" has a solution\" ); } }","title":"Relational"},{"location":"develop/java/L1/#logical","text":"These operate on boolean values and evaluating them will also result in a boolean value:","title":"Logical"},{"location":"develop/java/L1/#or-operator","text":"Written as a || b and evaluates to true only if either a or b are true a b a || b false false false false true true true false true true true true","title":"OR Operator"},{"location":"develop/java/L1/#and-operator","text":"Written as a && b and evaluates to true only if both a and b are true a b a && b false false false false true false true false false true true true","title":"AND Operator"},{"location":"develop/java/L1/#not-operator","text":"Written as !a and evaluates to true only if a is false a !a false true true false Exercises Evaluate the following expressions (without actually writing any code) for when boolean a = true , b = false and for when boolean a = true , b = true : ( a || b ) && ( ! a || ! b ) ! ( a && ! b ) || ( ! a && b ) ! ( a && b ) Click for the answers Expression/Condition a = true , b = false a = true , b = true ( a || b ) && ( ! a || ! b ) true false ! ( a && ! b ) || ( ! a && b ) false true ! ( a && b ) true false","title":"NOT Operator"},{"location":"develop/java/L1/#some-shortcuts","text":"You already learned about the assignment operator. Here are some shortcuts used for assignment with operators, if x and y are numbers and both are already declared and assigned values: x += y ; // same as x = x+y x -= y ; // same as x = x-y x /= y ; // same as x = x/y x %= y ; // same as x = x % y x ++ ; // same as x+=1 x -- ; // same as x-=1 Exercise : What is the value of x after the following is executed? int x = 60 , y = 10 ; y /= 5 ; x %= x - y ; x ++ ; x *= 4 ; Click for the answer int x = 60 , y = 10 ; y /= 5 ; // x = 60, y = 2 x %= x - y ; // x = 2, y = 2 x ++ ; // x = 3, y = 2 x *= 4 ; // x = 12, y = 2 The final value of x is 12.","title":"Some Shortcuts"},{"location":"develop/java/L1/#boolean-expressions","text":"A boolean expression is any expression that evaluates to true or false . It may contain literals, variables, and any of the above operators. The order of operations for evaluation are: Parentheses NOT Multiplication, division, modulus Addition, subtraction Greater/less than (or equal to) Equivalence/not equivalent AND OR The following are valid boolean expressions if x and y are numbers and b is a boolean : x >= 5 + y && ! ( y + 5 == 7 || y < 0 || ! b ) takeoffPercentage / avgTakeoffPercentage + 0.1 >= 1.2 && ( avgKpa >= 30 || avgGears >= 4 ) && teamNum != 25 && ! droppedGearOften Exercises The XOR (exclusive-or) operator evaluates to be true if either A or B are true, but not both. Write an expression that is logically equivalent to \"A XOR B\" using the AND, OR, and NOT operators Write a boolean expression to determine if at least 3 ranking points were earned by the red alliance in a match of FIRST Steamworks, given the scores of both the red and blue alliances, the number of gears delivered by the red alliance, whether or not the reserve gear was used, and the number of high/low goals into the red boiler in autonomous/tele-op. Use appropriate identifiers for variables and declare multiple, intermediate boolean expressions as necessary. XOR Solution Below is a table of the XOR operator: a b a XOR b false false false false true true true false true true true false Using this, we can write boolean XOR = ( ! a && b ) || ( a && ! b ); Steamworks ranking point solution The following variables are given: int redAllianceScore , blueAllianceScore ; int redGears ; int redHighGoalsAuto , redLowGoalsAuto ; int redHighGoalsTele , redLowGoalsTele ; boolean reserveGearUsed ; 2 ranking points are earned for a win, 1 point for a tie, 1 point for scoring 40 kPa or more, and 1 point for the activation of four rotors. Thus, three or more points are achieved under the following conditions: boolean threePlusRP = ( win && ( kpaReached || fourRotors )) || ( tie && kpaReached && fourRotors ); These are the conditions for the ranking points: boolean win = redAllianceScore > blueAllianceScore ; boolean tie = redAllianceScore == blueAllianceScore ; boolean fourRotors = ( redGears >= 12 && reserveGearUsed ) || redGears >= 13 ; boolean kpaReached = ( redHighGoalsAuto + ( redHighGoalsTele + redLowGoalsAuto ) / 3.0 + redLowGoalsTele / 9.0 ) >= 40 ;","title":"Boolean Expressions"},{"location":"develop/java/L1/#conditionals","text":"A conditional statement is one that executes if a particular boolean expression is true. The if , else , and else - if statements are written and used as follows: boolean a = < some expression > ; if ( a ) { //Code here executes if expression a is true } else if ( < some boolean expression b > ) { // Code here executes if expression b is true and a is false } else { // Code here executes if a and b are both false } Note that an if statement may be written without any else statements, but else and else - if statements must follow an if statement or an else statement. The boolean expression may also be placed inside the parentheses, rather than assigning its value to a boolean variable. These conditional statements may also be nested inside each other as follows: boolean a = < some expression > ; boolean b = < some expression > ; boolean c = < some expression > ; if ( a ) { if ( c ) { // Code here executes if a and c are true } else { //Code here executes if a is true and c is false } // Code here executes as long as a is true, no matter what the value of c is } else if ( b ) { // Code here executes if expression b is true and a is false, no matter what the value of c is if ( ! c ) { //Code here executes if a is false, b is true, and c is false } } else { // Code here executes if a and b are both false } Exercises Write a program to determine if a number is even or odd Write a program that prints the month, given its numerical value (1 to 12) Write a program that converts a day of the week to a number (Monday = 1, Sunday = 7) Write a program that converts feet to yards and vice-versa, depending on what the user wants Odd or Even Solution import java.util.Scanner ; public class OddEven { public static void public static void main ( String [] args ) { System . out . print ( \"Enter a number: \" ); Scanner sc = new Scanner ( System . in ); int num ; num = sc . nextInt (); boolean isEven = num % 2 == 0 System . out . print ( num + \" is \" ); if ( isEven ) { System . out . println ( \"even.\" ); } else System . out . println ( \"odd.\" ); } } Number Month Converter Solution import java.util.Scanner ; public class NumberMonthxConverter { public static void public static void main ( String [] args ) { System . out . print ( \"Enter a month: \" ); Scanner sc = new Scanner ( System . in ); String day ; day = sc . next (); int num ; if ( day . equals ( \"Monday\" )) num = 1 ; else if ( day . equals ( \"Tuesday\" )) num = 2 ; else if ( day . equals ( \"Wednesday\" )) num = 3 ; else if ( day . equals ( \"Thursday\" )) num = 4 ; else if ( day . equals ( \"Friday\" )) num = 5 ; else if ( day . equals ( \"Saturday\" )) num = 6 ; else if ( day . equals ( \"Sunday\" )) num = 7 ; System . out . print ( num ); } } Day Number Converter Solution import java.util.Scanner ; public class DayNumberConverter { public static void public static void main ( String [] args ) { System . out . print ( \"Enter a month: \" ); Scanner sc = new Scanner ( System . in ); String day ; day = sc . next (); int num ; if ( day . equals ( \"Monday\" )) num = 1 ; else if ( day . equals ( \"Tuesday\" )) num = 2 ; else if ( day . equals ( \"Wednesday\" )) num = 3 ; else if ( day . equals ( \"Thursday\" )) num = 4 ; else if ( day . equals ( \"Friday\" )) num = 5 ; else if ( day . equals ( \"Saturday\" )) num = 6 ; else if ( day . equals ( \"Sunday\" )) num = 7 ; System . out . print ( num ); } } Feet-Yard Converter Solution import java.util.Scanner ; public class FeetYardConverter { public static void public static void main ( String [] args ) { System . out . println ( \"1) Feet to Yards\" ); System . out . println ( \"2) Yards to Feet\" ); System . out . println ( \"Enter your choice (1 or 2): \" ); Scanner sc = new Scanner ( System . in ); int choice ; choice = sc . nextInt (); if ( choice == 1 ) { System . out . print ( \"Enter the number of feet: \" ); int feet = sc . nextInt (); System . out . println ( feet + \" feet is \" + ( feet / 3.0 ) + \" yards\" ); } else { System . out . print ( \"Enter the number of feet: \" ); int yards = sc . nextInt (); System . out . println ( yards + \" yards is \" + ( yards * 3 ) + \" feet\" ); } } }","title":"Conditionals"},{"location":"develop/java/L1/#assignment","text":"Download Eclipse and complete the exercises above as necessary to check your understanding. Afterwards, sign up for a HackerRank account and complete the \"A School Day\" program here . Click here to read the problem statement on this site. I suggest that you write and test the program on Eclipse, then check if it works on HackerRank.","title":"Assignment"},{"location":"develop/java/L2/","text":"Lesson 2 - Loops, Strings, Math After a (probably pretty long) first lesson, let's explore a couple more features of Java and see what you can do with everything that you learned. Loops Loops are used to execute a block of code enclosed in a set of braces ( {} ) multiple times. After all, computers are very good at doing the same thing over and over again! The number of times a block executes depends on a boolean expression. while Loops while loops execute as long as a boolean expression is true . It may not execute at all if the expression is false before entering the loop. while ( /*some boolean expression*/ ) { //Execute code here multiple times as long as the expression is true } Remember that the boolean expression should become false at some point during the execution of the code in the loop. Otherwise, an infinite loop will be created. For example, the following will print the numbers from 1 to 10 (inclusive): int counter = 1 ; while ( counter <= 10 ) { System . out . println ( counter ); counter ++ ; } do - while loops may also be written. The main difference between these and while loops is that the boolean expression must be true at the end of the loop, not at the beginning. The following prints the numbers from 1 to 10 (inclusive): int counter = - 1 ; do { counter ++ ; System . out . println ( counter ); } while ( counter < 10 ); for Loops for loops provide a more controlled way for iterating through a loop multiple times. There are three components to the for loop: the initial statement, the exit condition (boolean expression), and the post-excution statement. The example for ( /*initial statement*/ ; /*exit condition*/ ; /*post-execution statement*/ ) { //Code to be executed each loop } is essentially equal to the following while loop: //Initial statement while ( /*exit condition*/ ) { //Code to be executed each loop //Post-execution statement } The for loop is commonly used to execute a loop a certain number of times. Below, the loop prints the numbers from 0 to 9 (10 iterations): for ( int count = 0 ; i < 10 ; count ++ ) { System . out . println ( count ); } Keep in mind that the variable count is declared within the loop, and it cannot accessed outside it. Loops may also be placed inside each other. For example, executing for ( int row = 1 ; row <= 12 ; row ++ ) { for ( int col = 1 ; col <= 12 ; col ++ ) { System . out . print ( row * col ); System . out . print ( \" \" ); //adds a space } System . out . println (); //line break } will print a (poorly formatted) times table. Note that all three parts of a for loop are optional. That is, a loop like for (;;) { //something } will execute forever. Questions Determine the number of times the following for loops will execute. for ( int i = 4 ; i <= 8 ; i += 2 ) { /*do something*/ } for ( int i = 10 ; i >= 0 ; i -= 3 ) { /*do something*/ } for ( int j = 2 ; j >= 4 ; j ++ ) { /*do something*/ } Answers 3 4 0 Exercises Write a program that computes the sum of all odd integers from 1 to a number specified by the user Write a program that computes b^e b^e (a number raised to the power of an exponent), where b and e are positive integers Write a program that allows the user to enter a number, setSize . setSize numbers, num , follow and are inputted by the user. Print the average, largest, and smallest of the numbers. Loop Control There are two control statements that are used with loops: break The break statement will immediately exit a while or for loop. This can be useful if you're looking for a specific value, and you want the loop to end after you've found that value. For instance, in the below example, the loop will terminate immediately after the value key is found: int key = 8 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( i == key ) { System . out . println ( \"Found\" ); break ; } System . out . println ( \"Not found...\" ); } As a result, Not found ... will be printed out eight times at first, followed by Found . The loop will then terminate. The break statement will be more useful after you learn about arrays. continue The continue statement will immediately go to the next iteration of a for or while loop, bypassing all statements after it. This could be used when you only want to execute a loop for some values. Of course, an if - else statement can often accomplish the same thing, but break and continue statements can prevent too many nested blocks of code. For instance, the following block of code for ( int i = 0 ; i < 4 ; i ++ ) { System . out . println ( \"Going... \" + i ); if ( i >= 2 ) { continue ; } System . out . println ( \"Here\" ); } will print Going ... 0 Here Going ... 1 Here Going ... 2 Going ... 3 Characters In addition to the primitive data types ( boolean , int , double ) we learned about before, char s represent one of the 256 ASCII characters . These include the numbers, standard symbols and punctuation on a keyboard, and both uppercase and lowercase letters. A char is assigned a value with the declaration char allianceColor = 'R' ; Note the use of single quotation marks rather than double quotation marks (which are used for String s) and that a variable of type char may only contain a single character. Escape characters are the first 32 ASCII characters, which serve special functions. The most commonly used is '\\n' , which creates a line break. In addition, quotation marks must be escaped. Thus, executing the following code char quote1 = '\\'' ; char quote2 = '\\\"' ; char newLine = '\\n' System . out . print ( quote1 ); System . out . print ( newLine ); System . out . print ( quote2 ); will print ' \" Note that strings can be thought of as a series of char s concatenated together. For instance, executing String someText = \"Kickoff, 2017 \\n As we anticipated the new game, the livestream blared, \\\" STEAM POWERED! STEAM POWERED! STEAM POWERED! \\\" \" ; System . out . println ( someText ); will print Kickoff , 2017 As we anticipated the new game , the livestream blared , \"STEAM POWERED! STEAM POWERED! STEAM POWERED!\" The value of characters may be compared with the equivalence ( == ) operator. For example, allianceColor == 'R' is true . Note, however, that a character is not equal its int equivalent. That is, '1' == 1 is false . String Manipulation The String class in Java contains many methods to manipulate strings. We will present an overview of the most useful ones, though you may read the full documentation here . Concatenation A string can be concatenated , or joined together, with other strings or primitive datatypes (and literals) with the + operator. For example, executing the following: String mascot = \"Raider\" ; int teamNum = 25 ; String teamName = mascot + \" Robotix\" ; System . out . println ( \"The year is \" + 2017 ); System . out . println ( \"I am on Team \" + teamNum + \", \" + teamName ); will print The year is 2017 I am on Team 25 , Raider Robotix You may also concatenate a string onto the end of another with the += operator. Executing String s = \"Hello\" ; s += \" World!\" ; System . out . println ( s ); will print Hello World ! . String Properties You can check the length of a string (number of characters) with the string . length () method. Executing String s = \"Hello\" ; System . out . println ( s + \" is \" + s . length () + \" characters long\" ); System . out . print ( \"World!\" . length ()); will print Hello is 5 characters long 6 You can also check if a string contains a specific character sequence with the string . contains ( < character sequence > ) method, which returns a boolean value. If String s = \"Hello\" ; is declared, s . contains ( \"ell\" ) returns true , while s . contains ( \"f\" ) returns false . Parsing a String You may want to parse through a string sometimes, or check the sequence of its characters. The string . charAt ( /*index*/ ) method will return the character currently at the index. There are two things you should know about the method: The method will return a value of type char (character), rather than String . The index is a value that is greater than or equal to 0 and less than string . length () . That is, the index of the first character in the string is 0 , and the index of the last character in the string is string . length () - 1 . If String s = \"World\" ; is declared, s . charAt ( 0 ) returns 'W' , s . charAt ( 3 ) returns 'l' , and s . charAt ( 4 ) returns 'd' . A standard way to parse through all of the characters of a string is with the following for loop: String str = \"Hello World!\" ; for ( int i = 0 ; i < str . length (); i ++ ) { char currentChar = str . charAt ( i ); //Do something here } Substrings Suppose you want to return a slice of a string, known as a substring, such as the first letter four letters of String s = \"Raider Robotix\" ; . An easy-to-understand way would be to use string parsing, similar to what we did above: String s = \"Raider Robotix\" ; String result = \"\" ; // an empty string for ( int i = 0 ; i < 4 && i < s . length (); i ++ ) { result += s . charAt ( i ); } System . out . println ( result ); This would print out Raid . Note that the expression i < s . length () was still present in the exit condition in order to prevent errors if s was an input string that was less than four characters long. However, a faster way to get result would be to use the substring ( beginIndex , endIndex ) method, in which beginIndex and endIndex are integers that represent the indicies that you want to search. Similar to the for loop above, beginIndex is inclusive, while endIndex is exclusive. Here are some examples: s . substring ( 0 , 4 ); returns Raid s . substring ( 7 , s . length ()); returns Robotix \"hamburger\" . substring ( 4 , 8 ); returns urge Miscellaneous String Functions Assume that String s = \"Hello\" ; is declared in the following examples: s . toLowerCase (); returns hello s . toUpperCase (); returns HELLO s . indexOf ( \"l\" ); returns 2 (the first occurence of l in s ), while s . lastIndexOf ( \"l\" ) returns 3 s . concat ( \"world\" ); returns Helloworld As mentioned before, string equality is checked with s . equals ( \"Hello\" ); , which would return true . On the other hand, after declaring String anotherString = \"Hello\" ; , the boolean expression s == anotherString || s == \"Hello\" would be false , as string are objects , not primitives . Exercises Write a program to reverse a string if it has an R in it. Write a program to check if a alphanumeric string is a palindrome (reads the same backward as forward, such as racecar ). Note that Racecar , 123 racecar321 , and RaCeCaR are also palindromes. Write a program to replaces all commas from a string with semicolons Given a sentence, write a program to print its words backwards, so that My name is Bob becomes Bob is name My . Given two strings and an integer n , check if there exist a substring of length n in the first string that is also a substring of the second string The Math Class The Math class contains several methods that you may find helpful. It is imported by default, and documentation is found here . For these examples, we will declare double a = 4.5 , b = - 2.5 ; Math . abs ( b ) : takes the absolute value of a number, returns 2.5 in the example Math . ceil ( a ) : takes the ceiling of a number (rounds it up if it is a decimal), returns 5 in the example Math . floor ( a ) : takes the floor of a number (rounds it down if it is a decimal), returns 4 in the example Math . pow ( a - 0.5 , - b + 0.5 ) : takes the first number to the power of the second number, returns 125.0 in the example Math . sqrt ( a - 0.5 ) : takes the square root of a number, returns 2.0 in this example Math . PI : returns the value of pi (3.141592653589793) Math . random () : returns a random double in the interval [0.0, 1.0). This can be used to generate a random integer within a particular range by clamping the number down, then casting it to an int . For example, if you want a random integer in the interval [ lower , upper ], you would declare int randInt = ( int ) ( Math . random () * ( upper - lower )) + lower ; . Try it out! Exercises Write a program that solves quadratic equations of the form 0=ax^2+bx+c 0=ax^2+bx+c for x x , where a a , b b , and c c are coefficients given by the user Write a program that calculates the average of a data set, given the numbers in the set and its length Write a program to find the surface area and volume of a square pyramid, given its side length and height Write a program to round a number to a specific number of decimal places Assignment Complete the Raider Robotix Printer and Binary Converter programs. Please email or DM me via Slack the programs that you finish for feedback.","title":"Lesson 2: Loops, Strings, Math"},{"location":"develop/java/L2/#lesson-2-loops-strings-math","text":"After a (probably pretty long) first lesson, let's explore a couple more features of Java and see what you can do with everything that you learned.","title":"Lesson 2 - Loops, Strings, Math"},{"location":"develop/java/L2/#loops","text":"Loops are used to execute a block of code enclosed in a set of braces ( {} ) multiple times. After all, computers are very good at doing the same thing over and over again! The number of times a block executes depends on a boolean expression.","title":"Loops"},{"location":"develop/java/L2/#while-loops","text":"while loops execute as long as a boolean expression is true . It may not execute at all if the expression is false before entering the loop. while ( /*some boolean expression*/ ) { //Execute code here multiple times as long as the expression is true } Remember that the boolean expression should become false at some point during the execution of the code in the loop. Otherwise, an infinite loop will be created. For example, the following will print the numbers from 1 to 10 (inclusive): int counter = 1 ; while ( counter <= 10 ) { System . out . println ( counter ); counter ++ ; } do - while loops may also be written. The main difference between these and while loops is that the boolean expression must be true at the end of the loop, not at the beginning. The following prints the numbers from 1 to 10 (inclusive): int counter = - 1 ; do { counter ++ ; System . out . println ( counter ); } while ( counter < 10 );","title":"while Loops"},{"location":"develop/java/L2/#for-loops","text":"for loops provide a more controlled way for iterating through a loop multiple times. There are three components to the for loop: the initial statement, the exit condition (boolean expression), and the post-excution statement. The example for ( /*initial statement*/ ; /*exit condition*/ ; /*post-execution statement*/ ) { //Code to be executed each loop } is essentially equal to the following while loop: //Initial statement while ( /*exit condition*/ ) { //Code to be executed each loop //Post-execution statement } The for loop is commonly used to execute a loop a certain number of times. Below, the loop prints the numbers from 0 to 9 (10 iterations): for ( int count = 0 ; i < 10 ; count ++ ) { System . out . println ( count ); } Keep in mind that the variable count is declared within the loop, and it cannot accessed outside it. Loops may also be placed inside each other. For example, executing for ( int row = 1 ; row <= 12 ; row ++ ) { for ( int col = 1 ; col <= 12 ; col ++ ) { System . out . print ( row * col ); System . out . print ( \" \" ); //adds a space } System . out . println (); //line break } will print a (poorly formatted) times table. Note that all three parts of a for loop are optional. That is, a loop like for (;;) { //something } will execute forever. Questions Determine the number of times the following for loops will execute. for ( int i = 4 ; i <= 8 ; i += 2 ) { /*do something*/ } for ( int i = 10 ; i >= 0 ; i -= 3 ) { /*do something*/ } for ( int j = 2 ; j >= 4 ; j ++ ) { /*do something*/ } Answers 3 4 0 Exercises Write a program that computes the sum of all odd integers from 1 to a number specified by the user Write a program that computes b^e b^e (a number raised to the power of an exponent), where b and e are positive integers Write a program that allows the user to enter a number, setSize . setSize numbers, num , follow and are inputted by the user. Print the average, largest, and smallest of the numbers.","title":"for Loops"},{"location":"develop/java/L2/#loop-control","text":"There are two control statements that are used with loops:","title":"Loop Control"},{"location":"develop/java/L2/#break","text":"The break statement will immediately exit a while or for loop. This can be useful if you're looking for a specific value, and you want the loop to end after you've found that value. For instance, in the below example, the loop will terminate immediately after the value key is found: int key = 8 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( i == key ) { System . out . println ( \"Found\" ); break ; } System . out . println ( \"Not found...\" ); } As a result, Not found ... will be printed out eight times at first, followed by Found . The loop will then terminate. The break statement will be more useful after you learn about arrays.","title":"break"},{"location":"develop/java/L2/#continue","text":"The continue statement will immediately go to the next iteration of a for or while loop, bypassing all statements after it. This could be used when you only want to execute a loop for some values. Of course, an if - else statement can often accomplish the same thing, but break and continue statements can prevent too many nested blocks of code. For instance, the following block of code for ( int i = 0 ; i < 4 ; i ++ ) { System . out . println ( \"Going... \" + i ); if ( i >= 2 ) { continue ; } System . out . println ( \"Here\" ); } will print Going ... 0 Here Going ... 1 Here Going ... 2 Going ... 3","title":"continue"},{"location":"develop/java/L2/#characters","text":"In addition to the primitive data types ( boolean , int , double ) we learned about before, char s represent one of the 256 ASCII characters . These include the numbers, standard symbols and punctuation on a keyboard, and both uppercase and lowercase letters. A char is assigned a value with the declaration char allianceColor = 'R' ; Note the use of single quotation marks rather than double quotation marks (which are used for String s) and that a variable of type char may only contain a single character. Escape characters are the first 32 ASCII characters, which serve special functions. The most commonly used is '\\n' , which creates a line break. In addition, quotation marks must be escaped. Thus, executing the following code char quote1 = '\\'' ; char quote2 = '\\\"' ; char newLine = '\\n' System . out . print ( quote1 ); System . out . print ( newLine ); System . out . print ( quote2 ); will print ' \" Note that strings can be thought of as a series of char s concatenated together. For instance, executing String someText = \"Kickoff, 2017 \\n As we anticipated the new game, the livestream blared, \\\" STEAM POWERED! STEAM POWERED! STEAM POWERED! \\\" \" ; System . out . println ( someText ); will print Kickoff , 2017 As we anticipated the new game , the livestream blared , \"STEAM POWERED! STEAM POWERED! STEAM POWERED!\" The value of characters may be compared with the equivalence ( == ) operator. For example, allianceColor == 'R' is true . Note, however, that a character is not equal its int equivalent. That is, '1' == 1 is false .","title":"Characters"},{"location":"develop/java/L2/#string-manipulation","text":"The String class in Java contains many methods to manipulate strings. We will present an overview of the most useful ones, though you may read the full documentation here .","title":"String Manipulation"},{"location":"develop/java/L2/#concatenation","text":"A string can be concatenated , or joined together, with other strings or primitive datatypes (and literals) with the + operator. For example, executing the following: String mascot = \"Raider\" ; int teamNum = 25 ; String teamName = mascot + \" Robotix\" ; System . out . println ( \"The year is \" + 2017 ); System . out . println ( \"I am on Team \" + teamNum + \", \" + teamName ); will print The year is 2017 I am on Team 25 , Raider Robotix You may also concatenate a string onto the end of another with the += operator. Executing String s = \"Hello\" ; s += \" World!\" ; System . out . println ( s ); will print Hello World ! .","title":"Concatenation"},{"location":"develop/java/L2/#string-properties","text":"You can check the length of a string (number of characters) with the string . length () method. Executing String s = \"Hello\" ; System . out . println ( s + \" is \" + s . length () + \" characters long\" ); System . out . print ( \"World!\" . length ()); will print Hello is 5 characters long 6 You can also check if a string contains a specific character sequence with the string . contains ( < character sequence > ) method, which returns a boolean value. If String s = \"Hello\" ; is declared, s . contains ( \"ell\" ) returns true , while s . contains ( \"f\" ) returns false .","title":"String Properties"},{"location":"develop/java/L2/#parsing-a-string","text":"You may want to parse through a string sometimes, or check the sequence of its characters. The string . charAt ( /*index*/ ) method will return the character currently at the index. There are two things you should know about the method: The method will return a value of type char (character), rather than String . The index is a value that is greater than or equal to 0 and less than string . length () . That is, the index of the first character in the string is 0 , and the index of the last character in the string is string . length () - 1 . If String s = \"World\" ; is declared, s . charAt ( 0 ) returns 'W' , s . charAt ( 3 ) returns 'l' , and s . charAt ( 4 ) returns 'd' . A standard way to parse through all of the characters of a string is with the following for loop: String str = \"Hello World!\" ; for ( int i = 0 ; i < str . length (); i ++ ) { char currentChar = str . charAt ( i ); //Do something here }","title":"Parsing a String"},{"location":"develop/java/L2/#substrings","text":"Suppose you want to return a slice of a string, known as a substring, such as the first letter four letters of String s = \"Raider Robotix\" ; . An easy-to-understand way would be to use string parsing, similar to what we did above: String s = \"Raider Robotix\" ; String result = \"\" ; // an empty string for ( int i = 0 ; i < 4 && i < s . length (); i ++ ) { result += s . charAt ( i ); } System . out . println ( result ); This would print out Raid . Note that the expression i < s . length () was still present in the exit condition in order to prevent errors if s was an input string that was less than four characters long. However, a faster way to get result would be to use the substring ( beginIndex , endIndex ) method, in which beginIndex and endIndex are integers that represent the indicies that you want to search. Similar to the for loop above, beginIndex is inclusive, while endIndex is exclusive. Here are some examples: s . substring ( 0 , 4 ); returns Raid s . substring ( 7 , s . length ()); returns Robotix \"hamburger\" . substring ( 4 , 8 ); returns urge","title":"Substrings"},{"location":"develop/java/L2/#miscellaneous-string-functions","text":"Assume that String s = \"Hello\" ; is declared in the following examples: s . toLowerCase (); returns hello s . toUpperCase (); returns HELLO s . indexOf ( \"l\" ); returns 2 (the first occurence of l in s ), while s . lastIndexOf ( \"l\" ) returns 3 s . concat ( \"world\" ); returns Helloworld As mentioned before, string equality is checked with s . equals ( \"Hello\" ); , which would return true . On the other hand, after declaring String anotherString = \"Hello\" ; , the boolean expression s == anotherString || s == \"Hello\" would be false , as string are objects , not primitives . Exercises Write a program to reverse a string if it has an R in it. Write a program to check if a alphanumeric string is a palindrome (reads the same backward as forward, such as racecar ). Note that Racecar , 123 racecar321 , and RaCeCaR are also palindromes. Write a program to replaces all commas from a string with semicolons Given a sentence, write a program to print its words backwards, so that My name is Bob becomes Bob is name My . Given two strings and an integer n , check if there exist a substring of length n in the first string that is also a substring of the second string","title":"Miscellaneous String Functions"},{"location":"develop/java/L2/#the-math-class","text":"The Math class contains several methods that you may find helpful. It is imported by default, and documentation is found here . For these examples, we will declare double a = 4.5 , b = - 2.5 ; Math . abs ( b ) : takes the absolute value of a number, returns 2.5 in the example Math . ceil ( a ) : takes the ceiling of a number (rounds it up if it is a decimal), returns 5 in the example Math . floor ( a ) : takes the floor of a number (rounds it down if it is a decimal), returns 4 in the example Math . pow ( a - 0.5 , - b + 0.5 ) : takes the first number to the power of the second number, returns 125.0 in the example Math . sqrt ( a - 0.5 ) : takes the square root of a number, returns 2.0 in this example Math . PI : returns the value of pi (3.141592653589793) Math . random () : returns a random double in the interval [0.0, 1.0). This can be used to generate a random integer within a particular range by clamping the number down, then casting it to an int . For example, if you want a random integer in the interval [ lower , upper ], you would declare int randInt = ( int ) ( Math . random () * ( upper - lower )) + lower ; . Try it out! Exercises Write a program that solves quadratic equations of the form 0=ax^2+bx+c 0=ax^2+bx+c for x x , where a a , b b , and c c are coefficients given by the user Write a program that calculates the average of a data set, given the numbers in the set and its length Write a program to find the surface area and volume of a square pyramid, given its side length and height Write a program to round a number to a specific number of decimal places","title":"The Math Class"},{"location":"develop/java/L2/#assignment","text":"Complete the Raider Robotix Printer and Binary Converter programs. Please email or DM me via Slack the programs that you finish for feedback.","title":"Assignment"},{"location":"develop/java/L3/","text":"Lesson 3 - Methods Here's a short lesson on one of the building blocks of Java that will prepare you for object-orientated programming: methods. Method signature A method (also known as a function in other languages) is essentially a function, very similar to one that you would encounter in math class. It has an input, an output, and a name (or identifier), though these must have specific data types (think a limited domain/range). Here is a sample method ( isEven ) being declared within a class: public class Example { public boolean isEven ( int num ) { if ( num % 2 == 0 ) { return true ; } return false ; } public static void main ( String [] args ) { //main method //code executed here first } } In this example, the method signature is simply public boolean isEven ( int num ) . It consists of visibility modifiers ( public , private , protected , etc.), a return type ( boolean ), a method identifier ( isEven ), and a set of parameters ( int num ). These parameters must each have a datatype, followed by an identifier, similar to declaring a variable. To list multiple parameters, list each one individually within the parentheses, then separate them with a comma, like in the following example: public int getNumRpPowerUp ( int redScore , int blueScore , boolean autoQuestComplete , int numClimbs , boolean levitateUsed ) { int totalRp = 0 ; if ( redScore > blueScore ) totalRp += 2 ; if ( redScore == blueScore ) totalRp ++; if ( autoQuestComplete ) totalRp ++ if ( numClimbs == 3 || numClimbs == 2 && levitateUsed ) totalRp ++ return totalRp ; } Note that a value with the same type as the specified return type ( int in this case) must be returned by the method. This is accomplished by typing the word return followed by a variable or literal value of the specified return type. For instance, the statement return 0 ; would be valid in getNumRpPowerUp as well. Note that the method immediately ends once a return statement is executed. It it possible for a method to have no parameters and/or return type as well. With no parameters, simply leave the contents of the parentheses following the method name blank: public String getInfoString () { return \"Hello World!\" ; } If you don't want to return a value from the method, the return type should be specified as void . A return statement is not necessary: public void printInfo ( int currentMatchNum , String scoutName ) { System . out . println ( scoutName + \" - Match \" + currentMatchNum ); } You've already used methods to find properties of an object or to compute values, such as with str . length () or Math . pow ( base , power ) . In general, a method call is accomplished by typing the method name, followed by its parameters. The return value (if there is one) can then be used, either within a conditional statement, loop, or assigned to a variable: int red = 200 , blue = 30 , climbs = 1 ; boolean levitated = true ; int rpGained = getNumRpPowerUp ( red , blue , true , climbs , levitated ); while ( isEven ( rpGained )) { //do something } Why methods? So, why are methods so important if they're just executing a block of pre-written code? Well, creating multiple methods in an application or program allows you to break down a problem and do certain tasks repeatedly. For instance, if you wanted to test if a series of numbers were even in different parts of a program, it would be easier to make a call to isEven ( num ) rather than remembering that if a number mod 2 is 0, it is even. Another way to structure an application is to have methods responsible for specific tasks, such as saving a file or verifying if a password matches the one that was stored. As long as you test a method after you write it and ensure it gives the correct output for a variety of input parameters, you can use it throughout an application without needing to refer back to the actual method's source code. That also makes it easy to collaborate with each other, as each person working on a project could be responsible for writing and testing one method; as long as those work independently, you could implement them together in the final product. Overloading methods Sometimes, a method should be able to have different set of parameters, of different data types. In this case, the parameter list will need to be modfied: public double average ( int num1 , int num2 ) { return ( num1 + num2 ) / 2.0 ; } public double average ( double a , double b ) { return ( a + b ) / 2.0 ; } Depending on the datatypes of the parameters when you make the method call, the compiler will know which method to execute. Note that the return type for a particular method name must always be the same, and a method cannot be overloaded if its signature is otherwise identical (parameters have the same datatypes, in the same order). Recursion Like in math, methods can call themselves or other methods within the body of their code. For instance, the following returns the n th Fibonacci number (1, 1, 2, 3, 5, ...): int fib ( int n ) { if ( n == 1 ) return 1 ; if ( n == 2 ) return 1 ; return fib ( n - 1 ) + fib ( n - 2 ); } Recursion is useful for creating simple methods, but their running time can sometimes be slow, and you must always ensure that you reach a base case ( n == 1 or n == 2 in this example) that returns a literal value. Refer to the binary search method if you want to see a more complex example of recursion. Algorithmic challenges Do as many as you want, until you get a good feel of when to implement methods and how to break down a problem: Write a recursive method to compute the factorial of a number. Note that 0! is equal to 1. Write a program that takes any English sentence without punctuation as an input, then converts it to Pig Latin . Implement a more efficient (non-recursive) algorithm to find the n^\\text{th} n^\\text{th} Fibonacci number Determine the sum of all prime numbers from 2 to a number specified by the user. A number is superb if and only if the sum of all of its factors (excluding itself) is less than a number. Write a program to determine the number of superb numbers between two numbers (e.g. 1 and 100) that are specified by the user. Given a series of variable identifiers in camelCase, identify the number of actual words in the string (e.g. numberOfRankingPoints has four actual words). Given the length of a set of integers S, followed the elements (numbers) of S, determine if S contains only consecutive integers, without repeats (e.g. {3, 5, 4, 6} {3, 5, 4, 6} does, while {6, 4, 3} {6, 4, 3} and {1, 2, 2, 3} {1, 2, 2, 3} do not). Given a series of lowercase strings without spaces or punctuation, determine if any two adjacent strings (inputted right after each other) are anagrams of each other. Write a program to determine if a number is a palindrome. Write methods that compute the least common multiple and greatest common factor of two positive integers. Please email or DM me via Slack any challenges that you finish for feedback!","title":"Lesson 3: Methods"},{"location":"develop/java/L3/#lesson-3-methods","text":"Here's a short lesson on one of the building blocks of Java that will prepare you for object-orientated programming: methods.","title":"Lesson 3 - Methods"},{"location":"develop/java/L3/#method-signature","text":"A method (also known as a function in other languages) is essentially a function, very similar to one that you would encounter in math class. It has an input, an output, and a name (or identifier), though these must have specific data types (think a limited domain/range). Here is a sample method ( isEven ) being declared within a class: public class Example { public boolean isEven ( int num ) { if ( num % 2 == 0 ) { return true ; } return false ; } public static void main ( String [] args ) { //main method //code executed here first } } In this example, the method signature is simply public boolean isEven ( int num ) . It consists of visibility modifiers ( public , private , protected , etc.), a return type ( boolean ), a method identifier ( isEven ), and a set of parameters ( int num ). These parameters must each have a datatype, followed by an identifier, similar to declaring a variable. To list multiple parameters, list each one individually within the parentheses, then separate them with a comma, like in the following example: public int getNumRpPowerUp ( int redScore , int blueScore , boolean autoQuestComplete , int numClimbs , boolean levitateUsed ) { int totalRp = 0 ; if ( redScore > blueScore ) totalRp += 2 ; if ( redScore == blueScore ) totalRp ++; if ( autoQuestComplete ) totalRp ++ if ( numClimbs == 3 || numClimbs == 2 && levitateUsed ) totalRp ++ return totalRp ; } Note that a value with the same type as the specified return type ( int in this case) must be returned by the method. This is accomplished by typing the word return followed by a variable or literal value of the specified return type. For instance, the statement return 0 ; would be valid in getNumRpPowerUp as well. Note that the method immediately ends once a return statement is executed. It it possible for a method to have no parameters and/or return type as well. With no parameters, simply leave the contents of the parentheses following the method name blank: public String getInfoString () { return \"Hello World!\" ; } If you don't want to return a value from the method, the return type should be specified as void . A return statement is not necessary: public void printInfo ( int currentMatchNum , String scoutName ) { System . out . println ( scoutName + \" - Match \" + currentMatchNum ); } You've already used methods to find properties of an object or to compute values, such as with str . length () or Math . pow ( base , power ) . In general, a method call is accomplished by typing the method name, followed by its parameters. The return value (if there is one) can then be used, either within a conditional statement, loop, or assigned to a variable: int red = 200 , blue = 30 , climbs = 1 ; boolean levitated = true ; int rpGained = getNumRpPowerUp ( red , blue , true , climbs , levitated ); while ( isEven ( rpGained )) { //do something }","title":"Method signature"},{"location":"develop/java/L3/#why-methods","text":"So, why are methods so important if they're just executing a block of pre-written code? Well, creating multiple methods in an application or program allows you to break down a problem and do certain tasks repeatedly. For instance, if you wanted to test if a series of numbers were even in different parts of a program, it would be easier to make a call to isEven ( num ) rather than remembering that if a number mod 2 is 0, it is even. Another way to structure an application is to have methods responsible for specific tasks, such as saving a file or verifying if a password matches the one that was stored. As long as you test a method after you write it and ensure it gives the correct output for a variety of input parameters, you can use it throughout an application without needing to refer back to the actual method's source code. That also makes it easy to collaborate with each other, as each person working on a project could be responsible for writing and testing one method; as long as those work independently, you could implement them together in the final product.","title":"Why methods?"},{"location":"develop/java/L3/#overloading-methods","text":"Sometimes, a method should be able to have different set of parameters, of different data types. In this case, the parameter list will need to be modfied: public double average ( int num1 , int num2 ) { return ( num1 + num2 ) / 2.0 ; } public double average ( double a , double b ) { return ( a + b ) / 2.0 ; } Depending on the datatypes of the parameters when you make the method call, the compiler will know which method to execute. Note that the return type for a particular method name must always be the same, and a method cannot be overloaded if its signature is otherwise identical (parameters have the same datatypes, in the same order).","title":"Overloading methods"},{"location":"develop/java/L3/#recursion","text":"Like in math, methods can call themselves or other methods within the body of their code. For instance, the following returns the n th Fibonacci number (1, 1, 2, 3, 5, ...): int fib ( int n ) { if ( n == 1 ) return 1 ; if ( n == 2 ) return 1 ; return fib ( n - 1 ) + fib ( n - 2 ); } Recursion is useful for creating simple methods, but their running time can sometimes be slow, and you must always ensure that you reach a base case ( n == 1 or n == 2 in this example) that returns a literal value. Refer to the binary search method if you want to see a more complex example of recursion.","title":"Recursion"},{"location":"develop/java/L3/#algorithmic-challenges","text":"Do as many as you want, until you get a good feel of when to implement methods and how to break down a problem: Write a recursive method to compute the factorial of a number. Note that 0! is equal to 1. Write a program that takes any English sentence without punctuation as an input, then converts it to Pig Latin . Implement a more efficient (non-recursive) algorithm to find the n^\\text{th} n^\\text{th} Fibonacci number Determine the sum of all prime numbers from 2 to a number specified by the user. A number is superb if and only if the sum of all of its factors (excluding itself) is less than a number. Write a program to determine the number of superb numbers between two numbers (e.g. 1 and 100) that are specified by the user. Given a series of variable identifiers in camelCase, identify the number of actual words in the string (e.g. numberOfRankingPoints has four actual words). Given the length of a set of integers S, followed the elements (numbers) of S, determine if S contains only consecutive integers, without repeats (e.g. {3, 5, 4, 6} {3, 5, 4, 6} does, while {6, 4, 3} {6, 4, 3} and {1, 2, 2, 3} {1, 2, 2, 3} do not). Given a series of lowercase strings without spaces or punctuation, determine if any two adjacent strings (inputted right after each other) are anagrams of each other. Write a program to determine if a number is a palindrome. Write methods that compute the least common multiple and greatest common factor of two positive integers. Please email or DM me via Slack any challenges that you finish for feedback!","title":"Algorithmic challenges"},{"location":"develop/java/L4/","text":"Lesson 4 - Object Orientated Design We explored String s in previous lessons, which was your first look at an object in Java. In fact, you've been writing programs inside of a main function, which is a method inside a function! In this lesson, we'll see what an object really is and why they're so useful. Why objects? Objects have both state , variables that remain constant until you modify them, and behavior , which are seen through callable methods that either feed your main method information about that object or operate on its state. As programmers, you need to design objects so that their state and behavior are appropriate for what you're trying to accomplish, while breaking down code into testable and understandable building blocks. It's probably easiest to think of an object like an object in the real world, such as a person or a dog. It could have states like a name, age, favorite color, and friends. Similarly, a Person object could have behaviors like befriending another person if they have the same favorite color, increasing its age every year, or saying its name. Objects may also want to keep some state variables private , such as a credit card number. These are just examples, but you'll see as we go about modeling a person in this lesson. In essence, objects make programming real-world mechanisms and representing real-world entities a lot easier. You could have a Robot object drive a certain distance, deposit and earn interest in a BankAccount , or read the state of an Actuator on a Robot . Constructors and member variables A class is the blueprint behind an object, which is something you should already be familiar with from writing programs. Each class should generally be in its own . java file, called ClassName . java . It's possible to have multiple classes within a file, but we'll get to that later. Inside Person . java : // Import statements come first import java.util.Scanner ; public class Person { public static void main ( String [] args ){ // do stuff here } } This is probably what you're familiar with right now. Now, we'll add in some fields, called member variables , to the Person class that will help identify it: public class Person { String name , favoriteColor ; int age , numFriends ; } To initialize these attributes, we'll also need a constructor , which is essentially a method that returns an instance of that class while assigning values to as many member variables as you'd like. public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ) { this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } Note that the identifier for a constructor is simply the name of the class, though the parameters can be any datatype, and there is no return statement. Like other methods, constructors can also be overloaded with arguments of different datatypes. An empty constructor is automatically created if no constructor is declared for a class, which simply doesn't set any member variables. To access member variables, we use the keyword this , referring to the new instance of the object, followed by the dot operator and the identifiers of the variables you want to modify. This also distinguishes the name variable in the parameter of the constructor with the name variable that's part of the object's state. Member variables must be assigned a value, either explicitly through the code of the class or via a constructor, before their value can be accessed. They can also either be objects or primitive values. Declaring objects So, how exactly do you create an object with the constructor? Well, it's similar to declaring any other variable in Java, complete with a datatype and identifier, except you'll need to use the new keyword: public static void main ( String [] args ) { Person mentor = new Person ( \"Cokeley\" ); } This creates an instance of a Person , which is stored in mentor . Now, if you want to access or modify attributes of mentor , you'll use the same dot operator that was used in the constructor: mentor . age = 25 ; System . out . println ( mentor . name + \" is \" + mentor . age + \" years old\" ); This will print out Cokeley is 25 years old . Class methods While having objects as a simple data structure with various attributes is useful, sometimes you want a little more interactivity. That's when we can create our own methods in a class. We can spice up the Person class by adding in the following: public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } boolean makeFriends ( Person possibleFriend ){ if ( possibleFriend . favoriteColor . equals ( this . favoriteColor )) { this . numFriends ++ ; possibleFriend . numFriends ++ ; return true ; } return false ; } } This makeFriends method mutually has two people become friends if their favoriteColor is the same, then returns true if they've become friends, or false otherwise. Another example can be seen with this RightTriangle class: class RightTriangle { double legOne , legTwo , hypotenuse ; RightTriangle ( double side1 , double side2 , double side3 ) { this . hypotenuse = Math . max ( Math . max ( side1 , side2 ), side3 ); this . legOne = Math . min ( Math . min ( side1 , side2 ), side3 ); this . legTwo = side1 + side2 + side3 - this . legOne - this . hypotenuse ; } double getArea () { return 0.5 * this . legOne * this . legTwo ; } double getPerimeter () { return this . legOne + this . legTwo + this . hypotenuse ; } // Returns smaller acute angle in radians double getSmallerAngle () { return Math . atan ( this . legOne / this . legTwo ); } // Returns larger acute angle in radians double getLargerAngle () { return Math . PI / 2 - this . getSmallerAngle (); } // Extends the length of the shorter leg and // adjusts the length of the hypotenuse accordingly void extendLegOne ( double newLength ) { if ( newLength > this . legTwo ){ this . legOne = this . legTwo ; this . legTwo = newLength ; } else this . legOne = newLength ; this . hypotenuse = Math . sqrt ( Math . pow ( this . legOne , 2 ) + Math . pow ( this . legTwo , 2 )); } } Here, after initializing a RightTriangle object, we can use its different instance methods to get and modify its properties. For instance, executing the following in the main method RightTriangle tri = new RightTriangle ( 4 , 3 , 5 ); System . out . println ( \"Perimeter: \" + tri . getPerimeter ()); System . out . println ( \"Area: \" + tri . getArea ()); System . out . println ( \"Smaller Angle: \" + tri . getSmallestAngle () + \" rad\" ); tri . extendLegOne ( 10 ); System . out . println ( \"New Perimeter: \" + tri . getPerimeter ()); will print Perimeter : 12.0 Area : 6.0 Smallest Angle : 0.6435011087932844 rad New Perimeter : 24.77032961426901 Visibility Sometimes it is desirable to reduce the access and visibility of object methods or instance variables. For example, you generally wouldn't want a main method to be able to change a Person object's name explicitly, or perhaps you want to modify a BankAccount object's balance only through withdrawal and deposit methods, each requiring a PIN code. In that case, it's best to leave member variables private instead of public . To do this, simply put the visibility modifier in front of the variable identifier, like so: public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ) { this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } That way, private level access only allows those variables to be accessed and modified within the same class (such as within the constructor or other class methods). On the other hand, public level access allows all classes to modify a variable or call a method, while default access (not putting any modifier) only allows classes of the same package to access variables/methods. We'll get into packages later on, but just know that they're ways of grouping similar classes for now. So, how are we supposed to modify and access attributes like favoriteColor so the method makeFriends can still function properly? For the first case, we'll use a special type of method called a setter , while we create a getter to do the latter: private public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ) { this . age = 0 ; this . numFriends = 0 ; this . name = name ; } public void setFavoriteColor ( String favoriteColor ) { this . favoriteColor = favoriteColor ; } public String getFavoriteColor () { return this . favoriteColor ; } } It's pretty simple: a setter has an argument datatype that's the same as the member variable, sets the member variable, then returns nothing. Meanwhile, a getter has the same return type as the member variable, has no parameters, and simply returns the value of the member variable. In fact, these methods are so common (as it's good practice to set variables as private ) that most IDEs (including Eclipse) have a way to automatically generate setters and getters for a class. Finally, static methods and variables are called directly on a class, rather than on an instance of a class. You've already seen examples of these in the Math class: the variable Math . PI and the method Math . pow ( base , exp ) can be called without declaring an instance of a Math object via the new keyword. It's important to note that static variables are shared by all instances of a given class (and thus can be used as temporary storage). Also, static methods cannot access non- static variables or methods. You can make a static method private or public by putting the visibility modifier in front of the word static , such as in public static void main ( String [] args ) . Scope Our last topic is something that we've used throughout this lesson without realizing it; variable identifiers often come in conflict with each other. In that case, which value do we use? The smallest scope is in a loop: for ( int i = 1 ; i < 5 ; i ++ ) { double area = Math . pow ( i , 2 ); } In this case, both i and area have block scope and cannot be modified or accessed outside of the for loop. You'll see that a set of curly braces generally denotes scope. Note that variables with the identifier i or area cannot exist outside of the loop either. Next up are local variables, also known as method scope : public void setSideLength ( int sideLength ) { double squareArea = Math . pow ( sideLength , 2 ); this . sideLength = sideLength ; } Both sideLength and squareArea can be accessed/modified only within the method setSideLength . However, using the keyword this and the dot operator will refer to the member variable sideLength of the class, rather than the one passed in as an argument. All variables other than member variables cannot be accessed outside of a class, which then follow the visibility rules discussed before. HW: Modeling Bank Accounts We've discussed bank accounts throughout this lesson. Now it's time to implement one! Each BankAccount object has the following attributes, which should all be private : balance : a double indicating the amount of money in the bank account. Cannot be negative. pin : a four-digit code that authenticates a user. May contain leading zeroes (i.e. 0000 is a valid PIN) name : the name of the bank account owner interestRate : the percent of interest earned by a user in a given year, shared across all bank accounts Challenge : id : a random, five-digit code that's generated upon the creation of the bank account to identify it. Does not contain leading zeroes. You may want to refer back to the Math . random method from Lesson 2. Methods should be provided to do the following: Construct a BankAccount with a PIN, owner, and initial balance Challenge : Construct a BankAccount with a PIN, owner, and initial balance of $0.00 Get the name of the owner of an account Get the id of the account Change the PIN of the account, given the old PIN and the new PIN. Should return some form of feedback to determine if the PIN was successfully changed Withdraw money from an account, given its PIN and the amount desired. Should indicate if withdrawal was successful and should not allow it if the account doesn't have enough money Deposit a given amount of money into the account Earn interest for the year, based on the interestRate Challenge : Transfer money from one account to another, given another BankAccount object and its PIN You do not need to submit a main method as a driver for your class, though you will need to write one to test if your class works. Next lesson, you'll write one to complete specific tasks when you learn about arrays and HashMaps to create a network of bank accounts. Please email me your completed class or DM me via Slack.","title":"Lesson 4: Objects"},{"location":"develop/java/L4/#lesson-4-object-orientated-design","text":"We explored String s in previous lessons, which was your first look at an object in Java. In fact, you've been writing programs inside of a main function, which is a method inside a function! In this lesson, we'll see what an object really is and why they're so useful.","title":"Lesson 4 - Object Orientated Design"},{"location":"develop/java/L4/#why-objects","text":"Objects have both state , variables that remain constant until you modify them, and behavior , which are seen through callable methods that either feed your main method information about that object or operate on its state. As programmers, you need to design objects so that their state and behavior are appropriate for what you're trying to accomplish, while breaking down code into testable and understandable building blocks. It's probably easiest to think of an object like an object in the real world, such as a person or a dog. It could have states like a name, age, favorite color, and friends. Similarly, a Person object could have behaviors like befriending another person if they have the same favorite color, increasing its age every year, or saying its name. Objects may also want to keep some state variables private , such as a credit card number. These are just examples, but you'll see as we go about modeling a person in this lesson. In essence, objects make programming real-world mechanisms and representing real-world entities a lot easier. You could have a Robot object drive a certain distance, deposit and earn interest in a BankAccount , or read the state of an Actuator on a Robot .","title":"Why objects?"},{"location":"develop/java/L4/#constructors-and-member-variables","text":"A class is the blueprint behind an object, which is something you should already be familiar with from writing programs. Each class should generally be in its own . java file, called ClassName . java . It's possible to have multiple classes within a file, but we'll get to that later. Inside Person . java : // Import statements come first import java.util.Scanner ; public class Person { public static void main ( String [] args ){ // do stuff here } } This is probably what you're familiar with right now. Now, we'll add in some fields, called member variables , to the Person class that will help identify it: public class Person { String name , favoriteColor ; int age , numFriends ; } To initialize these attributes, we'll also need a constructor , which is essentially a method that returns an instance of that class while assigning values to as many member variables as you'd like. public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ) { this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } Note that the identifier for a constructor is simply the name of the class, though the parameters can be any datatype, and there is no return statement. Like other methods, constructors can also be overloaded with arguments of different datatypes. An empty constructor is automatically created if no constructor is declared for a class, which simply doesn't set any member variables. To access member variables, we use the keyword this , referring to the new instance of the object, followed by the dot operator and the identifiers of the variables you want to modify. This also distinguishes the name variable in the parameter of the constructor with the name variable that's part of the object's state. Member variables must be assigned a value, either explicitly through the code of the class or via a constructor, before their value can be accessed. They can also either be objects or primitive values.","title":"Constructors and member variables"},{"location":"develop/java/L4/#declaring-objects","text":"So, how exactly do you create an object with the constructor? Well, it's similar to declaring any other variable in Java, complete with a datatype and identifier, except you'll need to use the new keyword: public static void main ( String [] args ) { Person mentor = new Person ( \"Cokeley\" ); } This creates an instance of a Person , which is stored in mentor . Now, if you want to access or modify attributes of mentor , you'll use the same dot operator that was used in the constructor: mentor . age = 25 ; System . out . println ( mentor . name + \" is \" + mentor . age + \" years old\" ); This will print out Cokeley is 25 years old .","title":"Declaring objects"},{"location":"develop/java/L4/#class-methods","text":"While having objects as a simple data structure with various attributes is useful, sometimes you want a little more interactivity. That's when we can create our own methods in a class. We can spice up the Person class by adding in the following: public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } boolean makeFriends ( Person possibleFriend ){ if ( possibleFriend . favoriteColor . equals ( this . favoriteColor )) { this . numFriends ++ ; possibleFriend . numFriends ++ ; return true ; } return false ; } } This makeFriends method mutually has two people become friends if their favoriteColor is the same, then returns true if they've become friends, or false otherwise. Another example can be seen with this RightTriangle class: class RightTriangle { double legOne , legTwo , hypotenuse ; RightTriangle ( double side1 , double side2 , double side3 ) { this . hypotenuse = Math . max ( Math . max ( side1 , side2 ), side3 ); this . legOne = Math . min ( Math . min ( side1 , side2 ), side3 ); this . legTwo = side1 + side2 + side3 - this . legOne - this . hypotenuse ; } double getArea () { return 0.5 * this . legOne * this . legTwo ; } double getPerimeter () { return this . legOne + this . legTwo + this . hypotenuse ; } // Returns smaller acute angle in radians double getSmallerAngle () { return Math . atan ( this . legOne / this . legTwo ); } // Returns larger acute angle in radians double getLargerAngle () { return Math . PI / 2 - this . getSmallerAngle (); } // Extends the length of the shorter leg and // adjusts the length of the hypotenuse accordingly void extendLegOne ( double newLength ) { if ( newLength > this . legTwo ){ this . legOne = this . legTwo ; this . legTwo = newLength ; } else this . legOne = newLength ; this . hypotenuse = Math . sqrt ( Math . pow ( this . legOne , 2 ) + Math . pow ( this . legTwo , 2 )); } } Here, after initializing a RightTriangle object, we can use its different instance methods to get and modify its properties. For instance, executing the following in the main method RightTriangle tri = new RightTriangle ( 4 , 3 , 5 ); System . out . println ( \"Perimeter: \" + tri . getPerimeter ()); System . out . println ( \"Area: \" + tri . getArea ()); System . out . println ( \"Smaller Angle: \" + tri . getSmallestAngle () + \" rad\" ); tri . extendLegOne ( 10 ); System . out . println ( \"New Perimeter: \" + tri . getPerimeter ()); will print Perimeter : 12.0 Area : 6.0 Smallest Angle : 0.6435011087932844 rad New Perimeter : 24.77032961426901","title":"Class methods"},{"location":"develop/java/L4/#visibility","text":"Sometimes it is desirable to reduce the access and visibility of object methods or instance variables. For example, you generally wouldn't want a main method to be able to change a Person object's name explicitly, or perhaps you want to modify a BankAccount object's balance only through withdrawal and deposit methods, each requiring a PIN code. In that case, it's best to leave member variables private instead of public . To do this, simply put the visibility modifier in front of the variable identifier, like so: public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ) { this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } That way, private level access only allows those variables to be accessed and modified within the same class (such as within the constructor or other class methods). On the other hand, public level access allows all classes to modify a variable or call a method, while default access (not putting any modifier) only allows classes of the same package to access variables/methods. We'll get into packages later on, but just know that they're ways of grouping similar classes for now. So, how are we supposed to modify and access attributes like favoriteColor so the method makeFriends can still function properly? For the first case, we'll use a special type of method called a setter , while we create a getter to do the latter: private public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ) { this . age = 0 ; this . numFriends = 0 ; this . name = name ; } public void setFavoriteColor ( String favoriteColor ) { this . favoriteColor = favoriteColor ; } public String getFavoriteColor () { return this . favoriteColor ; } } It's pretty simple: a setter has an argument datatype that's the same as the member variable, sets the member variable, then returns nothing. Meanwhile, a getter has the same return type as the member variable, has no parameters, and simply returns the value of the member variable. In fact, these methods are so common (as it's good practice to set variables as private ) that most IDEs (including Eclipse) have a way to automatically generate setters and getters for a class. Finally, static methods and variables are called directly on a class, rather than on an instance of a class. You've already seen examples of these in the Math class: the variable Math . PI and the method Math . pow ( base , exp ) can be called without declaring an instance of a Math object via the new keyword. It's important to note that static variables are shared by all instances of a given class (and thus can be used as temporary storage). Also, static methods cannot access non- static variables or methods. You can make a static method private or public by putting the visibility modifier in front of the word static , such as in public static void main ( String [] args ) .","title":"Visibility"},{"location":"develop/java/L4/#scope","text":"Our last topic is something that we've used throughout this lesson without realizing it; variable identifiers often come in conflict with each other. In that case, which value do we use? The smallest scope is in a loop: for ( int i = 1 ; i < 5 ; i ++ ) { double area = Math . pow ( i , 2 ); } In this case, both i and area have block scope and cannot be modified or accessed outside of the for loop. You'll see that a set of curly braces generally denotes scope. Note that variables with the identifier i or area cannot exist outside of the loop either. Next up are local variables, also known as method scope : public void setSideLength ( int sideLength ) { double squareArea = Math . pow ( sideLength , 2 ); this . sideLength = sideLength ; } Both sideLength and squareArea can be accessed/modified only within the method setSideLength . However, using the keyword this and the dot operator will refer to the member variable sideLength of the class, rather than the one passed in as an argument. All variables other than member variables cannot be accessed outside of a class, which then follow the visibility rules discussed before.","title":"Scope"},{"location":"develop/java/L4/#hw-modeling-bank-accounts","text":"We've discussed bank accounts throughout this lesson. Now it's time to implement one! Each BankAccount object has the following attributes, which should all be private : balance : a double indicating the amount of money in the bank account. Cannot be negative. pin : a four-digit code that authenticates a user. May contain leading zeroes (i.e. 0000 is a valid PIN) name : the name of the bank account owner interestRate : the percent of interest earned by a user in a given year, shared across all bank accounts Challenge : id : a random, five-digit code that's generated upon the creation of the bank account to identify it. Does not contain leading zeroes. You may want to refer back to the Math . random method from Lesson 2. Methods should be provided to do the following: Construct a BankAccount with a PIN, owner, and initial balance Challenge : Construct a BankAccount with a PIN, owner, and initial balance of $0.00 Get the name of the owner of an account Get the id of the account Change the PIN of the account, given the old PIN and the new PIN. Should return some form of feedback to determine if the PIN was successfully changed Withdraw money from an account, given its PIN and the amount desired. Should indicate if withdrawal was successful and should not allow it if the account doesn't have enough money Deposit a given amount of money into the account Earn interest for the year, based on the interestRate Challenge : Transfer money from one account to another, given another BankAccount object and its PIN You do not need to submit a main method as a driver for your class, though you will need to write one to test if your class works. Next lesson, you'll write one to complete specific tasks when you learn about arrays and HashMaps to create a network of bank accounts. Please email me your completed class or DM me via Slack.","title":"HW: Modeling Bank Accounts"},{"location":"develop/java/L5/","text":"Lesson 5: Arrays & Dictionaries Arrays Initialization Printing Modifying elements ArrayList s References 2D Arrays Enumerations HashMap s HW: A Bank Network","title":"Lesson 5: Arrays & Dictionaries"},{"location":"develop/java/L5/#lesson-5-arrays-dictionaries","text":"","title":"Lesson 5: Arrays &amp; Dictionaries"},{"location":"develop/java/L5/#arrays","text":"","title":"Arrays"},{"location":"develop/java/L5/#initialization","text":"","title":"Initialization"},{"location":"develop/java/L5/#printing","text":"","title":"Printing"},{"location":"develop/java/L5/#modifying-elements","text":"","title":"Modifying elements"},{"location":"develop/java/L5/#arraylists","text":"","title":"ArrayLists"},{"location":"develop/java/L5/#references","text":"","title":"References"},{"location":"develop/java/L5/#2d-arrays","text":"","title":"2D Arrays"},{"location":"develop/java/L5/#enumerations","text":"","title":"Enumerations"},{"location":"develop/java/L5/#hashmaps","text":"","title":"HashMaps"},{"location":"develop/java/L5/#hw-a-bank-network","text":"","title":"HW: A Bank Network"},{"location":"develop/java/L6/","text":"Lesson 6 - Advanced Java Exceptions ArrayIndexOutOfBounds Arithmetic IO NullPointerException Comparators Exception handling try - catch throws Debugging in Eclipse","title":"Lesson 6: Advanced Java"},{"location":"develop/java/L6/#lesson-6-advanced-java","text":"","title":"Lesson 6 - Advanced Java"},{"location":"develop/java/L6/#exceptions","text":"","title":"Exceptions"},{"location":"develop/java/L6/#arrayindexoutofbounds","text":"","title":"ArrayIndexOutOfBounds"},{"location":"develop/java/L6/#arithmetic","text":"","title":"Arithmetic"},{"location":"develop/java/L6/#io","text":"","title":"IO"},{"location":"develop/java/L6/#nullpointerexception","text":"","title":"NullPointerException"},{"location":"develop/java/L6/#comparators","text":"","title":"Comparators"},{"location":"develop/java/L6/#exception-handling","text":"","title":"Exception handling"},{"location":"develop/java/L6/#try-catch","text":"","title":"try-catch"},{"location":"develop/java/L6/#throws","text":"","title":"throws"},{"location":"develop/java/L6/#debugging-in-eclipse","text":"","title":"Debugging in Eclipse"},{"location":"develop/java/L7/","text":"Lesson 7 - Advanced OOP Subclasses Inheritance Polymorphism Interfaces Abstract Classes","title":"Lesson 7: Advanced OOP"},{"location":"develop/java/L7/#lesson-7-advanced-oop","text":"","title":"Lesson 7 - Advanced OOP"},{"location":"develop/java/L7/#subclasses","text":"","title":"Subclasses"},{"location":"develop/java/L7/#inheritance","text":"","title":"Inheritance"},{"location":"develop/java/L7/#polymorphism","text":"","title":"Polymorphism"},{"location":"develop/java/L7/#interfaces","text":"","title":"Interfaces"},{"location":"develop/java/L7/#abstract-classes","text":"","title":"Abstract Classes"},{"location":"develop/java/binaryconverter/","text":"Binary Converter Objectives Learn to parse strings effectively Learn to use methods in the Math class Apply your knowledge to Java to implement an algorithm Task All data in computers are stored in binary, which is a base-2 number system in which the only digits are 0's and 1's. Write a program to convert a binary number to decimal. An algorithm to do this is found below, but additional information on decimal/binary may be found online. You should not use any built-in methods that you have not learned about in the lessons. Conversion Algorithm In a base-10 (decimal) number system, you obtain the value of a number by multiplying the exponent of the decimal place by the number in that place, then adding the products together. For example, to compute the value of 1234, you would compute 1234 = 10^0\\cdot4 + 10^1\\cdot3 + 10^2\\cdot2 + 10^3\\cdot1 1234 = 10^0\\cdot4 + 10^1\\cdot3 + 10^2\\cdot2 + 10^3\\cdot1 which is equal to 1\\cdot4 + 10\\cdot3 + 100\\cdot2 + 1000\\cdot1=1234 1\\cdot4 + 10\\cdot3 + 100\\cdot2 + 1000\\cdot1=1234 . The same applies to base-2 (binary), except you multiply by the powers of 2 instead of the powers of 10. To compute the value of 10110_2 10110_2 (binary), you compute (in decimal) 10110_2 = 2^0\\cdot0 + 2^1\\cdot1 + 2^2\\cdot1 + 2^3\\cdot0 + 2^4\\cdot1 10110_2 = 2^0\\cdot0 + 2^1\\cdot1 + 2^2\\cdot1 + 2^3\\cdot0 + 2^4\\cdot1 which is equal to 1\\cdot0 + 2\\cdot1 + 4\\cdot1 +8\\cdot0+16\\cdot1=22_{10} 1\\cdot0 + 2\\cdot1 + 4\\cdot1 +8\\cdot0+16\\cdot1=22_{10} (in decimal). Input Format The input will consist of an integer, numTestCases , on the first line, representing the number of test cases. numTestCases lines follow. There will be a binary number, binaryNum , on each line following numTestCases . Hint : What data type should numTestCases be? What about binaryNum ? Constraints 1\\leq \\texttt{numTestCases} \\leq 1000 1\\leq \\texttt{numTestCases} \\leq 1000 The decimal value of each binaryNum is between 0 and 2^{31}-1 2^{31}-1 ( Integer . MAX_VALUE ), inclusive Output Format Your output will consist of testCaseNum lines. On each line, print binaryNum , the words in decimal is , then the corresponding decimal value of binaryNum . For example, if your input is 2 10110 11 your output should be 10110 in decimal is 22 11 in decimal is 3 Sample Input 3 0 111 1111111111111111111111111111111 Sample Output 0 in decimal is 0 111 in decimal is 7 1111111111111111111111111111111 in decimal is 2147483647","title":"Binary Converter"},{"location":"develop/java/binaryconverter/#binary-converter","text":"","title":"Binary Converter"},{"location":"develop/java/binaryconverter/#objectives","text":"Learn to parse strings effectively Learn to use methods in the Math class Apply your knowledge to Java to implement an algorithm","title":"Objectives"},{"location":"develop/java/binaryconverter/#task","text":"All data in computers are stored in binary, which is a base-2 number system in which the only digits are 0's and 1's. Write a program to convert a binary number to decimal. An algorithm to do this is found below, but additional information on decimal/binary may be found online. You should not use any built-in methods that you have not learned about in the lessons.","title":"Task"},{"location":"develop/java/binaryconverter/#conversion-algorithm","text":"In a base-10 (decimal) number system, you obtain the value of a number by multiplying the exponent of the decimal place by the number in that place, then adding the products together. For example, to compute the value of 1234, you would compute 1234 = 10^0\\cdot4 + 10^1\\cdot3 + 10^2\\cdot2 + 10^3\\cdot1 1234 = 10^0\\cdot4 + 10^1\\cdot3 + 10^2\\cdot2 + 10^3\\cdot1 which is equal to 1\\cdot4 + 10\\cdot3 + 100\\cdot2 + 1000\\cdot1=1234 1\\cdot4 + 10\\cdot3 + 100\\cdot2 + 1000\\cdot1=1234 . The same applies to base-2 (binary), except you multiply by the powers of 2 instead of the powers of 10. To compute the value of 10110_2 10110_2 (binary), you compute (in decimal) 10110_2 = 2^0\\cdot0 + 2^1\\cdot1 + 2^2\\cdot1 + 2^3\\cdot0 + 2^4\\cdot1 10110_2 = 2^0\\cdot0 + 2^1\\cdot1 + 2^2\\cdot1 + 2^3\\cdot0 + 2^4\\cdot1 which is equal to 1\\cdot0 + 2\\cdot1 + 4\\cdot1 +8\\cdot0+16\\cdot1=22_{10} 1\\cdot0 + 2\\cdot1 + 4\\cdot1 +8\\cdot0+16\\cdot1=22_{10} (in decimal).","title":"Conversion Algorithm"},{"location":"develop/java/binaryconverter/#input-format","text":"The input will consist of an integer, numTestCases , on the first line, representing the number of test cases. numTestCases lines follow. There will be a binary number, binaryNum , on each line following numTestCases . Hint : What data type should numTestCases be? What about binaryNum ?","title":"Input Format"},{"location":"develop/java/binaryconverter/#constraints","text":"1\\leq \\texttt{numTestCases} \\leq 1000 1\\leq \\texttt{numTestCases} \\leq 1000 The decimal value of each binaryNum is between 0 and 2^{31}-1 2^{31}-1 ( Integer . MAX_VALUE ), inclusive","title":"Constraints"},{"location":"develop/java/binaryconverter/#output-format","text":"Your output will consist of testCaseNum lines. On each line, print binaryNum , the words in decimal is , then the corresponding decimal value of binaryNum . For example, if your input is 2 10110 11 your output should be 10110 in decimal is 22 11 in decimal is 3","title":"Output Format"},{"location":"develop/java/binaryconverter/#sample-input","text":"3 0 111 1111111111111111111111111111111","title":"Sample Input"},{"location":"develop/java/binaryconverter/#sample-output","text":"0 in decimal is 0 111 in decimal is 7 1111111111111111111111111111111 in decimal is 2147483647","title":"Sample Output"},{"location":"develop/java/robotixprinter/","text":"Raider Robotix Printer Objectives Learn string concatenation Implement for loops for test cases Use appropriate logic and operators in if and else statements Input Format The input will consist of two space separated integers, lowerLimit and upperLimit . Task Print the numbers from lowerLimit to upperLimit , inclusive, with each number on one line. However, for multiples of 3 print Raider instead of the number. For multiples of 7 print Robotix instead of the number. For multiples of three and seven, print RaiderRobotix . You should use an effective algorithm that uses as few if statements as possible. Maintain readable code and name variables appropriately. Hints What operator do you use to check if a number is a multiple of another? What is your precondition and break condition in a for loop to cycle through a range of numbers? Constraints lowerLimit and upperLimit are integers 0 \\leq \\texttt{lowerLimit} \\leq \\texttt{upperLimit} \\leq 2^{31}-1 0 \\leq \\texttt{lowerLimit} \\leq \\texttt{upperLimit} \\leq 2^{31}-1 Sample Input 10 25 Sample Output 10 11 Raider 13 Robotix Raider 16 17 Raider 19 20 RaiderRobotix 22 23 Raider 25","title":"Raider Robotix Printer"},{"location":"develop/java/robotixprinter/#raider-robotix-printer","text":"","title":"Raider Robotix Printer"},{"location":"develop/java/robotixprinter/#objectives","text":"Learn string concatenation Implement for loops for test cases Use appropriate logic and operators in if and else statements","title":"Objectives"},{"location":"develop/java/robotixprinter/#input-format","text":"The input will consist of two space separated integers, lowerLimit and upperLimit .","title":"Input Format"},{"location":"develop/java/robotixprinter/#task","text":"Print the numbers from lowerLimit to upperLimit , inclusive, with each number on one line. However, for multiples of 3 print Raider instead of the number. For multiples of 7 print Robotix instead of the number. For multiples of three and seven, print RaiderRobotix . You should use an effective algorithm that uses as few if statements as possible. Maintain readable code and name variables appropriately. Hints What operator do you use to check if a number is a multiple of another? What is your precondition and break condition in a for loop to cycle through a range of numbers?","title":"Task"},{"location":"develop/java/robotixprinter/#constraints","text":"lowerLimit and upperLimit are integers 0 \\leq \\texttt{lowerLimit} \\leq \\texttt{upperLimit} \\leq 2^{31}-1 0 \\leq \\texttt{lowerLimit} \\leq \\texttt{upperLimit} \\leq 2^{31}-1","title":"Constraints"},{"location":"develop/java/robotixprinter/#sample-input","text":"10 25","title":"Sample Input"},{"location":"develop/java/robotixprinter/#sample-output","text":"10 11 Raider 13 Robotix Raider 16 17 Raider 19 20 RaiderRobotix 22 23 Raider 25","title":"Sample Output"},{"location":"develop/java/schoolday/","text":"A School Day Objectives Learn to use basic Java input/output Learn to declare and assign values to variables Demonstrate appropriate usage of variable identifiers Apply your knowledge of operators to solve a problem Use boolean expression appropriately Learn to use simple conditional statements Task You seem to have lost your calendar for this year and can only remember the days of the week that each month starts with. Write a program that determines if a particular date is a school day. There is school from Monday to Friday (inclusive), except on holidays and in July and August. The following dates are defined as holidays: January 1 July 4 November 11 December 24 December 25 Hints What boolean expression would check if a day is a holiday? How would you check the current day of the week using mathematical operators? How would you convert the current day of the week to a number? Input Format The input will consist of three tokens, each separated with a whitespace. The first two represent the current date, while the third represents the day of the week the first day of the month is on . The first token is a string that is a month of the year ( January , February , etc.). The next token is an integer representing the date. The last token is a string that is a day of the week ( Sunday , Monday , etc.) An example input (for March 2017) is: March 25 Wednesday Output Format The output will consist of the input date, followed by the phrase is a school day . if it is a school day or is not a school day . if it is not. An example output for the example input is: March 25 is not a school day . Input/Output Examples Sample 1 December 25 Friday December 25 is not a school day . Sample 2 July 2 Monday July 2 is not a school day . Sample 3 April 26 Saturday April 26 is a school day .","title":"A School Day"},{"location":"develop/java/schoolday/#a-school-day","text":"","title":"A School Day"},{"location":"develop/java/schoolday/#objectives","text":"Learn to use basic Java input/output Learn to declare and assign values to variables Demonstrate appropriate usage of variable identifiers Apply your knowledge of operators to solve a problem Use boolean expression appropriately Learn to use simple conditional statements","title":"Objectives"},{"location":"develop/java/schoolday/#task","text":"You seem to have lost your calendar for this year and can only remember the days of the week that each month starts with. Write a program that determines if a particular date is a school day. There is school from Monday to Friday (inclusive), except on holidays and in July and August. The following dates are defined as holidays: January 1 July 4 November 11 December 24 December 25 Hints What boolean expression would check if a day is a holiday? How would you check the current day of the week using mathematical operators? How would you convert the current day of the week to a number?","title":"Task"},{"location":"develop/java/schoolday/#input-format","text":"The input will consist of three tokens, each separated with a whitespace. The first two represent the current date, while the third represents the day of the week the first day of the month is on . The first token is a string that is a month of the year ( January , February , etc.). The next token is an integer representing the date. The last token is a string that is a day of the week ( Sunday , Monday , etc.) An example input (for March 2017) is: March 25 Wednesday","title":"Input Format"},{"location":"develop/java/schoolday/#output-format","text":"The output will consist of the input date, followed by the phrase is a school day . if it is a school day or is not a school day . if it is not. An example output for the example input is: March 25 is not a school day .","title":"Output Format"},{"location":"develop/java/schoolday/#inputoutput-examples","text":"Sample 1 December 25 Friday December 25 is not a school day . Sample 2 July 2 Monday July 2 is not a school day . Sample 3 April 26 Saturday April 26 is a school day .","title":"Input/Output Examples"},{"location":"develop/maintain/L1/","text":"Lesson 1 - Introduction to Java Raider Robotix and Java FRC Team 25, Raider Robotix , uses the Java programming language for programming both the robot and the scouting system. Java is also taught in NBTHS's computer science courses. These lessons will provide you with the building blocks of Java that are necessary to program, maintain, and understand the scouting system. It currently has two components: * Android scouting app - collects data from scouts during events and exports it in JSON (JavaScript Object Notation) files * Every year, this needs to be updated with the correct metrics, events, game manual, and other options, as necessary * Desktop scouting client - compiles the JSON files from the app and outputs spreadsheets of each scouting entry and aggregated statistics for each team * Every year, this needs to be updated with the correct metrics, which includes averages, percentages, probabilities, and standard deviations, in addition to those in the scouting app Starting from the 2017 season, Tableau is used to visualize and analyze the data from the spreadsheets generated by the client. The goal is to have you understand how the scouting system works and be comfortable with changing its code by next season's kickoff. If you want to work on robot programming instead, additional knowledge of WPILib API will be needed. Lesson Structure Generally, several concepts will be explained and grouped together to form a lesson. As each concept is taught, several practice exercises are given for you to check your understanding. At the end of the lesson, one or two problems will be assigned on HackerRank that test your understanding of all concepts in the lesson. The site allows you to check your program against several test cases and will \"grade\" it (pass or fail) instantly. Java Code Structure Java source files have a . java extension and each contain a class , which acts like an object (we'll get to this later). Each class/source file is located in a package , which acts as a folder to organize various files. Inside an executable program is a main method , in which the code inside it executes. In a desktop Java program, the method signature public static void main ( String [] args ) is used, followed by a set of curly braces. Below is an example inside a file called Example . java : // Place import statements here public class Example { public static void main ( String [] args ){ // Write your code to execute here } } As seen above line comments can be written if they are proceeded with two forward slashes ( // ). Anything following the two slashes will be ignored by the compiler when your program executes. Block comments may also be written like this: /* Hi! * I'm a block comment. */ Note the two slashes showing the beginning/end of the comment and the asterisk on each line. Variables Any data or value you use in Java is stored in a variable . A variable can have one of many different datatypes . The following are common datatypes: * int - an integer with a value between -2^31 - 1 and 2^31 -1 ( 123 , 25 , - 900 , 0 , etc.) * double - a positive or negative decimal number ( 1.23 , - 2.5 , 1.0005 , etc.) * boolean - has either a true or false value * String - a sequence of characters, enclosed in a set of quotation marks ( \"Hello World\" , \"1+1=2\" , \"Raider Robotix\" , etc.) You can declare variables with its datatype, followed by a space and its identifier , then a semicolon. The identifier must start with a letter or underscore, then be followed by more letters, underscores, or numbers, with no spaces. Valid identifiers include: * _t * motor1 * MOTOR_SPEED Generally, variables are named in a camelCase notation, where the first word is lowercase, then the remaining words are uppercase. Examples of variable declarations with camelCase naming include: int teleOpGearsCollected ; double avgKpaPerGame ; boolean baselineCrossed ; String robotComment , pilotComment ; //multiple variables can be declared with a comma separating them On the other hand, variables that are constant throughout a program should be named with only uppercase letters and underscores. Examples of these variables include: double TURN_ANGLE_TOLERANCE ; int LEFT_JOYSTICK_PORT ; String RULES_FILEPATH ; int VERSION_NUMBER ; Keep in mind that variables should not have generic identifiers like x or var1 , but ones that are descriptive. A variable can be assigned a value with its identifier followed by the assignment operator , = , and its value. This value can be literal or that of another variable. A variable may be assigned a value and declared at the same time as well. Some examples: int teleOpGearsCollected ; // declaration double avgHighGoalsTeleOp = 12.555 ; // variable declared and value of 12.555 assigned teleOpGearsCollected = 4 ; // assignment afterwards boolean baselineCrossed = true , readyTakeoff = false ; // two variables declared and assigned value String robotComment = \"This is a good robot\" ; double avgTeleOpKpa = avgHighGoalsTeleOp / 3 ; //value dependent on another variable Output Output to the console in Java can be executed with the following statement : System . out . println ( < some value > ); This calls the println method on a value, where < some value > can be a literal value or a variable. Remember to terminate the print statement with a semicolon. For example, executing System . out . println ( teleOpGearsCollected ); System . out . println ( \"gears collected in tele-op in match\" ); System . out . println ( 25 ); will result in the following output: 4 gears collected in tele - op in match 25 If you don't want a new line after the output, the System . out . print ( < some value > ) method may be used. Executing System . out . print ( teleOpGearsCollected ); System . out . println ( \" gears collected in tele-op.\" ); System . out . println ( \"Robots are cool\" ); will result in the following output: 4 gears collected in tele - op . Robots are cool An IDE An IDE (Integrated Development Environment) will be used to program in Java. It allows you to write code, execute, and debug it in one application. I recommend using Eclipse , as NBTHS and the WPILib API uses it, though alternatives like InteliJ and BlueJ exist. We will be using Android Studio as our IDE for Android development. To get started with Eclipse: 1. Download and extract the ZIP file from the link above 2. Run the executable and choose your workspace (default should work) 3. Go to File > New > Java Project and name your project 4. Close the Welcome window 5. Right click your project and go to New > Class, and name your class (without the . java extension) 6. Write your main method (see above) 7. Try replacing the comment with a statement to print Hello World 8. Press the green \"Play\" button to execute your program If there are any syntax errors in your program, Eclipse will underline them in red, and the program will not run. Try fixing them by reading the error message and reviewing your code or by using Google. A Brief Exercise : Assign the values of true , \"Raider Robotix\" , and 25 to variables. Use print statements with the variables and literal values to generate the output Hello World ! It is true that I am on Team 25 , Raider Robotix 25 is the Team Number . Input To take user input, you will need to use a Scanner object. First, you will need to import the class by placing the following import statement before the class starts (see example above): import java.util.Scanner ; The Scanner object can be declared and constructed like this to read from the system console: Scanner myScanner = new Scanner ( System . in ); The datatype is Scanner , and myScanner can be any valid identifier. Note the use of the new keyword to create a new object and the parentheses following. Several methods can be accessed through the Scanner object for different datatypes. A method essentially acts like a function and returns a value to the main program. These may be used to let users assign values to variables: int anInteger = myScanner . nextInt (); String aLine = myScanner . next (); // takes the next whole line Essentially, the dot operator ( . ) shows that the methods nextInt () and nextLine () are written in the Scanner class, and you are accessing them from an outside class. More methods for input can be found by reading the documentation for the class . If the wrong datatype is used, there will be an error in your program. By default, spaces and line breaks separating tokens in the input will result two different variables. For example, if the input is Raider Robotix executing String teamName = myScanner . next (); System . out . println ( teamName ); will output Raider while executing String teamName = myScanner . nextLine (); System . out . println ( teamName ); will output Raider Robotix Exercise Write a program that allows prompts a user to input a string, an integer, and a floating point number, then print all three once they are inputted. Operators Operators in Java allow you to interact between different datatypes. For these examples, we will declare int a = 5 , b = 4 ; double c = 2.5 ; String s = \"Hello\" ; Mathematical Evaluating these operators will result in a number of type int if both are integers, or of type double if at least one is a double : + - adds the number (an int or double ) to the left and right of it a + b is equal to 9 , a + c is equal to 7.5 - - subtracts the number on the right from the left b - a is equal to - 1 , b - c is equal to 1.5 * - multiplies the number to the left and right of it a * b is equal to 20 , b * c is equal to 10.0 / - divides the number on the left by the number on the right. However, if both numbers are int s, integer division will occur. That is, the remainder is discarded, and only the quotient remains. a / c is equal to 2.0 , b / c is equal to 1.6 a / b is equal to 1 , b / a is equal to 0 A literal int value ( 1 ) may be converted into a double value by adding a decimal point and a zero ( 1.0 ) % - the modulus operator, a % b returns the remainder of a / b a % b is equal to 1 , b % a is equal to 4 , a % c is equal to 0.0 Exercises : * Write a program that allows the user to input (integer) dimensions of a rectangular prism and outputs its surface area and volume * Write a program that prints the day of the week of a day, given the day of the week of the first day of the month (where 1=Monday, 7=Sunday) * Write a program that calculates the score of a match in FIRST Steamworks, where the user inputs the number of rotors activated during tele-op/autonomous, high/low goals in tele-op/autonomous, the times the baseline was crossed, the times robots took off, and foul points that were incurred by the opposing alliance Relational Evaluating these operators will result in a boolean value ( true or false ): < - less than, <= - less than or equal to b < a is true , 4.5 < 0 is false - 2 <= c is true , 5 <= 5 is true > - greater than, >= - greater than or equal to == - checks for equality. This can only be used for primitive datatypes, and not objects a == 5 is true , 2.0 == a / c is true false == true is false For strings, the method someString . equals ( /*another string*/ ) is used for equality because a string is an object. We'll get into this more in the next lesson. s . equals ( \"Hello\" ) is true , s . equals ( \"World\" ) is false != - checks if the two objects are not equal a != 5 is false , 1 != a / c is true false != true is true Exercise : Write a program to determine if it is true that a quadratic equation of the form 0=ax^2+bx+c has a real solution, where the user inputs a, b, and c. (Hint: For now the best way to square an integer x is x * x , as x ^ 2 will not evaluate correctly) Logical These operate on boolean values and evaluating them will also result in a boolean value: OR Operator - written as a || b , evaluates to true only if either a or b are true a b a \\ | \\ | b false false false false true true true false true true true true AND Operator - written as a && b , evaluates to true only if both a and b are true a b a && b false false false false true false true false false true true true NOT Operator - written as !a , evaluates to true only if a is false a !a false true true false Exercises * Evaluate the following expressions (without actually writing any code) for when boolean a = true , b = false and for when boolean a = true , b = true : * ( a || b ) && ( ! a || ! b ) * ! ( a && ! b ) || ( ! a && b ) * ! ( a && b ) Some Shortcuts You already learned about the assignment operator. Here are some shortcuts used for assignment with operators, if x and y are numbers and both are already declared and assigned values: x += y ; // same as x = x+y x -= y ; // same as x = x-y x /= y ; // same as x = x/y x %= y ; // same as x = x % y x ++ ; // same as x+=1 x -- ; // same as x-=1 Exercise : What is the value of x after the following is executed? int x = 60 , y = 10 ; y /= 5 ; x %= x - y ; x ++ ; x *= 4 ; Boolean Expressions A boolean expression is any expression that evaluates to true or false . It may contain literals, variables, and any of the above operators. The order of operations for evaluation are: Parentheses NOT Multiplication, division, modulus Addition, subtraction Greater/less than (or equal to) Equivalence/not equivalent AND OR The following are valid boolean expressions if x and y are numbers and b is a boolean : * x >= 5 + y && ! ( y + 5 == 7 || y < 0 || ! b ) * takeoffPercentage / avgTakeoffPercentage + 0.1 >= 1.2 && ( avgKpa >= 30 || avgGears >= 4 ) && teamNum != 25 && ! droppedGearOften Exercises * The XOR (exclusive-or) operator evaluates to be true if either A or B are true, but not both. Write an expression that is logically equivalent to \"A XOR B\" using the AND, OR, and NOT operators * Write a boolean expression to determine if at least 3 ranking points were earned by the red alliance in a match of FIRST Steamworks, given the scores of both the red and blue alliances, the number of gears delivered by the red alliance, whether or not the reserve gear was used, and the number of high/low goals into the red boiler in autonomous/tele-op. Use appropriate identifiers for variables and declare multiple, intermediate boolean expressions as necessary. Conditionals A conditional statement is one that executes if a particular boolean expression is true. The if , else , and else - if statements are written and used as follows: boolean a = < some expression > ; if ( a ){ //Code here executes if expression a is true } else if ( < some boolean expression b > ){ // Code here executes if expression b is true and a is false } else { // Code here executes if a and b are both false } Note that an if statement may be written without any else statements, but else and else - if statements must follow an if statement or an else statement. The boolean expression may also be placed inside the parentheses, rather than assigning its value to a boolean variable. These conditional statements may also be nested inside each other as follows: boolean a = < some expression > ; boolean b = < some expression > ; boolean c = < some expression > ; if ( a ){ if ( c ){ // Code here executes if a and c are true } else { //Code here executes if a is true and c is false } // Code here executes as long as a is true, no matter what the value of c is } else if ( b ){ // Code here executes if expression b is true and a is false, no matter what the value of c is if ( ! c ){ //Code here executes if a is false, b is true, and c is false } } else { // Code here executes if a and b are both false } Exercises * Write a program to determine if a number is even or odd * Write a program that prints the month, given its numerical value (1 to 12) * Write a program that converts a day of the week to a number (Monday = 1, Sunday = 7) * Write a program that converts feet to yards and vice-versa, depending on what the user wants Assignment Download Eclipse and complete the exercises above as necessary to check your understanding. Afterwards, sign up for a HackerRank account and complete the \"A School Day\" program here . I suggest that you write and test the program on Eclipse, then check if it works on HackerRank.","title":"Lesson 1: The Scouting App"},{"location":"develop/maintain/L1/#lesson-1-introduction-to-java","text":"","title":"Lesson 1 - Introduction to Java"},{"location":"develop/maintain/L1/#raider-robotix-and-java","text":"FRC Team 25, Raider Robotix , uses the Java programming language for programming both the robot and the scouting system. Java is also taught in NBTHS's computer science courses. These lessons will provide you with the building blocks of Java that are necessary to program, maintain, and understand the scouting system. It currently has two components: * Android scouting app - collects data from scouts during events and exports it in JSON (JavaScript Object Notation) files * Every year, this needs to be updated with the correct metrics, events, game manual, and other options, as necessary * Desktop scouting client - compiles the JSON files from the app and outputs spreadsheets of each scouting entry and aggregated statistics for each team * Every year, this needs to be updated with the correct metrics, which includes averages, percentages, probabilities, and standard deviations, in addition to those in the scouting app Starting from the 2017 season, Tableau is used to visualize and analyze the data from the spreadsheets generated by the client. The goal is to have you understand how the scouting system works and be comfortable with changing its code by next season's kickoff. If you want to work on robot programming instead, additional knowledge of WPILib API will be needed.","title":"Raider Robotix and Java"},{"location":"develop/maintain/L1/#lesson-structure","text":"Generally, several concepts will be explained and grouped together to form a lesson. As each concept is taught, several practice exercises are given for you to check your understanding. At the end of the lesson, one or two problems will be assigned on HackerRank that test your understanding of all concepts in the lesson. The site allows you to check your program against several test cases and will \"grade\" it (pass or fail) instantly.","title":"Lesson Structure"},{"location":"develop/maintain/L1/#java-code-structure","text":"Java source files have a . java extension and each contain a class , which acts like an object (we'll get to this later). Each class/source file is located in a package , which acts as a folder to organize various files. Inside an executable program is a main method , in which the code inside it executes. In a desktop Java program, the method signature public static void main ( String [] args ) is used, followed by a set of curly braces. Below is an example inside a file called Example . java : // Place import statements here public class Example { public static void main ( String [] args ){ // Write your code to execute here } } As seen above line comments can be written if they are proceeded with two forward slashes ( // ). Anything following the two slashes will be ignored by the compiler when your program executes. Block comments may also be written like this: /* Hi! * I'm a block comment. */ Note the two slashes showing the beginning/end of the comment and the asterisk on each line.","title":"Java Code Structure"},{"location":"develop/maintain/L1/#variables","text":"Any data or value you use in Java is stored in a variable . A variable can have one of many different datatypes . The following are common datatypes: * int - an integer with a value between -2^31 - 1 and 2^31 -1 ( 123 , 25 , - 900 , 0 , etc.) * double - a positive or negative decimal number ( 1.23 , - 2.5 , 1.0005 , etc.) * boolean - has either a true or false value * String - a sequence of characters, enclosed in a set of quotation marks ( \"Hello World\" , \"1+1=2\" , \"Raider Robotix\" , etc.) You can declare variables with its datatype, followed by a space and its identifier , then a semicolon. The identifier must start with a letter or underscore, then be followed by more letters, underscores, or numbers, with no spaces. Valid identifiers include: * _t * motor1 * MOTOR_SPEED Generally, variables are named in a camelCase notation, where the first word is lowercase, then the remaining words are uppercase. Examples of variable declarations with camelCase naming include: int teleOpGearsCollected ; double avgKpaPerGame ; boolean baselineCrossed ; String robotComment , pilotComment ; //multiple variables can be declared with a comma separating them On the other hand, variables that are constant throughout a program should be named with only uppercase letters and underscores. Examples of these variables include: double TURN_ANGLE_TOLERANCE ; int LEFT_JOYSTICK_PORT ; String RULES_FILEPATH ; int VERSION_NUMBER ; Keep in mind that variables should not have generic identifiers like x or var1 , but ones that are descriptive. A variable can be assigned a value with its identifier followed by the assignment operator , = , and its value. This value can be literal or that of another variable. A variable may be assigned a value and declared at the same time as well. Some examples: int teleOpGearsCollected ; // declaration double avgHighGoalsTeleOp = 12.555 ; // variable declared and value of 12.555 assigned teleOpGearsCollected = 4 ; // assignment afterwards boolean baselineCrossed = true , readyTakeoff = false ; // two variables declared and assigned value String robotComment = \"This is a good robot\" ; double avgTeleOpKpa = avgHighGoalsTeleOp / 3 ; //value dependent on another variable","title":"Variables"},{"location":"develop/maintain/L1/#output","text":"Output to the console in Java can be executed with the following statement : System . out . println ( < some value > ); This calls the println method on a value, where < some value > can be a literal value or a variable. Remember to terminate the print statement with a semicolon. For example, executing System . out . println ( teleOpGearsCollected ); System . out . println ( \"gears collected in tele-op in match\" ); System . out . println ( 25 ); will result in the following output: 4 gears collected in tele - op in match 25 If you don't want a new line after the output, the System . out . print ( < some value > ) method may be used. Executing System . out . print ( teleOpGearsCollected ); System . out . println ( \" gears collected in tele-op.\" ); System . out . println ( \"Robots are cool\" ); will result in the following output: 4 gears collected in tele - op . Robots are cool","title":"Output"},{"location":"develop/maintain/L1/#an-ide","text":"An IDE (Integrated Development Environment) will be used to program in Java. It allows you to write code, execute, and debug it in one application. I recommend using Eclipse , as NBTHS and the WPILib API uses it, though alternatives like InteliJ and BlueJ exist. We will be using Android Studio as our IDE for Android development. To get started with Eclipse: 1. Download and extract the ZIP file from the link above 2. Run the executable and choose your workspace (default should work) 3. Go to File > New > Java Project and name your project 4. Close the Welcome window 5. Right click your project and go to New > Class, and name your class (without the . java extension) 6. Write your main method (see above) 7. Try replacing the comment with a statement to print Hello World 8. Press the green \"Play\" button to execute your program If there are any syntax errors in your program, Eclipse will underline them in red, and the program will not run. Try fixing them by reading the error message and reviewing your code or by using Google. A Brief Exercise : Assign the values of true , \"Raider Robotix\" , and 25 to variables. Use print statements with the variables and literal values to generate the output Hello World ! It is true that I am on Team 25 , Raider Robotix 25 is the Team Number .","title":"An IDE"},{"location":"develop/maintain/L1/#input","text":"To take user input, you will need to use a Scanner object. First, you will need to import the class by placing the following import statement before the class starts (see example above): import java.util.Scanner ; The Scanner object can be declared and constructed like this to read from the system console: Scanner myScanner = new Scanner ( System . in ); The datatype is Scanner , and myScanner can be any valid identifier. Note the use of the new keyword to create a new object and the parentheses following. Several methods can be accessed through the Scanner object for different datatypes. A method essentially acts like a function and returns a value to the main program. These may be used to let users assign values to variables: int anInteger = myScanner . nextInt (); String aLine = myScanner . next (); // takes the next whole line Essentially, the dot operator ( . ) shows that the methods nextInt () and nextLine () are written in the Scanner class, and you are accessing them from an outside class. More methods for input can be found by reading the documentation for the class . If the wrong datatype is used, there will be an error in your program. By default, spaces and line breaks separating tokens in the input will result two different variables. For example, if the input is Raider Robotix executing String teamName = myScanner . next (); System . out . println ( teamName ); will output Raider while executing String teamName = myScanner . nextLine (); System . out . println ( teamName ); will output Raider Robotix Exercise Write a program that allows prompts a user to input a string, an integer, and a floating point number, then print all three once they are inputted.","title":"Input"},{"location":"develop/maintain/L1/#operators","text":"Operators in Java allow you to interact between different datatypes. For these examples, we will declare int a = 5 , b = 4 ; double c = 2.5 ; String s = \"Hello\" ;","title":"Operators"},{"location":"develop/maintain/L1/#mathematical","text":"Evaluating these operators will result in a number of type int if both are integers, or of type double if at least one is a double : + - adds the number (an int or double ) to the left and right of it a + b is equal to 9 , a + c is equal to 7.5 - - subtracts the number on the right from the left b - a is equal to - 1 , b - c is equal to 1.5 * - multiplies the number to the left and right of it a * b is equal to 20 , b * c is equal to 10.0 / - divides the number on the left by the number on the right. However, if both numbers are int s, integer division will occur. That is, the remainder is discarded, and only the quotient remains. a / c is equal to 2.0 , b / c is equal to 1.6 a / b is equal to 1 , b / a is equal to 0 A literal int value ( 1 ) may be converted into a double value by adding a decimal point and a zero ( 1.0 ) % - the modulus operator, a % b returns the remainder of a / b a % b is equal to 1 , b % a is equal to 4 , a % c is equal to 0.0 Exercises : * Write a program that allows the user to input (integer) dimensions of a rectangular prism and outputs its surface area and volume * Write a program that prints the day of the week of a day, given the day of the week of the first day of the month (where 1=Monday, 7=Sunday) * Write a program that calculates the score of a match in FIRST Steamworks, where the user inputs the number of rotors activated during tele-op/autonomous, high/low goals in tele-op/autonomous, the times the baseline was crossed, the times robots took off, and foul points that were incurred by the opposing alliance","title":"Mathematical"},{"location":"develop/maintain/L1/#relational","text":"Evaluating these operators will result in a boolean value ( true or false ): < - less than, <= - less than or equal to b < a is true , 4.5 < 0 is false - 2 <= c is true , 5 <= 5 is true > - greater than, >= - greater than or equal to == - checks for equality. This can only be used for primitive datatypes, and not objects a == 5 is true , 2.0 == a / c is true false == true is false For strings, the method someString . equals ( /*another string*/ ) is used for equality because a string is an object. We'll get into this more in the next lesson. s . equals ( \"Hello\" ) is true , s . equals ( \"World\" ) is false != - checks if the two objects are not equal a != 5 is false , 1 != a / c is true false != true is true Exercise : Write a program to determine if it is true that a quadratic equation of the form 0=ax^2+bx+c has a real solution, where the user inputs a, b, and c. (Hint: For now the best way to square an integer x is x * x , as x ^ 2 will not evaluate correctly)","title":"Relational"},{"location":"develop/maintain/L1/#logical","text":"These operate on boolean values and evaluating them will also result in a boolean value: OR Operator - written as a || b , evaluates to true only if either a or b are true a b a \\ | \\ | b false false false false true true true false true true true true AND Operator - written as a && b , evaluates to true only if both a and b are true a b a && b false false false false true false true false false true true true NOT Operator - written as !a , evaluates to true only if a is false a !a false true true false Exercises * Evaluate the following expressions (without actually writing any code) for when boolean a = true , b = false and for when boolean a = true , b = true : * ( a || b ) && ( ! a || ! b ) * ! ( a && ! b ) || ( ! a && b ) * ! ( a && b )","title":"Logical"},{"location":"develop/maintain/L1/#some-shortcuts","text":"You already learned about the assignment operator. Here are some shortcuts used for assignment with operators, if x and y are numbers and both are already declared and assigned values: x += y ; // same as x = x+y x -= y ; // same as x = x-y x /= y ; // same as x = x/y x %= y ; // same as x = x % y x ++ ; // same as x+=1 x -- ; // same as x-=1 Exercise : What is the value of x after the following is executed? int x = 60 , y = 10 ; y /= 5 ; x %= x - y ; x ++ ; x *= 4 ;","title":"Some Shortcuts"},{"location":"develop/maintain/L1/#boolean-expressions","text":"A boolean expression is any expression that evaluates to true or false . It may contain literals, variables, and any of the above operators. The order of operations for evaluation are: Parentheses NOT Multiplication, division, modulus Addition, subtraction Greater/less than (or equal to) Equivalence/not equivalent AND OR The following are valid boolean expressions if x and y are numbers and b is a boolean : * x >= 5 + y && ! ( y + 5 == 7 || y < 0 || ! b ) * takeoffPercentage / avgTakeoffPercentage + 0.1 >= 1.2 && ( avgKpa >= 30 || avgGears >= 4 ) && teamNum != 25 && ! droppedGearOften Exercises * The XOR (exclusive-or) operator evaluates to be true if either A or B are true, but not both. Write an expression that is logically equivalent to \"A XOR B\" using the AND, OR, and NOT operators * Write a boolean expression to determine if at least 3 ranking points were earned by the red alliance in a match of FIRST Steamworks, given the scores of both the red and blue alliances, the number of gears delivered by the red alliance, whether or not the reserve gear was used, and the number of high/low goals into the red boiler in autonomous/tele-op. Use appropriate identifiers for variables and declare multiple, intermediate boolean expressions as necessary.","title":"Boolean Expressions"},{"location":"develop/maintain/L1/#conditionals","text":"A conditional statement is one that executes if a particular boolean expression is true. The if , else , and else - if statements are written and used as follows: boolean a = < some expression > ; if ( a ){ //Code here executes if expression a is true } else if ( < some boolean expression b > ){ // Code here executes if expression b is true and a is false } else { // Code here executes if a and b are both false } Note that an if statement may be written without any else statements, but else and else - if statements must follow an if statement or an else statement. The boolean expression may also be placed inside the parentheses, rather than assigning its value to a boolean variable. These conditional statements may also be nested inside each other as follows: boolean a = < some expression > ; boolean b = < some expression > ; boolean c = < some expression > ; if ( a ){ if ( c ){ // Code here executes if a and c are true } else { //Code here executes if a is true and c is false } // Code here executes as long as a is true, no matter what the value of c is } else if ( b ){ // Code here executes if expression b is true and a is false, no matter what the value of c is if ( ! c ){ //Code here executes if a is false, b is true, and c is false } } else { // Code here executes if a and b are both false } Exercises * Write a program to determine if a number is even or odd * Write a program that prints the month, given its numerical value (1 to 12) * Write a program that converts a day of the week to a number (Monday = 1, Sunday = 7) * Write a program that converts feet to yards and vice-versa, depending on what the user wants","title":"Conditionals"},{"location":"develop/maintain/L1/#assignment","text":"Download Eclipse and complete the exercises above as necessary to check your understanding. Afterwards, sign up for a HackerRank account and complete the \"A School Day\" program here . I suggest that you write and test the program on Eclipse, then check if it works on HackerRank.","title":"Assignment"},{"location":"develop/maintain/L2/","text":"Lesson 2 - Loops, Strings, Math After a (probably pretty long) first lesson, let's explore a couple more features of Java and see what you can do with everything that you learned. Loops Loops are used to execute a block of code enclosed in a set of braces ( {} ) multiple times. After all, computers are very good at doing the same thing over and over again! The number of times a block executes depends on a boolean expression. while Loops while loops execute as long as a boolean expression is true . It may not execute at all if the expression is false before entering the loop. while ( /*some boolean expression*/ ){ //Execute code here multiple times as long as the expression is true } Remember that the boolean expression should become false at some point during the execution of the code in the loop. Otherwise, an infinite loop will be created. For example, the following will print the numbers from 1 to 10 (inclusive): int counter = 1 ; while ( counter <= 10 ){ System . out . println ( counter ); counter ++ ; } do - while loops may also be written. The main difference between these and while loops is that the boolean expression must be true at the end of the loop, not at the beginning. The following prints the numbers from 1 to 10 (inclusive): int counter = - 1 ; do { counter ++ ; System . out . println ( counter ); } while ( counter < 10 ); for Loops for loops provide a more controlled way for iterating through a loop multiple times. There are three components to the for loop: the initial statement, the exit condition (boolean expression), and the post-excution statement. The example for ( /*initial statement*/ ; /*exit condition*/ ; /*post-execution statement*/ ){ //Code to be executed each loop } is essentially equal to the following while loop: //Initial statement while ( /*exit condition*/ ){ //Code to be executed each loop //Post-execution statement } The for loop is commonly used to execute a loop a certain number of times. Below, the loop prints the numbers from 0 to 9 (10 iterations): for ( int count = 0 ; i < 10 ; count ++ ){ System . out . println ( count ); } Keep in mind that the variable count is declared within the loop, and it cannot accessed outside it. Loops may also be placed inside each other. For example, executing for ( int row = 1 ; row <= 12 ; row ++ ){ for ( int col = 1 ; col <= 12 ; col ++ ){ System . out . print ( row * col ); System . out . print ( \" \" ); //adds a space } System . out . println (); //line break } will print a (poorly formatted) times table. Note that all three parts of a for loop are optional. That is, a loop like for (;;) { //something } will execute forever. Questions Determine the number of times the following for loops will execute. for ( int i = 4 ; i <= 8 ; i += 2 ) { /*do something*/ } for ( int i = 10 ; i >= 0 ; i -= 3 ) { /*do something*/ } for ( int j = 2 ; j >= 4 ; j ++ ) { /*do something*/ } Exercises Write a program that computes the sum of all odd integers from 1 to a number specified by the user Write a program that computes b^e (a number raised to the power of an exponent), where b and e are positive integers Write a program that allows the user to enter a number, setSize . setSize numbers, num , follow and are inputted by the user. Print the average, largest, and smallest of the numbers. Loop Control There are two control statements that are used with loops: break The break statement will immediately exit a while or for loop. This can be useful if you're looking for a specific value, and you want the loop to end after you've found that value. For instance, in the below example, the loop will terminate immediately after the value key is found: int key = 8 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( i == key ) { System . out . println ( \"Found\" ); break ; } System . out . println ( \"Not found...\" ); } As a result, Not found ... will be printed out eight times at first, followed by Found . The loop will then terminate. The break statement will be more useful after you learn about arrays. continue The continue statement will immediately go to the next iteration of a for or while loop, bypassing all statements after it. This could be used when you only want to execute a loop for some values. Of course, an if - else statement can often accomplish the same thing, but break and continue statements can prevent too many nested blocks of code. For instance, the following block of code for ( int i = 0 ; i < 4 ; i ++ ) { System . out . println ( \"Going... \" + i ); if ( i >= 2 ) { continue ; } System . out . println ( \"Here\" ); } will print Going ... 0 Here Going ... 1 Here Going ... 2 Going ... 3 Characters In addition to the primitive data types ( boolean , int , double ) we learned about before, char s represent one of the 256 ASCII characters . These include the numbers, standard symbols and punctuation on a keyboard, and both uppercase and lowercase letters. A char is assigned a value with the declaration char allianceColor = 'R' ; Note the use of single quotation marks rather than double quotation marks (which are used for String s) and that a variable of type char may only contain a single character. Escape characters are the first 32 ASCII characters, which serve special functions. The most commonly used is '\\n' , which creates a line break. In addition, quotation marks must be escaped. Thus, executing the following code char quote1 = '\\'' ; char quote2 = '\\\"' ; char newLine = '\\n' System . out . print ( quote1 ); System . out . print ( newLine ); System . out . print ( quote2 ); will print ' \" Note that strings can be thought of as a series of char s concatenated together. For instance, executing String someText = \"Kickoff, 2017 \\n As we anticipated the new game, the livestream blared, \\\" STEAM POWERED! STEAM POWERED! STEAM POWERED! \\\" \" ; System . out . println ( someText ); will print Kickoff , 2017 As we anticipated the new game , the livestream blared , \"STEAM POWERED! STEAM POWERED! STEAM POWERED!\" The value of characters may be compared with the equivalence ( == ) operator. For example, allianceColor == 'R' is true . Note, however, that a character is not equal its int equivalent. That is, '1' == 1 is false . String Manipulation The String class in Java contains many methods to manipulate strings. We will present an overview of the most useful ones, though you may read the full documentation here . Concatenation A string can be concatenated , or joined together, with other strings or primitive datatypes (and literals) with the + operator. For example, executing the following: String mascot = \"Raider\" ; int teamNum = 25 ; String teamName = mascot + \" Robotix\" ; System . out . println ( \"The year is \" + 2017 ); System . out . println ( \"I am on Team \" + teamNum + \", \" + teamName ); will print The year is 2017 I am on Team 25 , Raider Robotix You may also concatenate a string onto the end of another with the += operator. Executing String s = \"Hello\" ; s += \" World!\" ; System . out . println ( s ); will print Hello World ! . String Properties You can check the length of a string (number of characters) with the string . length () method. Executing String s = \"Hello\" ; System . out . println ( s + \" is \" + s . length () + \" characters long\" ); System . out . print ( \"World!\" . length ()); will print Hello is 5 characters long 6 You can also check if a string contains a specific character sequence with the string . contains ( < character sequence > ) method, which returns a boolean value. If String s = \"Hello\" ; is declared, s . contains ( \"ell\" ) returns true , while s . contains ( \"f\" ) returns false . Parsing a String You may want to parse through a string sometimes, or check the sequence of its characters. The string . charAt ( /*index*/ ) method will return the character currently at the index. There are two things you should know about the method: The method will return a value of type char (character), rather than String . The index is a value that is greater than or equal to 0 and less than string . length () . That is, the index of the first character in the string is 0 , and the index of the last character in the string is string . length () - 1 . If String s = \"World\" ; is declared, s . charAt ( 0 ) returns 'W' , s . charAt ( 3 ) returns 'l' , and s . charAt ( 4 ) returns 'd' . A standard way to parse through all of the characters of a string is with the following for loop: String str = \"Hello World!\" ; for ( int i = 0 ; i < str . length (); i ++ ){ char currentChar = str . charAt ( i ); //Do something here } Substrings Suppose you want to return a slice of a string, known as a substring, such as the first letter four letters of String s = \"Raider Robotix\" ; . An easy-to-understand way would be to use string parsing, similar to what we did above: String s = \"Raider Robotix\" ; String result = \"\" ; // an empty string for ( int i = 0 ; i < 4 && i < s . length (); i ++ ){ result += s . charAt ( i ); } System . out . println ( result ); This would print out Raid . Note that the expression i < s . length () was still present in the exit condition in order to prevent errors if s was an input string that was less than four characters long. However, a faster way to get result would be to use the substring ( beginIndex , endIndex ) method, in which beginIndex and endIndex are integers that represent the indicies that you want to search. Similar to the for loop above, beginIndex is inclusive, while endIndex is exclusive. Here are some examples: s . substring ( 0 , 4 ); returns Raid s . substring ( 7 , s . length ()); returns Robotix \"hamburger\" . substring ( 4 , 8 ); returns urge Miscellaneous String Functions Assume that String s = \"Hello\" ; is declared in the following examples: s . toLowerCase (); returns hello s . toUpperCase (); returns HELLO s . indexOf ( \"l\" ); returns 2 (the first occurence of l in s ), while s . lastIndexOf ( \"l\" ) returns 3 s . concat ( \"world\" ); returns Helloworld As mentioned before, string equality is checked with s . equals ( \"Hello\" ); , which would return true . On the other hand, after declaring String anotherString = \"Hello\" ; , the boolean expression s == anotherString || s == \"Hello\" would be false , as string are objects , not primitives . Exercises * Write a program to reverse a string if it has an R in it. * Write a program to check if a string is a palindrome (reads the same backward as forward, such as racecar) * Write a program to replaces all commas from a string with semicolons The Math Class The Math class contains several methods that you may find helpful. It is imported by default, and documentation is found here . For these examples, we will declare double a = 4.5 , b = - 2.5 ; Math . abs ( b ) : takes the absolute value of a number, returns 2.5 in the example Math . ceil ( a ) : takes the ceiling of a number (rounds it up if it is a decimal), returns 5 in the example Math . floor ( a ) : takes the floor of a number (rounds it down if it is a decimal), returns 4 in the example Math . pow ( a - 0.5 , - b + 0.5 ) : takes the first number to the power of the second number, returns 125.0 in the example Math . sqrt ( a - 0.5 ) : takes the square root of a number, returns 2.0 in this example Math . PI : returns the value of pi (3.141592653589793) Math . random () : returns a random double in the interval [0.0, 1.0). This can be used to generate a random integer within a particular range by clamping the number down, then casting it to an int . For example, if you want a random integer in the interval [ lower , upper ], you would declare int randInt = ( int ) ( Math . random () * ( upper - lower )) + lower ; . Try it out! Exercises * Write a program that solves quadratic equations of the form 0=ax^2+bx+c for x, where a, b, and c are coefficients given by the user * Write a program that calculates the average of a data set, given the numbers in the set and its length * Write a program to find the surface area and volume of a square pyramid, given its side length and height * Write a program to round a number to a specific number of decimal places Assignment Complete the \"Raider Robotix Printer\" and \"Binary Converter\" programs on HackerRank.","title":"Lesson 2: The Scouting Client"},{"location":"develop/maintain/L2/#lesson-2-loops-strings-math","text":"After a (probably pretty long) first lesson, let's explore a couple more features of Java and see what you can do with everything that you learned.","title":"Lesson 2 - Loops, Strings, Math"},{"location":"develop/maintain/L2/#loops","text":"Loops are used to execute a block of code enclosed in a set of braces ( {} ) multiple times. After all, computers are very good at doing the same thing over and over again! The number of times a block executes depends on a boolean expression.","title":"Loops"},{"location":"develop/maintain/L2/#while-loops","text":"while loops execute as long as a boolean expression is true . It may not execute at all if the expression is false before entering the loop. while ( /*some boolean expression*/ ){ //Execute code here multiple times as long as the expression is true } Remember that the boolean expression should become false at some point during the execution of the code in the loop. Otherwise, an infinite loop will be created. For example, the following will print the numbers from 1 to 10 (inclusive): int counter = 1 ; while ( counter <= 10 ){ System . out . println ( counter ); counter ++ ; } do - while loops may also be written. The main difference between these and while loops is that the boolean expression must be true at the end of the loop, not at the beginning. The following prints the numbers from 1 to 10 (inclusive): int counter = - 1 ; do { counter ++ ; System . out . println ( counter ); } while ( counter < 10 );","title":"while Loops"},{"location":"develop/maintain/L2/#for-loops","text":"for loops provide a more controlled way for iterating through a loop multiple times. There are three components to the for loop: the initial statement, the exit condition (boolean expression), and the post-excution statement. The example for ( /*initial statement*/ ; /*exit condition*/ ; /*post-execution statement*/ ){ //Code to be executed each loop } is essentially equal to the following while loop: //Initial statement while ( /*exit condition*/ ){ //Code to be executed each loop //Post-execution statement } The for loop is commonly used to execute a loop a certain number of times. Below, the loop prints the numbers from 0 to 9 (10 iterations): for ( int count = 0 ; i < 10 ; count ++ ){ System . out . println ( count ); } Keep in mind that the variable count is declared within the loop, and it cannot accessed outside it. Loops may also be placed inside each other. For example, executing for ( int row = 1 ; row <= 12 ; row ++ ){ for ( int col = 1 ; col <= 12 ; col ++ ){ System . out . print ( row * col ); System . out . print ( \" \" ); //adds a space } System . out . println (); //line break } will print a (poorly formatted) times table. Note that all three parts of a for loop are optional. That is, a loop like for (;;) { //something } will execute forever. Questions Determine the number of times the following for loops will execute. for ( int i = 4 ; i <= 8 ; i += 2 ) { /*do something*/ } for ( int i = 10 ; i >= 0 ; i -= 3 ) { /*do something*/ } for ( int j = 2 ; j >= 4 ; j ++ ) { /*do something*/ } Exercises Write a program that computes the sum of all odd integers from 1 to a number specified by the user Write a program that computes b^e (a number raised to the power of an exponent), where b and e are positive integers Write a program that allows the user to enter a number, setSize . setSize numbers, num , follow and are inputted by the user. Print the average, largest, and smallest of the numbers.","title":"for Loops"},{"location":"develop/maintain/L2/#loop-control","text":"There are two control statements that are used with loops:","title":"Loop Control"},{"location":"develop/maintain/L2/#break","text":"The break statement will immediately exit a while or for loop. This can be useful if you're looking for a specific value, and you want the loop to end after you've found that value. For instance, in the below example, the loop will terminate immediately after the value key is found: int key = 8 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( i == key ) { System . out . println ( \"Found\" ); break ; } System . out . println ( \"Not found...\" ); } As a result, Not found ... will be printed out eight times at first, followed by Found . The loop will then terminate. The break statement will be more useful after you learn about arrays.","title":"break"},{"location":"develop/maintain/L2/#continue","text":"The continue statement will immediately go to the next iteration of a for or while loop, bypassing all statements after it. This could be used when you only want to execute a loop for some values. Of course, an if - else statement can often accomplish the same thing, but break and continue statements can prevent too many nested blocks of code. For instance, the following block of code for ( int i = 0 ; i < 4 ; i ++ ) { System . out . println ( \"Going... \" + i ); if ( i >= 2 ) { continue ; } System . out . println ( \"Here\" ); } will print Going ... 0 Here Going ... 1 Here Going ... 2 Going ... 3","title":"continue"},{"location":"develop/maintain/L2/#characters","text":"In addition to the primitive data types ( boolean , int , double ) we learned about before, char s represent one of the 256 ASCII characters . These include the numbers, standard symbols and punctuation on a keyboard, and both uppercase and lowercase letters. A char is assigned a value with the declaration char allianceColor = 'R' ; Note the use of single quotation marks rather than double quotation marks (which are used for String s) and that a variable of type char may only contain a single character. Escape characters are the first 32 ASCII characters, which serve special functions. The most commonly used is '\\n' , which creates a line break. In addition, quotation marks must be escaped. Thus, executing the following code char quote1 = '\\'' ; char quote2 = '\\\"' ; char newLine = '\\n' System . out . print ( quote1 ); System . out . print ( newLine ); System . out . print ( quote2 ); will print ' \" Note that strings can be thought of as a series of char s concatenated together. For instance, executing String someText = \"Kickoff, 2017 \\n As we anticipated the new game, the livestream blared, \\\" STEAM POWERED! STEAM POWERED! STEAM POWERED! \\\" \" ; System . out . println ( someText ); will print Kickoff , 2017 As we anticipated the new game , the livestream blared , \"STEAM POWERED! STEAM POWERED! STEAM POWERED!\" The value of characters may be compared with the equivalence ( == ) operator. For example, allianceColor == 'R' is true . Note, however, that a character is not equal its int equivalent. That is, '1' == 1 is false .","title":"Characters"},{"location":"develop/maintain/L2/#string-manipulation","text":"The String class in Java contains many methods to manipulate strings. We will present an overview of the most useful ones, though you may read the full documentation here .","title":"String Manipulation"},{"location":"develop/maintain/L2/#concatenation","text":"A string can be concatenated , or joined together, with other strings or primitive datatypes (and literals) with the + operator. For example, executing the following: String mascot = \"Raider\" ; int teamNum = 25 ; String teamName = mascot + \" Robotix\" ; System . out . println ( \"The year is \" + 2017 ); System . out . println ( \"I am on Team \" + teamNum + \", \" + teamName ); will print The year is 2017 I am on Team 25 , Raider Robotix You may also concatenate a string onto the end of another with the += operator. Executing String s = \"Hello\" ; s += \" World!\" ; System . out . println ( s ); will print Hello World ! .","title":"Concatenation"},{"location":"develop/maintain/L2/#string-properties","text":"You can check the length of a string (number of characters) with the string . length () method. Executing String s = \"Hello\" ; System . out . println ( s + \" is \" + s . length () + \" characters long\" ); System . out . print ( \"World!\" . length ()); will print Hello is 5 characters long 6 You can also check if a string contains a specific character sequence with the string . contains ( < character sequence > ) method, which returns a boolean value. If String s = \"Hello\" ; is declared, s . contains ( \"ell\" ) returns true , while s . contains ( \"f\" ) returns false .","title":"String Properties"},{"location":"develop/maintain/L2/#parsing-a-string","text":"You may want to parse through a string sometimes, or check the sequence of its characters. The string . charAt ( /*index*/ ) method will return the character currently at the index. There are two things you should know about the method: The method will return a value of type char (character), rather than String . The index is a value that is greater than or equal to 0 and less than string . length () . That is, the index of the first character in the string is 0 , and the index of the last character in the string is string . length () - 1 . If String s = \"World\" ; is declared, s . charAt ( 0 ) returns 'W' , s . charAt ( 3 ) returns 'l' , and s . charAt ( 4 ) returns 'd' . A standard way to parse through all of the characters of a string is with the following for loop: String str = \"Hello World!\" ; for ( int i = 0 ; i < str . length (); i ++ ){ char currentChar = str . charAt ( i ); //Do something here }","title":"Parsing a String"},{"location":"develop/maintain/L2/#substrings","text":"Suppose you want to return a slice of a string, known as a substring, such as the first letter four letters of String s = \"Raider Robotix\" ; . An easy-to-understand way would be to use string parsing, similar to what we did above: String s = \"Raider Robotix\" ; String result = \"\" ; // an empty string for ( int i = 0 ; i < 4 && i < s . length (); i ++ ){ result += s . charAt ( i ); } System . out . println ( result ); This would print out Raid . Note that the expression i < s . length () was still present in the exit condition in order to prevent errors if s was an input string that was less than four characters long. However, a faster way to get result would be to use the substring ( beginIndex , endIndex ) method, in which beginIndex and endIndex are integers that represent the indicies that you want to search. Similar to the for loop above, beginIndex is inclusive, while endIndex is exclusive. Here are some examples: s . substring ( 0 , 4 ); returns Raid s . substring ( 7 , s . length ()); returns Robotix \"hamburger\" . substring ( 4 , 8 ); returns urge","title":"Substrings"},{"location":"develop/maintain/L2/#miscellaneous-string-functions","text":"Assume that String s = \"Hello\" ; is declared in the following examples: s . toLowerCase (); returns hello s . toUpperCase (); returns HELLO s . indexOf ( \"l\" ); returns 2 (the first occurence of l in s ), while s . lastIndexOf ( \"l\" ) returns 3 s . concat ( \"world\" ); returns Helloworld As mentioned before, string equality is checked with s . equals ( \"Hello\" ); , which would return true . On the other hand, after declaring String anotherString = \"Hello\" ; , the boolean expression s == anotherString || s == \"Hello\" would be false , as string are objects , not primitives . Exercises * Write a program to reverse a string if it has an R in it. * Write a program to check if a string is a palindrome (reads the same backward as forward, such as racecar) * Write a program to replaces all commas from a string with semicolons","title":"Miscellaneous String Functions"},{"location":"develop/maintain/L2/#the-math-class","text":"The Math class contains several methods that you may find helpful. It is imported by default, and documentation is found here . For these examples, we will declare double a = 4.5 , b = - 2.5 ; Math . abs ( b ) : takes the absolute value of a number, returns 2.5 in the example Math . ceil ( a ) : takes the ceiling of a number (rounds it up if it is a decimal), returns 5 in the example Math . floor ( a ) : takes the floor of a number (rounds it down if it is a decimal), returns 4 in the example Math . pow ( a - 0.5 , - b + 0.5 ) : takes the first number to the power of the second number, returns 125.0 in the example Math . sqrt ( a - 0.5 ) : takes the square root of a number, returns 2.0 in this example Math . PI : returns the value of pi (3.141592653589793) Math . random () : returns a random double in the interval [0.0, 1.0). This can be used to generate a random integer within a particular range by clamping the number down, then casting it to an int . For example, if you want a random integer in the interval [ lower , upper ], you would declare int randInt = ( int ) ( Math . random () * ( upper - lower )) + lower ; . Try it out! Exercises * Write a program that solves quadratic equations of the form 0=ax^2+bx+c for x, where a, b, and c are coefficients given by the user * Write a program that calculates the average of a data set, given the numbers in the set and its length * Write a program to find the surface area and volume of a square pyramid, given its side length and height * Write a program to round a number to a specific number of decimal places","title":"The Math Class"},{"location":"develop/maintain/L2/#assignment","text":"Complete the \"Raider Robotix Printer\" and \"Binary Converter\" programs on HackerRank.","title":"Assignment"},{"location":"develop/maintain/L3/","text":"Lesson 3 - Methods Here's a short lesson on one of the building blocks of Java that will prepare you for object-orientated programming: methods. Method signature A method (also known as a function in other languages) is essentially a function, very similar to one that you would encounter in math class. It has an input, an output, and a name (or identifier), though these must have specific data types (think a limited domain/range). Here is a sample method ( isEven ) being declared within a class: public class Example { public boolean isEven ( int num ){ if ( num % 2 == 0 ){ return true ; } return false ; } public static void main ( String [] args ){ //main method //code executed here first } } In this example, the method signature is simply public boolean isEven ( int num ) . It consists of visibility modifiers ( public , private , protected , etc.), a return type ( boolean ), a method identifier ( isEven ), and a set of parameters ( int num ). These parameters must each have a datatype, followed by an identifier, similar to declaring a variable. To list multiple parameters, list each one individually within the parentheses, then separate them with a comma, like in the following example: public int getNumRpPowerUp ( int redScore , int blueScore , boolean autoQuestComplete , int numClimbs , boolean levitateUsed ){ int totalRp = 0 ; if ( redScore > blueScore ) totalRp += 2 ; if ( redScore == blueScore ) totalRp ++ ; if ( autoQuestComplete ) totalRp ++ if ( numClimbs == 3 || numClimbs == 2 && levitateUsed ) totalRp ++ return totalRp ; } Note that a value with the same type as the specified return type ( int in this case) must be returned by the method. This is accomplished by typing the word return followed by a variable or literal value of the specified return type. For instance, the statement return 0 ; would be valid in getNumRpPowerUp as well. Note that the method immediately ends once a return statement is executed. It it possible for a method to have no parameters and/or return type as well. With no parameters, simply leave the contents of the parentheses following the method name blank: public String getInfoString (){ return \"Hello World!\" ; } If you don't want to return a value from the method, the return type should be specified as void . A return statement is not necessary: public void printInfo ( int currentMatchNum , String scoutName ){ System . out . println ( scoutName + \" - Match \" + currentMatchNum ); } You've already used methods to find properties of an object or to compute values, such as with str . length () or Math . pow ( base , power ) . In general, a method call is accomplished by typing the method name, followed by its parameters. The return value (if there is one) can then be used, either within a conditional statement, loop, or assigned to a variable: int red = 200 , blue = 30 , climbs = 1 ; boolean levitated = true ; int rpGained = getNumRpPowerUp ( red , blue , true , climbs , levitated ); while ( isEven ( rpGained )){ //do something } Why methods? So, why are methods so important if they're just executing a block of pre-written code? Well, creating multiple methods in an application or program allows you to break down a problem and do certain tasks repeatedly. For instance, if you wanted to test if a series of numbers were even in different parts of a program, it would be easier to make a call to isEven ( num ) rather than remembering that if a number mod 2 is 0, it is even. Another way to structure an application is to have methods responsible for specific tasks, such as saving a file or verifying if a password matches the one that was stored. As long as you test a method after you write it and ensure it gives the correct output for a variety of input parameters, you can use it throughout an application without needing to refer back to the actual method's source code. That also makes it easy to collaborate with each other, as each person working on a project could be responsible for writing and testing one method; as long as those work independently, you could implement them together in the final product. Overloading methods Sometimes, a method should be able to have different set of parameters, of different data types. In this case, the parameter list will need to be modfied: public double average ( int num1 , int num2 ){ return ( num1 + num2 ) / 2.0 ; } public double average ( double a , double b ){ return ( a + b ) / 2.0 ; } Depending on the datatypes of the parameters when you make the method call, the compiler will know which method to execute. Note that the return type for a particular method name must always be the same, and a method cannot be overloaded if its signature is otherwise identical (parameters have the same datatypes, in the same order). Recursion Like in math, methods can call themselves or other methods within the body of their code. For instance, the following returns the n th Fibonacci number (1, 1, 2, 3, 5, ...): int fib ( int n ){ if ( n == 1 ) return 1 ; if ( n == 2 ) return 1 ; return fib ( n - 1 ) + fib ( n - 2 ); } Recursion is useful for creating simple methods, but their running time can sometimes be slow, and you must always ensure that you reach a base case ( n == 1 or n == 2 in this example) that returns a literal value. Refer to the binary search method if you want to see a more complex example of recursion. Algorithmic challenges Do as many as you want, until you get a good feel of when to implement methods and how to break down a problem: Write a recursive method to compute the factorial of a number. Note that 0! is equal to 1. Write a program that takes any English sentence without punctuation as an input, then converts it to Pig Latin . Implement a more efficient (non-recursive) algorithm to find the n th Fibonacci number Determine the sum of all prime numbers from 2 to a number specified by the user. A number is superb if and only if the sum of all of its factors (excluding itself) is less than a number. Write a program to determine the number of superb numbers between two numbers (e.g. 1 and 100) that are specified by the user. Given a series of variable identifiers in camelCase, identify the number of actual words in the string (e.g. numberOfRankingPoints has four actual words). Given the length of a set of integers S, followed the elements (numbers) of S, determine if S contains only consecutive integers, without repeats (e.g. {3, 5, 4, 6} does, while {6, 4, 3} and {1, 2, 2, 3} do not). Given a series of lowercase strings without spaces or punctuation, determine if any two adjacent strings (inputted right after each other) are anagrams of each other. Write a program to determine if a number is a palindrome. Write methods that compute the least common multiple and greatest common factor of two positive integers. Please email or DM me via Slack any challenges that you finish for feedback!","title":"Lesson 3: The Blue Alliance Library"},{"location":"develop/maintain/L3/#lesson-3-methods","text":"Here's a short lesson on one of the building blocks of Java that will prepare you for object-orientated programming: methods.","title":"Lesson 3 - Methods"},{"location":"develop/maintain/L3/#method-signature","text":"A method (also known as a function in other languages) is essentially a function, very similar to one that you would encounter in math class. It has an input, an output, and a name (or identifier), though these must have specific data types (think a limited domain/range). Here is a sample method ( isEven ) being declared within a class: public class Example { public boolean isEven ( int num ){ if ( num % 2 == 0 ){ return true ; } return false ; } public static void main ( String [] args ){ //main method //code executed here first } } In this example, the method signature is simply public boolean isEven ( int num ) . It consists of visibility modifiers ( public , private , protected , etc.), a return type ( boolean ), a method identifier ( isEven ), and a set of parameters ( int num ). These parameters must each have a datatype, followed by an identifier, similar to declaring a variable. To list multiple parameters, list each one individually within the parentheses, then separate them with a comma, like in the following example: public int getNumRpPowerUp ( int redScore , int blueScore , boolean autoQuestComplete , int numClimbs , boolean levitateUsed ){ int totalRp = 0 ; if ( redScore > blueScore ) totalRp += 2 ; if ( redScore == blueScore ) totalRp ++ ; if ( autoQuestComplete ) totalRp ++ if ( numClimbs == 3 || numClimbs == 2 && levitateUsed ) totalRp ++ return totalRp ; } Note that a value with the same type as the specified return type ( int in this case) must be returned by the method. This is accomplished by typing the word return followed by a variable or literal value of the specified return type. For instance, the statement return 0 ; would be valid in getNumRpPowerUp as well. Note that the method immediately ends once a return statement is executed. It it possible for a method to have no parameters and/or return type as well. With no parameters, simply leave the contents of the parentheses following the method name blank: public String getInfoString (){ return \"Hello World!\" ; } If you don't want to return a value from the method, the return type should be specified as void . A return statement is not necessary: public void printInfo ( int currentMatchNum , String scoutName ){ System . out . println ( scoutName + \" - Match \" + currentMatchNum ); } You've already used methods to find properties of an object or to compute values, such as with str . length () or Math . pow ( base , power ) . In general, a method call is accomplished by typing the method name, followed by its parameters. The return value (if there is one) can then be used, either within a conditional statement, loop, or assigned to a variable: int red = 200 , blue = 30 , climbs = 1 ; boolean levitated = true ; int rpGained = getNumRpPowerUp ( red , blue , true , climbs , levitated ); while ( isEven ( rpGained )){ //do something }","title":"Method signature"},{"location":"develop/maintain/L3/#why-methods","text":"So, why are methods so important if they're just executing a block of pre-written code? Well, creating multiple methods in an application or program allows you to break down a problem and do certain tasks repeatedly. For instance, if you wanted to test if a series of numbers were even in different parts of a program, it would be easier to make a call to isEven ( num ) rather than remembering that if a number mod 2 is 0, it is even. Another way to structure an application is to have methods responsible for specific tasks, such as saving a file or verifying if a password matches the one that was stored. As long as you test a method after you write it and ensure it gives the correct output for a variety of input parameters, you can use it throughout an application without needing to refer back to the actual method's source code. That also makes it easy to collaborate with each other, as each person working on a project could be responsible for writing and testing one method; as long as those work independently, you could implement them together in the final product.","title":"Why methods?"},{"location":"develop/maintain/L3/#overloading-methods","text":"Sometimes, a method should be able to have different set of parameters, of different data types. In this case, the parameter list will need to be modfied: public double average ( int num1 , int num2 ){ return ( num1 + num2 ) / 2.0 ; } public double average ( double a , double b ){ return ( a + b ) / 2.0 ; } Depending on the datatypes of the parameters when you make the method call, the compiler will know which method to execute. Note that the return type for a particular method name must always be the same, and a method cannot be overloaded if its signature is otherwise identical (parameters have the same datatypes, in the same order).","title":"Overloading methods"},{"location":"develop/maintain/L3/#recursion","text":"Like in math, methods can call themselves or other methods within the body of their code. For instance, the following returns the n th Fibonacci number (1, 1, 2, 3, 5, ...): int fib ( int n ){ if ( n == 1 ) return 1 ; if ( n == 2 ) return 1 ; return fib ( n - 1 ) + fib ( n - 2 ); } Recursion is useful for creating simple methods, but their running time can sometimes be slow, and you must always ensure that you reach a base case ( n == 1 or n == 2 in this example) that returns a literal value. Refer to the binary search method if you want to see a more complex example of recursion.","title":"Recursion"},{"location":"develop/maintain/L3/#algorithmic-challenges","text":"Do as many as you want, until you get a good feel of when to implement methods and how to break down a problem: Write a recursive method to compute the factorial of a number. Note that 0! is equal to 1. Write a program that takes any English sentence without punctuation as an input, then converts it to Pig Latin . Implement a more efficient (non-recursive) algorithm to find the n th Fibonacci number Determine the sum of all prime numbers from 2 to a number specified by the user. A number is superb if and only if the sum of all of its factors (excluding itself) is less than a number. Write a program to determine the number of superb numbers between two numbers (e.g. 1 and 100) that are specified by the user. Given a series of variable identifiers in camelCase, identify the number of actual words in the string (e.g. numberOfRankingPoints has four actual words). Given the length of a set of integers S, followed the elements (numbers) of S, determine if S contains only consecutive integers, without repeats (e.g. {3, 5, 4, 6} does, while {6, 4, 3} and {1, 2, 2, 3} do not). Given a series of lowercase strings without spaces or punctuation, determine if any two adjacent strings (inputted right after each other) are anagrams of each other. Write a program to determine if a number is a palindrome. Write methods that compute the least common multiple and greatest common factor of two positive integers. Please email or DM me via Slack any challenges that you finish for feedback!","title":"Algorithmic challenges"},{"location":"develop/misc/L1/","text":"Lesson 1 - File I/O Reading files Reading folders Writing to files Regex Android differences","title":"Lesson 1: File I/O"},{"location":"develop/misc/L1/#lesson-1-file-io","text":"","title":"Lesson 1 - File I/O"},{"location":"develop/misc/L1/#reading-files","text":"","title":"Reading files"},{"location":"develop/misc/L1/#reading-folders","text":"","title":"Reading folders"},{"location":"develop/misc/L1/#writing-to-files","text":"","title":"Writing to files"},{"location":"develop/misc/L1/#regex","text":"","title":"Regex"},{"location":"develop/misc/L1/#android-differences","text":"","title":"Android differences"},{"location":"develop/misc/L2/","text":"Lesson 2 - JSON Structure and editing Serialization Creating object models Deserialization","title":"Lesson 2: JSON"},{"location":"develop/misc/L2/#lesson-2-json","text":"","title":"Lesson 2 - JSON"},{"location":"develop/misc/L2/#structure-and-editing","text":"","title":"Structure and editing"},{"location":"develop/misc/L2/#serialization","text":"","title":"Serialization"},{"location":"develop/misc/L2/#creating-object-models","text":"","title":"Creating object models"},{"location":"develop/misc/L2/#deserialization","text":"","title":"Deserialization"},{"location":"develop/misc/L3/","text":"Lesson 3 - HTTP About GET requests POST requests Headers API keys Responses","title":"Lesson 3: HTTP"},{"location":"develop/misc/L3/#lesson-3-http","text":"","title":"Lesson 3 - HTTP"},{"location":"develop/misc/L3/#about","text":"","title":"About"},{"location":"develop/misc/L3/#get-requests","text":"","title":"GET requests"},{"location":"develop/misc/L3/#post-requests","text":"","title":"POST requests"},{"location":"develop/misc/L3/#headers","text":"","title":"Headers"},{"location":"develop/misc/L3/#api-keys","text":"","title":"API keys"},{"location":"develop/misc/L3/#responses","text":"","title":"Responses"},{"location":"develop/misc/L4/","text":"Lesson 4 - The Blue Alliance API Structure Using the Java library Using HTTP API keys","title":"Lesson 4: The Blue Alliance API"},{"location":"develop/misc/L4/#lesson-4-the-blue-alliance-api","text":"","title":"Lesson 4 - The Blue Alliance API"},{"location":"develop/misc/L4/#structure","text":"","title":"Structure"},{"location":"develop/misc/L4/#using-the-java-library","text":"","title":"Using the Java library"},{"location":"develop/misc/L4/#using-http","text":"","title":"Using HTTP"},{"location":"develop/misc/L4/#api-keys","text":"","title":"API keys"},{"location":"develop/misc/L5/","text":"Lesson 5 - Java Swing Frames Buttons Panels","title":"Lesson 5: Java Swing"},{"location":"develop/misc/L5/#lesson-5-java-swing","text":"","title":"Lesson 5 - Java Swing"},{"location":"develop/misc/L5/#frames","text":"","title":"Frames"},{"location":"develop/misc/L5/#buttons","text":"","title":"Buttons"},{"location":"develop/misc/L5/#panels","text":"","title":"Panels"},{"location":"develop/misc/L6/","text":"Lesson 6 - Regex","title":"Lesson 6: Regex"},{"location":"develop/misc/L6/#lesson-6-regex","text":"","title":"Lesson 6 - Regex"},{"location":"develop/misc/L7/","text":"Lesson 7 - HTML & JavaScript HTML Structure Styling Links Embedding content CSS JavaScript Java differences Using libraries Using HTTP requests Interfacing with HTML","title":"Lesson 7: HTML & Javascript"},{"location":"develop/misc/L7/#lesson-7-html-javascript","text":"","title":"Lesson 7 - HTML &amp; JavaScript"},{"location":"develop/misc/L7/#html","text":"","title":"HTML"},{"location":"develop/misc/L7/#structure","text":"","title":"Structure"},{"location":"develop/misc/L7/#styling","text":"","title":"Styling"},{"location":"develop/misc/L7/#links","text":"","title":"Links"},{"location":"develop/misc/L7/#embedding-content","text":"","title":"Embedding content"},{"location":"develop/misc/L7/#css","text":"","title":"CSS"},{"location":"develop/misc/L7/#javascript","text":"","title":"JavaScript"},{"location":"develop/misc/L7/#java-differences","text":"","title":"Java differences"},{"location":"develop/misc/L7/#using-libraries","text":"","title":"Using libraries"},{"location":"develop/misc/L7/#using-http-requests","text":"","title":"Using HTTP requests"},{"location":"develop/misc/L7/#interfacing-with-html","text":"","title":"Interfacing with HTML"},{"location":"develop/opensource/L1/","text":"Lesson 1 - What is Git? Version Control Systems Intro to Git Comitting Remotes GitHub Repositories SSH","title":"Lesson 1: What is Git?"},{"location":"develop/opensource/L1/#lesson-1-what-is-git","text":"","title":"Lesson 1 - What is Git?"},{"location":"develop/opensource/L1/#version-control-systems","text":"","title":"Version Control Systems"},{"location":"develop/opensource/L1/#intro-to-git","text":"","title":"Intro to Git"},{"location":"develop/opensource/L1/#comitting","text":"","title":"Comitting"},{"location":"develop/opensource/L1/#remotes","text":"","title":"Remotes"},{"location":"develop/opensource/L1/#github","text":"","title":"GitHub"},{"location":"develop/opensource/L1/#repositories","text":"","title":"Repositories"},{"location":"develop/opensource/L1/#ssh","text":"","title":"SSH"},{"location":"develop/opensource/L2/","text":"Lesson 2 - Collaboration Communication Branches Merge conflicts Issues Versioning Releases","title":"Lesson 2: Collaboration"},{"location":"develop/opensource/L2/#lesson-2-collaboration","text":"","title":"Lesson 2 - Collaboration"},{"location":"develop/opensource/L2/#communication","text":"","title":"Communication"},{"location":"develop/opensource/L2/#branches","text":"","title":"Branches"},{"location":"develop/opensource/L2/#merge-conflicts","text":"","title":"Merge conflicts"},{"location":"develop/opensource/L2/#issues","text":"","title":"Issues"},{"location":"develop/opensource/L2/#versioning","text":"","title":"Versioning"},{"location":"develop/opensource/L2/#releases","text":"","title":"Releases"},{"location":"develop/opensource/L3/","text":"Lesson 3 - Build Tools Travis CI Gradle Maven","title":"Lesson 3: Build Tools"},{"location":"develop/opensource/L3/#lesson-3-build-tools","text":"","title":"Lesson 3 - Build Tools"},{"location":"develop/opensource/L3/#travis-ci","text":"","title":"Travis CI"},{"location":"develop/opensource/L3/#gradle","text":"","title":"Gradle"},{"location":"develop/opensource/L3/#maven","text":"","title":"Maven"},{"location":"develop/opensource/L4/","text":"Lesson 4 - Documentation JavaDoc Style GitHub Pages Markdown MkDocs","title":"Lesson 4: Documentation"},{"location":"develop/opensource/L4/#lesson-4-documentation","text":"","title":"Lesson 4 - Documentation"},{"location":"develop/opensource/L4/#javadoc","text":"","title":"JavaDoc"},{"location":"develop/opensource/L4/#style","text":"","title":"Style"},{"location":"develop/opensource/L4/#github-pages","text":"","title":"GitHub Pages"},{"location":"develop/opensource/L4/#markdown","text":"","title":"Markdown"},{"location":"develop/opensource/L4/#mkdocs","text":"","title":"MkDocs"},{"location":"lead/assess/L1/","text":"Lesson 1 - Introduction to Java Raider Robotix and Java FRC Team 25, Raider Robotix , uses the Java programming language for programming both the robot and the scouting system. Java is also taught in NBTHS's computer science courses. These lessons will provide you with the building blocks of Java that are necessary to program, maintain, and understand the scouting system. It currently has two components: * Android scouting app - collects data from scouts during events and exports it in JSON (JavaScript Object Notation) files * Every year, this needs to be updated with the correct metrics, events, game manual, and other options, as necessary * Desktop scouting client - compiles the JSON files from the app and outputs spreadsheets of each scouting entry and aggregated statistics for each team * Every year, this needs to be updated with the correct metrics, which includes averages, percentages, probabilities, and standard deviations, in addition to those in the scouting app Starting from the 2017 season, Tableau is used to visualize and analyze the data from the spreadsheets generated by the client. The goal is to have you understand how the scouting system works and be comfortable with changing its code by next season's kickoff. If you want to work on robot programming instead, additional knowledge of WPILib API will be needed. Lesson Structure Generally, several concepts will be explained and grouped together to form a lesson. As each concept is taught, several practice exercises are given for you to check your understanding. At the end of the lesson, one or two problems will be assigned on HackerRank that test your understanding of all concepts in the lesson. The site allows you to check your program against several test cases and will \"grade\" it (pass or fail) instantly. Java Code Structure Java source files have a . java extension and each contain a class , which acts like an object (we'll get to this later). Each class/source file is located in a package , which acts as a folder to organize various files. Inside an executable program is a main method , in which the code inside it executes. In a desktop Java program, the method signature public static void main ( String [] args ) is used, followed by a set of curly braces. Below is an example inside a file called Example . java : // Place import statements here public class Example { public static void main ( String [] args ){ // Write your code to execute here } } As seen above line comments can be written if they are proceeded with two forward slashes ( // ). Anything following the two slashes will be ignored by the compiler when your program executes. Block comments may also be written like this: /* Hi! * I'm a block comment. */ Note the two slashes showing the beginning/end of the comment and the asterisk on each line. Variables Any data or value you use in Java is stored in a variable . A variable can have one of many different datatypes . The following are common datatypes: * int - an integer with a value between -2^31 - 1 and 2^31 -1 ( 123 , 25 , - 900 , 0 , etc.) * double - a positive or negative decimal number ( 1.23 , - 2.5 , 1.0005 , etc.) * boolean - has either a true or false value * String - a sequence of characters, enclosed in a set of quotation marks ( \"Hello World\" , \"1+1=2\" , \"Raider Robotix\" , etc.) You can declare variables with its datatype, followed by a space and its identifier , then a semicolon. The identifier must start with a letter or underscore, then be followed by more letters, underscores, or numbers, with no spaces. Valid identifiers include: * _t * motor1 * MOTOR_SPEED Generally, variables are named in a camelCase notation, where the first word is lowercase, then the remaining words are uppercase. Examples of variable declarations with camelCase naming include: int teleOpGearsCollected ; double avgKpaPerGame ; boolean baselineCrossed ; String robotComment , pilotComment ; //multiple variables can be declared with a comma separating them On the other hand, variables that are constant throughout a program should be named with only uppercase letters and underscores. Examples of these variables include: double TURN_ANGLE_TOLERANCE ; int LEFT_JOYSTICK_PORT ; String RULES_FILEPATH ; int VERSION_NUMBER ; Keep in mind that variables should not have generic identifiers like x or var1 , but ones that are descriptive. A variable can be assigned a value with its identifier followed by the assignment operator , = , and its value. This value can be literal or that of another variable. A variable may be assigned a value and declared at the same time as well. Some examples: int teleOpGearsCollected ; // declaration double avgHighGoalsTeleOp = 12.555 ; // variable declared and value of 12.555 assigned teleOpGearsCollected = 4 ; // assignment afterwards boolean baselineCrossed = true , readyTakeoff = false ; // two variables declared and assigned value String robotComment = \"This is a good robot\" ; double avgTeleOpKpa = avgHighGoalsTeleOp / 3 ; //value dependent on another variable Output Output to the console in Java can be executed with the following statement : System . out . println ( < some value > ); This calls the println method on a value, where < some value > can be a literal value or a variable. Remember to terminate the print statement with a semicolon. For example, executing System . out . println ( teleOpGearsCollected ); System . out . println ( \"gears collected in tele-op in match\" ); System . out . println ( 25 ); will result in the following output: 4 gears collected in tele - op in match 25 If you don't want a new line after the output, the System . out . print ( < some value > ) method may be used. Executing System . out . print ( teleOpGearsCollected ); System . out . println ( \" gears collected in tele-op.\" ); System . out . println ( \"Robots are cool\" ); will result in the following output: 4 gears collected in tele - op . Robots are cool An IDE An IDE (Integrated Development Environment) will be used to program in Java. It allows you to write code, execute, and debug it in one application. I recommend using Eclipse , as NBTHS and the WPILib API uses it, though alternatives like InteliJ and BlueJ exist. We will be using Android Studio as our IDE for Android development. To get started with Eclipse: 1. Download and extract the ZIP file from the link above 2. Run the executable and choose your workspace (default should work) 3. Go to File > New > Java Project and name your project 4. Close the Welcome window 5. Right click your project and go to New > Class, and name your class (without the . java extension) 6. Write your main method (see above) 7. Try replacing the comment with a statement to print Hello World 8. Press the green \"Play\" button to execute your program If there are any syntax errors in your program, Eclipse will underline them in red, and the program will not run. Try fixing them by reading the error message and reviewing your code or by using Google. A Brief Exercise : Assign the values of true , \"Raider Robotix\" , and 25 to variables. Use print statements with the variables and literal values to generate the output Hello World ! It is true that I am on Team 25 , Raider Robotix 25 is the Team Number . Input To take user input, you will need to use a Scanner object. First, you will need to import the class by placing the following import statement before the class starts (see example above): import java.util.Scanner ; The Scanner object can be declared and constructed like this to read from the system console: Scanner myScanner = new Scanner ( System . in ); The datatype is Scanner , and myScanner can be any valid identifier. Note the use of the new keyword to create a new object and the parentheses following. Several methods can be accessed through the Scanner object for different datatypes. A method essentially acts like a function and returns a value to the main program. These may be used to let users assign values to variables: int anInteger = myScanner . nextInt (); String aLine = myScanner . next (); // takes the next whole line Essentially, the dot operator ( . ) shows that the methods nextInt () and nextLine () are written in the Scanner class, and you are accessing them from an outside class. More methods for input can be found by reading the documentation for the class . If the wrong datatype is used, there will be an error in your program. By default, spaces and line breaks separating tokens in the input will result two different variables. For example, if the input is Raider Robotix executing String teamName = myScanner . next (); System . out . println ( teamName ); will output Raider while executing String teamName = myScanner . nextLine (); System . out . println ( teamName ); will output Raider Robotix Exercise Write a program that allows prompts a user to input a string, an integer, and a floating point number, then print all three once they are inputted. Operators Operators in Java allow you to interact between different datatypes. For these examples, we will declare int a = 5 , b = 4 ; double c = 2.5 ; String s = \"Hello\" ; Mathematical Evaluating these operators will result in a number of type int if both are integers, or of type double if at least one is a double : + - adds the number (an int or double ) to the left and right of it a + b is equal to 9 , a + c is equal to 7.5 - - subtracts the number on the right from the left b - a is equal to - 1 , b - c is equal to 1.5 * - multiplies the number to the left and right of it a * b is equal to 20 , b * c is equal to 10.0 / - divides the number on the left by the number on the right. However, if both numbers are int s, integer division will occur. That is, the remainder is discarded, and only the quotient remains. a / c is equal to 2.0 , b / c is equal to 1.6 a / b is equal to 1 , b / a is equal to 0 A literal int value ( 1 ) may be converted into a double value by adding a decimal point and a zero ( 1.0 ) % - the modulus operator, a % b returns the remainder of a / b a % b is equal to 1 , b % a is equal to 4 , a % c is equal to 0.0 Exercises : * Write a program that allows the user to input (integer) dimensions of a rectangular prism and outputs its surface area and volume * Write a program that prints the day of the week of a day, given the day of the week of the first day of the month (where 1=Monday, 7=Sunday) * Write a program that calculates the score of a match in FIRST Steamworks, where the user inputs the number of rotors activated during tele-op/autonomous, high/low goals in tele-op/autonomous, the times the baseline was crossed, the times robots took off, and foul points that were incurred by the opposing alliance Relational Evaluating these operators will result in a boolean value ( true or false ): < - less than, <= - less than or equal to b < a is true , 4.5 < 0 is false - 2 <= c is true , 5 <= 5 is true > - greater than, >= - greater than or equal to == - checks for equality. This can only be used for primitive datatypes, and not objects a == 5 is true , 2.0 == a / c is true false == true is false For strings, the method someString . equals ( /*another string*/ ) is used for equality because a string is an object. We'll get into this more in the next lesson. s . equals ( \"Hello\" ) is true , s . equals ( \"World\" ) is false != - checks if the two objects are not equal a != 5 is false , 1 != a / c is true false != true is true Exercise : Write a program to determine if it is true that a quadratic equation of the form 0=ax^2+bx+c has a real solution, where the user inputs a, b, and c. (Hint: For now the best way to square an integer x is x * x , as x ^ 2 will not evaluate correctly) Logical These operate on boolean values and evaluating them will also result in a boolean value: OR Operator - written as a || b , evaluates to true only if either a or b are true a b a \\ | \\ | b false false false false true true true false true true true true AND Operator - written as a && b , evaluates to true only if both a and b are true a b a && b false false false false true false true false false true true true NOT Operator - written as !a , evaluates to true only if a is false a !a false true true false Exercises * Evaluate the following expressions (without actually writing any code) for when boolean a = true , b = false and for when boolean a = true , b = true : * ( a || b ) && ( ! a || ! b ) * ! ( a && ! b ) || ( ! a && b ) * ! ( a && b ) Some Shortcuts You already learned about the assignment operator. Here are some shortcuts used for assignment with operators, if x and y are numbers and both are already declared and assigned values: x += y ; // same as x = x+y x -= y ; // same as x = x-y x /= y ; // same as x = x/y x %= y ; // same as x = x % y x ++ ; // same as x+=1 x -- ; // same as x-=1 Exercise : What is the value of x after the following is executed? int x = 60 , y = 10 ; y /= 5 ; x %= x - y ; x ++ ; x *= 4 ; Boolean Expressions A boolean expression is any expression that evaluates to true or false . It may contain literals, variables, and any of the above operators. The order of operations for evaluation are: Parentheses NOT Multiplication, division, modulus Addition, subtraction Greater/less than (or equal to) Equivalence/not equivalent AND OR The following are valid boolean expressions if x and y are numbers and b is a boolean : * x >= 5 + y && ! ( y + 5 == 7 || y < 0 || ! b ) * takeoffPercentage / avgTakeoffPercentage + 0.1 >= 1.2 && ( avgKpa >= 30 || avgGears >= 4 ) && teamNum != 25 && ! droppedGearOften Exercises * The XOR (exclusive-or) operator evaluates to be true if either A or B are true, but not both. Write an expression that is logically equivalent to \"A XOR B\" using the AND, OR, and NOT operators * Write a boolean expression to determine if at least 3 ranking points were earned by the red alliance in a match of FIRST Steamworks, given the scores of both the red and blue alliances, the number of gears delivered by the red alliance, whether or not the reserve gear was used, and the number of high/low goals into the red boiler in autonomous/tele-op. Use appropriate identifiers for variables and declare multiple, intermediate boolean expressions as necessary. Conditionals A conditional statement is one that executes if a particular boolean expression is true. The if , else , and else - if statements are written and used as follows: boolean a = < some expression > ; if ( a ){ //Code here executes if expression a is true } else if ( < some boolean expression b > ){ // Code here executes if expression b is true and a is false } else { // Code here executes if a and b are both false } Note that an if statement may be written without any else statements, but else and else - if statements must follow an if statement or an else statement. The boolean expression may also be placed inside the parentheses, rather than assigning its value to a boolean variable. These conditional statements may also be nested inside each other as follows: boolean a = < some expression > ; boolean b = < some expression > ; boolean c = < some expression > ; if ( a ){ if ( c ){ // Code here executes if a and c are true } else { //Code here executes if a is true and c is false } // Code here executes as long as a is true, no matter what the value of c is } else if ( b ){ // Code here executes if expression b is true and a is false, no matter what the value of c is if ( ! c ){ //Code here executes if a is false, b is true, and c is false } } else { // Code here executes if a and b are both false } Exercises * Write a program to determine if a number is even or odd * Write a program that prints the month, given its numerical value (1 to 12) * Write a program that converts a day of the week to a number (Monday = 1, Sunday = 7) * Write a program that converts feet to yards and vice-versa, depending on what the user wants Assignment Download Eclipse and complete the exercises above as necessary to check your understanding. Afterwards, sign up for a HackerRank account and complete the \"A School Day\" program here . I suggest that you write and test the program on Eclipse, then check if it works on HackerRank.","title":"Lesson 1: Evaluation System"},{"location":"lead/assess/L1/#lesson-1-introduction-to-java","text":"","title":"Lesson 1 - Introduction to Java"},{"location":"lead/assess/L1/#raider-robotix-and-java","text":"FRC Team 25, Raider Robotix , uses the Java programming language for programming both the robot and the scouting system. Java is also taught in NBTHS's computer science courses. These lessons will provide you with the building blocks of Java that are necessary to program, maintain, and understand the scouting system. It currently has two components: * Android scouting app - collects data from scouts during events and exports it in JSON (JavaScript Object Notation) files * Every year, this needs to be updated with the correct metrics, events, game manual, and other options, as necessary * Desktop scouting client - compiles the JSON files from the app and outputs spreadsheets of each scouting entry and aggregated statistics for each team * Every year, this needs to be updated with the correct metrics, which includes averages, percentages, probabilities, and standard deviations, in addition to those in the scouting app Starting from the 2017 season, Tableau is used to visualize and analyze the data from the spreadsheets generated by the client. The goal is to have you understand how the scouting system works and be comfortable with changing its code by next season's kickoff. If you want to work on robot programming instead, additional knowledge of WPILib API will be needed.","title":"Raider Robotix and Java"},{"location":"lead/assess/L1/#lesson-structure","text":"Generally, several concepts will be explained and grouped together to form a lesson. As each concept is taught, several practice exercises are given for you to check your understanding. At the end of the lesson, one or two problems will be assigned on HackerRank that test your understanding of all concepts in the lesson. The site allows you to check your program against several test cases and will \"grade\" it (pass or fail) instantly.","title":"Lesson Structure"},{"location":"lead/assess/L1/#java-code-structure","text":"Java source files have a . java extension and each contain a class , which acts like an object (we'll get to this later). Each class/source file is located in a package , which acts as a folder to organize various files. Inside an executable program is a main method , in which the code inside it executes. In a desktop Java program, the method signature public static void main ( String [] args ) is used, followed by a set of curly braces. Below is an example inside a file called Example . java : // Place import statements here public class Example { public static void main ( String [] args ){ // Write your code to execute here } } As seen above line comments can be written if they are proceeded with two forward slashes ( // ). Anything following the two slashes will be ignored by the compiler when your program executes. Block comments may also be written like this: /* Hi! * I'm a block comment. */ Note the two slashes showing the beginning/end of the comment and the asterisk on each line.","title":"Java Code Structure"},{"location":"lead/assess/L1/#variables","text":"Any data or value you use in Java is stored in a variable . A variable can have one of many different datatypes . The following are common datatypes: * int - an integer with a value between -2^31 - 1 and 2^31 -1 ( 123 , 25 , - 900 , 0 , etc.) * double - a positive or negative decimal number ( 1.23 , - 2.5 , 1.0005 , etc.) * boolean - has either a true or false value * String - a sequence of characters, enclosed in a set of quotation marks ( \"Hello World\" , \"1+1=2\" , \"Raider Robotix\" , etc.) You can declare variables with its datatype, followed by a space and its identifier , then a semicolon. The identifier must start with a letter or underscore, then be followed by more letters, underscores, or numbers, with no spaces. Valid identifiers include: * _t * motor1 * MOTOR_SPEED Generally, variables are named in a camelCase notation, where the first word is lowercase, then the remaining words are uppercase. Examples of variable declarations with camelCase naming include: int teleOpGearsCollected ; double avgKpaPerGame ; boolean baselineCrossed ; String robotComment , pilotComment ; //multiple variables can be declared with a comma separating them On the other hand, variables that are constant throughout a program should be named with only uppercase letters and underscores. Examples of these variables include: double TURN_ANGLE_TOLERANCE ; int LEFT_JOYSTICK_PORT ; String RULES_FILEPATH ; int VERSION_NUMBER ; Keep in mind that variables should not have generic identifiers like x or var1 , but ones that are descriptive. A variable can be assigned a value with its identifier followed by the assignment operator , = , and its value. This value can be literal or that of another variable. A variable may be assigned a value and declared at the same time as well. Some examples: int teleOpGearsCollected ; // declaration double avgHighGoalsTeleOp = 12.555 ; // variable declared and value of 12.555 assigned teleOpGearsCollected = 4 ; // assignment afterwards boolean baselineCrossed = true , readyTakeoff = false ; // two variables declared and assigned value String robotComment = \"This is a good robot\" ; double avgTeleOpKpa = avgHighGoalsTeleOp / 3 ; //value dependent on another variable","title":"Variables"},{"location":"lead/assess/L1/#output","text":"Output to the console in Java can be executed with the following statement : System . out . println ( < some value > ); This calls the println method on a value, where < some value > can be a literal value or a variable. Remember to terminate the print statement with a semicolon. For example, executing System . out . println ( teleOpGearsCollected ); System . out . println ( \"gears collected in tele-op in match\" ); System . out . println ( 25 ); will result in the following output: 4 gears collected in tele - op in match 25 If you don't want a new line after the output, the System . out . print ( < some value > ) method may be used. Executing System . out . print ( teleOpGearsCollected ); System . out . println ( \" gears collected in tele-op.\" ); System . out . println ( \"Robots are cool\" ); will result in the following output: 4 gears collected in tele - op . Robots are cool","title":"Output"},{"location":"lead/assess/L1/#an-ide","text":"An IDE (Integrated Development Environment) will be used to program in Java. It allows you to write code, execute, and debug it in one application. I recommend using Eclipse , as NBTHS and the WPILib API uses it, though alternatives like InteliJ and BlueJ exist. We will be using Android Studio as our IDE for Android development. To get started with Eclipse: 1. Download and extract the ZIP file from the link above 2. Run the executable and choose your workspace (default should work) 3. Go to File > New > Java Project and name your project 4. Close the Welcome window 5. Right click your project and go to New > Class, and name your class (without the . java extension) 6. Write your main method (see above) 7. Try replacing the comment with a statement to print Hello World 8. Press the green \"Play\" button to execute your program If there are any syntax errors in your program, Eclipse will underline them in red, and the program will not run. Try fixing them by reading the error message and reviewing your code or by using Google. A Brief Exercise : Assign the values of true , \"Raider Robotix\" , and 25 to variables. Use print statements with the variables and literal values to generate the output Hello World ! It is true that I am on Team 25 , Raider Robotix 25 is the Team Number .","title":"An IDE"},{"location":"lead/assess/L1/#input","text":"To take user input, you will need to use a Scanner object. First, you will need to import the class by placing the following import statement before the class starts (see example above): import java.util.Scanner ; The Scanner object can be declared and constructed like this to read from the system console: Scanner myScanner = new Scanner ( System . in ); The datatype is Scanner , and myScanner can be any valid identifier. Note the use of the new keyword to create a new object and the parentheses following. Several methods can be accessed through the Scanner object for different datatypes. A method essentially acts like a function and returns a value to the main program. These may be used to let users assign values to variables: int anInteger = myScanner . nextInt (); String aLine = myScanner . next (); // takes the next whole line Essentially, the dot operator ( . ) shows that the methods nextInt () and nextLine () are written in the Scanner class, and you are accessing them from an outside class. More methods for input can be found by reading the documentation for the class . If the wrong datatype is used, there will be an error in your program. By default, spaces and line breaks separating tokens in the input will result two different variables. For example, if the input is Raider Robotix executing String teamName = myScanner . next (); System . out . println ( teamName ); will output Raider while executing String teamName = myScanner . nextLine (); System . out . println ( teamName ); will output Raider Robotix Exercise Write a program that allows prompts a user to input a string, an integer, and a floating point number, then print all three once they are inputted.","title":"Input"},{"location":"lead/assess/L1/#operators","text":"Operators in Java allow you to interact between different datatypes. For these examples, we will declare int a = 5 , b = 4 ; double c = 2.5 ; String s = \"Hello\" ;","title":"Operators"},{"location":"lead/assess/L1/#mathematical","text":"Evaluating these operators will result in a number of type int if both are integers, or of type double if at least one is a double : + - adds the number (an int or double ) to the left and right of it a + b is equal to 9 , a + c is equal to 7.5 - - subtracts the number on the right from the left b - a is equal to - 1 , b - c is equal to 1.5 * - multiplies the number to the left and right of it a * b is equal to 20 , b * c is equal to 10.0 / - divides the number on the left by the number on the right. However, if both numbers are int s, integer division will occur. That is, the remainder is discarded, and only the quotient remains. a / c is equal to 2.0 , b / c is equal to 1.6 a / b is equal to 1 , b / a is equal to 0 A literal int value ( 1 ) may be converted into a double value by adding a decimal point and a zero ( 1.0 ) % - the modulus operator, a % b returns the remainder of a / b a % b is equal to 1 , b % a is equal to 4 , a % c is equal to 0.0 Exercises : * Write a program that allows the user to input (integer) dimensions of a rectangular prism and outputs its surface area and volume * Write a program that prints the day of the week of a day, given the day of the week of the first day of the month (where 1=Monday, 7=Sunday) * Write a program that calculates the score of a match in FIRST Steamworks, where the user inputs the number of rotors activated during tele-op/autonomous, high/low goals in tele-op/autonomous, the times the baseline was crossed, the times robots took off, and foul points that were incurred by the opposing alliance","title":"Mathematical"},{"location":"lead/assess/L1/#relational","text":"Evaluating these operators will result in a boolean value ( true or false ): < - less than, <= - less than or equal to b < a is true , 4.5 < 0 is false - 2 <= c is true , 5 <= 5 is true > - greater than, >= - greater than or equal to == - checks for equality. This can only be used for primitive datatypes, and not objects a == 5 is true , 2.0 == a / c is true false == true is false For strings, the method someString . equals ( /*another string*/ ) is used for equality because a string is an object. We'll get into this more in the next lesson. s . equals ( \"Hello\" ) is true , s . equals ( \"World\" ) is false != - checks if the two objects are not equal a != 5 is false , 1 != a / c is true false != true is true Exercise : Write a program to determine if it is true that a quadratic equation of the form 0=ax^2+bx+c has a real solution, where the user inputs a, b, and c. (Hint: For now the best way to square an integer x is x * x , as x ^ 2 will not evaluate correctly)","title":"Relational"},{"location":"lead/assess/L1/#logical","text":"These operate on boolean values and evaluating them will also result in a boolean value: OR Operator - written as a || b , evaluates to true only if either a or b are true a b a \\ | \\ | b false false false false true true true false true true true true AND Operator - written as a && b , evaluates to true only if both a and b are true a b a && b false false false false true false true false false true true true NOT Operator - written as !a , evaluates to true only if a is false a !a false true true false Exercises * Evaluate the following expressions (without actually writing any code) for when boolean a = true , b = false and for when boolean a = true , b = true : * ( a || b ) && ( ! a || ! b ) * ! ( a && ! b ) || ( ! a && b ) * ! ( a && b )","title":"Logical"},{"location":"lead/assess/L1/#some-shortcuts","text":"You already learned about the assignment operator. Here are some shortcuts used for assignment with operators, if x and y are numbers and both are already declared and assigned values: x += y ; // same as x = x+y x -= y ; // same as x = x-y x /= y ; // same as x = x/y x %= y ; // same as x = x % y x ++ ; // same as x+=1 x -- ; // same as x-=1 Exercise : What is the value of x after the following is executed? int x = 60 , y = 10 ; y /= 5 ; x %= x - y ; x ++ ; x *= 4 ;","title":"Some Shortcuts"},{"location":"lead/assess/L1/#boolean-expressions","text":"A boolean expression is any expression that evaluates to true or false . It may contain literals, variables, and any of the above operators. The order of operations for evaluation are: Parentheses NOT Multiplication, division, modulus Addition, subtraction Greater/less than (or equal to) Equivalence/not equivalent AND OR The following are valid boolean expressions if x and y are numbers and b is a boolean : * x >= 5 + y && ! ( y + 5 == 7 || y < 0 || ! b ) * takeoffPercentage / avgTakeoffPercentage + 0.1 >= 1.2 && ( avgKpa >= 30 || avgGears >= 4 ) && teamNum != 25 && ! droppedGearOften Exercises * The XOR (exclusive-or) operator evaluates to be true if either A or B are true, but not both. Write an expression that is logically equivalent to \"A XOR B\" using the AND, OR, and NOT operators * Write a boolean expression to determine if at least 3 ranking points were earned by the red alliance in a match of FIRST Steamworks, given the scores of both the red and blue alliances, the number of gears delivered by the red alliance, whether or not the reserve gear was used, and the number of high/low goals into the red boiler in autonomous/tele-op. Use appropriate identifiers for variables and declare multiple, intermediate boolean expressions as necessary.","title":"Boolean Expressions"},{"location":"lead/assess/L1/#conditionals","text":"A conditional statement is one that executes if a particular boolean expression is true. The if , else , and else - if statements are written and used as follows: boolean a = < some expression > ; if ( a ){ //Code here executes if expression a is true } else if ( < some boolean expression b > ){ // Code here executes if expression b is true and a is false } else { // Code here executes if a and b are both false } Note that an if statement may be written without any else statements, but else and else - if statements must follow an if statement or an else statement. The boolean expression may also be placed inside the parentheses, rather than assigning its value to a boolean variable. These conditional statements may also be nested inside each other as follows: boolean a = < some expression > ; boolean b = < some expression > ; boolean c = < some expression > ; if ( a ){ if ( c ){ // Code here executes if a and c are true } else { //Code here executes if a is true and c is false } // Code here executes as long as a is true, no matter what the value of c is } else if ( b ){ // Code here executes if expression b is true and a is false, no matter what the value of c is if ( ! c ){ //Code here executes if a is false, b is true, and c is false } } else { // Code here executes if a and b are both false } Exercises * Write a program to determine if a number is even or odd * Write a program that prints the month, given its numerical value (1 to 12) * Write a program that converts a day of the week to a number (Monday = 1, Sunday = 7) * Write a program that converts feet to yards and vice-versa, depending on what the user wants","title":"Conditionals"},{"location":"lead/assess/L1/#assignment","text":"Download Eclipse and complete the exercises above as necessary to check your understanding. Afterwards, sign up for a HackerRank account and complete the \"A School Day\" program here . I suggest that you write and test the program on Eclipse, then check if it works on HackerRank.","title":"Assignment"},{"location":"lead/assess/L2/","text":"Lesson 2 - Loops, Strings, Math After a (probably pretty long) first lesson, let's explore a couple more features of Java and see what you can do with everything that you learned. Loops Loops are used to execute a block of code enclosed in a set of braces ( {} ) multiple times. After all, computers are very good at doing the same thing over and over again! The number of times a block executes depends on a boolean expression. while Loops while loops execute as long as a boolean expression is true . It may not execute at all if the expression is false before entering the loop. while ( /*some boolean expression*/ ){ //Execute code here multiple times as long as the expression is true } Remember that the boolean expression should become false at some point during the execution of the code in the loop. Otherwise, an infinite loop will be created. For example, the following will print the numbers from 1 to 10 (inclusive): int counter = 1 ; while ( counter <= 10 ){ System . out . println ( counter ); counter ++ ; } do - while loops may also be written. The main difference between these and while loops is that the boolean expression must be true at the end of the loop, not at the beginning. The following prints the numbers from 1 to 10 (inclusive): int counter = - 1 ; do { counter ++ ; System . out . println ( counter ); } while ( counter < 10 ); for Loops for loops provide a more controlled way for iterating through a loop multiple times. There are three components to the for loop: the initial statement, the exit condition (boolean expression), and the post-excution statement. The example for ( /*initial statement*/ ; /*exit condition*/ ; /*post-execution statement*/ ){ //Code to be executed each loop } is essentially equal to the following while loop: //Initial statement while ( /*exit condition*/ ){ //Code to be executed each loop //Post-execution statement } The for loop is commonly used to execute a loop a certain number of times. Below, the loop prints the numbers from 0 to 9 (10 iterations): for ( int count = 0 ; i < 10 ; count ++ ){ System . out . println ( count ); } Keep in mind that the variable count is declared within the loop, and it cannot accessed outside it. Loops may also be placed inside each other. For example, executing for ( int row = 1 ; row <= 12 ; row ++ ){ for ( int col = 1 ; col <= 12 ; col ++ ){ System . out . print ( row * col ); System . out . print ( \" \" ); //adds a space } System . out . println (); //line break } will print a (poorly formatted) times table. Note that all three parts of a for loop are optional. That is, a loop like for (;;) { //something } will execute forever. Questions Determine the number of times the following for loops will execute. for ( int i = 4 ; i <= 8 ; i += 2 ) { /*do something*/ } for ( int i = 10 ; i >= 0 ; i -= 3 ) { /*do something*/ } for ( int j = 2 ; j >= 4 ; j ++ ) { /*do something*/ } Exercises Write a program that computes the sum of all odd integers from 1 to a number specified by the user Write a program that computes b^e (a number raised to the power of an exponent), where b and e are positive integers Write a program that allows the user to enter a number, setSize . setSize numbers, num , follow and are inputted by the user. Print the average, largest, and smallest of the numbers. Loop Control There are two control statements that are used with loops: break The break statement will immediately exit a while or for loop. This can be useful if you're looking for a specific value, and you want the loop to end after you've found that value. For instance, in the below example, the loop will terminate immediately after the value key is found: int key = 8 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( i == key ) { System . out . println ( \"Found\" ); break ; } System . out . println ( \"Not found...\" ); } As a result, Not found ... will be printed out eight times at first, followed by Found . The loop will then terminate. The break statement will be more useful after you learn about arrays. continue The continue statement will immediately go to the next iteration of a for or while loop, bypassing all statements after it. This could be used when you only want to execute a loop for some values. Of course, an if - else statement can often accomplish the same thing, but break and continue statements can prevent too many nested blocks of code. For instance, the following block of code for ( int i = 0 ; i < 4 ; i ++ ) { System . out . println ( \"Going... \" + i ); if ( i >= 2 ) { continue ; } System . out . println ( \"Here\" ); } will print Going ... 0 Here Going ... 1 Here Going ... 2 Going ... 3 Characters In addition to the primitive data types ( boolean , int , double ) we learned about before, char s represent one of the 256 ASCII characters . These include the numbers, standard symbols and punctuation on a keyboard, and both uppercase and lowercase letters. A char is assigned a value with the declaration char allianceColor = 'R' ; Note the use of single quotation marks rather than double quotation marks (which are used for String s) and that a variable of type char may only contain a single character. Escape characters are the first 32 ASCII characters, which serve special functions. The most commonly used is '\\n' , which creates a line break. In addition, quotation marks must be escaped. Thus, executing the following code char quote1 = '\\'' ; char quote2 = '\\\"' ; char newLine = '\\n' System . out . print ( quote1 ); System . out . print ( newLine ); System . out . print ( quote2 ); will print ' \" Note that strings can be thought of as a series of char s concatenated together. For instance, executing String someText = \"Kickoff, 2017 \\n As we anticipated the new game, the livestream blared, \\\" STEAM POWERED! STEAM POWERED! STEAM POWERED! \\\" \" ; System . out . println ( someText ); will print Kickoff , 2017 As we anticipated the new game , the livestream blared , \"STEAM POWERED! STEAM POWERED! STEAM POWERED!\" The value of characters may be compared with the equivalence ( == ) operator. For example, allianceColor == 'R' is true . Note, however, that a character is not equal its int equivalent. That is, '1' == 1 is false . String Manipulation The String class in Java contains many methods to manipulate strings. We will present an overview of the most useful ones, though you may read the full documentation here . Concatenation A string can be concatenated , or joined together, with other strings or primitive datatypes (and literals) with the + operator. For example, executing the following: String mascot = \"Raider\" ; int teamNum = 25 ; String teamName = mascot + \" Robotix\" ; System . out . println ( \"The year is \" + 2017 ); System . out . println ( \"I am on Team \" + teamNum + \", \" + teamName ); will print The year is 2017 I am on Team 25 , Raider Robotix You may also concatenate a string onto the end of another with the += operator. Executing String s = \"Hello\" ; s += \" World!\" ; System . out . println ( s ); will print Hello World ! . String Properties You can check the length of a string (number of characters) with the string . length () method. Executing String s = \"Hello\" ; System . out . println ( s + \" is \" + s . length () + \" characters long\" ); System . out . print ( \"World!\" . length ()); will print Hello is 5 characters long 6 You can also check if a string contains a specific character sequence with the string . contains ( < character sequence > ) method, which returns a boolean value. If String s = \"Hello\" ; is declared, s . contains ( \"ell\" ) returns true , while s . contains ( \"f\" ) returns false . Parsing a String You may want to parse through a string sometimes, or check the sequence of its characters. The string . charAt ( /*index*/ ) method will return the character currently at the index. There are two things you should know about the method: The method will return a value of type char (character), rather than String . The index is a value that is greater than or equal to 0 and less than string . length () . That is, the index of the first character in the string is 0 , and the index of the last character in the string is string . length () - 1 . If String s = \"World\" ; is declared, s . charAt ( 0 ) returns 'W' , s . charAt ( 3 ) returns 'l' , and s . charAt ( 4 ) returns 'd' . A standard way to parse through all of the characters of a string is with the following for loop: String str = \"Hello World!\" ; for ( int i = 0 ; i < str . length (); i ++ ){ char currentChar = str . charAt ( i ); //Do something here } Substrings Suppose you want to return a slice of a string, known as a substring, such as the first letter four letters of String s = \"Raider Robotix\" ; . An easy-to-understand way would be to use string parsing, similar to what we did above: String s = \"Raider Robotix\" ; String result = \"\" ; // an empty string for ( int i = 0 ; i < 4 && i < s . length (); i ++ ){ result += s . charAt ( i ); } System . out . println ( result ); This would print out Raid . Note that the expression i < s . length () was still present in the exit condition in order to prevent errors if s was an input string that was less than four characters long. However, a faster way to get result would be to use the substring ( beginIndex , endIndex ) method, in which beginIndex and endIndex are integers that represent the indicies that you want to search. Similar to the for loop above, beginIndex is inclusive, while endIndex is exclusive. Here are some examples: s . substring ( 0 , 4 ); returns Raid s . substring ( 7 , s . length ()); returns Robotix \"hamburger\" . substring ( 4 , 8 ); returns urge Miscellaneous String Functions Assume that String s = \"Hello\" ; is declared in the following examples: s . toLowerCase (); returns hello s . toUpperCase (); returns HELLO s . indexOf ( \"l\" ); returns 2 (the first occurence of l in s ), while s . lastIndexOf ( \"l\" ) returns 3 s . concat ( \"world\" ); returns Helloworld As mentioned before, string equality is checked with s . equals ( \"Hello\" ); , which would return true . On the other hand, after declaring String anotherString = \"Hello\" ; , the boolean expression s == anotherString || s == \"Hello\" would be false , as string are objects , not primitives . Exercises * Write a program to reverse a string if it has an R in it. * Write a program to check if a string is a palindrome (reads the same backward as forward, such as racecar) * Write a program to replaces all commas from a string with semicolons The Math Class The Math class contains several methods that you may find helpful. It is imported by default, and documentation is found here . For these examples, we will declare double a = 4.5 , b = - 2.5 ; Math . abs ( b ) : takes the absolute value of a number, returns 2.5 in the example Math . ceil ( a ) : takes the ceiling of a number (rounds it up if it is a decimal), returns 5 in the example Math . floor ( a ) : takes the floor of a number (rounds it down if it is a decimal), returns 4 in the example Math . pow ( a - 0.5 , - b + 0.5 ) : takes the first number to the power of the second number, returns 125.0 in the example Math . sqrt ( a - 0.5 ) : takes the square root of a number, returns 2.0 in this example Math . PI : returns the value of pi (3.141592653589793) Math . random () : returns a random double in the interval [0.0, 1.0). This can be used to generate a random integer within a particular range by clamping the number down, then casting it to an int . For example, if you want a random integer in the interval [ lower , upper ], you would declare int randInt = ( int ) ( Math . random () * ( upper - lower )) + lower ; . Try it out! Exercises * Write a program that solves quadratic equations of the form 0=ax^2+bx+c for x, where a, b, and c are coefficients given by the user * Write a program that calculates the average of a data set, given the numbers in the set and its length * Write a program to find the surface area and volume of a square pyramid, given its side length and height * Write a program to round a number to a specific number of decimal places Assignment Complete the \"Raider Robotix Printer\" and \"Binary Converter\" programs on HackerRank.","title":"Lesson 2: Theory"},{"location":"lead/assess/L2/#lesson-2-loops-strings-math","text":"After a (probably pretty long) first lesson, let's explore a couple more features of Java and see what you can do with everything that you learned.","title":"Lesson 2 - Loops, Strings, Math"},{"location":"lead/assess/L2/#loops","text":"Loops are used to execute a block of code enclosed in a set of braces ( {} ) multiple times. After all, computers are very good at doing the same thing over and over again! The number of times a block executes depends on a boolean expression.","title":"Loops"},{"location":"lead/assess/L2/#while-loops","text":"while loops execute as long as a boolean expression is true . It may not execute at all if the expression is false before entering the loop. while ( /*some boolean expression*/ ){ //Execute code here multiple times as long as the expression is true } Remember that the boolean expression should become false at some point during the execution of the code in the loop. Otherwise, an infinite loop will be created. For example, the following will print the numbers from 1 to 10 (inclusive): int counter = 1 ; while ( counter <= 10 ){ System . out . println ( counter ); counter ++ ; } do - while loops may also be written. The main difference between these and while loops is that the boolean expression must be true at the end of the loop, not at the beginning. The following prints the numbers from 1 to 10 (inclusive): int counter = - 1 ; do { counter ++ ; System . out . println ( counter ); } while ( counter < 10 );","title":"while Loops"},{"location":"lead/assess/L2/#for-loops","text":"for loops provide a more controlled way for iterating through a loop multiple times. There are three components to the for loop: the initial statement, the exit condition (boolean expression), and the post-excution statement. The example for ( /*initial statement*/ ; /*exit condition*/ ; /*post-execution statement*/ ){ //Code to be executed each loop } is essentially equal to the following while loop: //Initial statement while ( /*exit condition*/ ){ //Code to be executed each loop //Post-execution statement } The for loop is commonly used to execute a loop a certain number of times. Below, the loop prints the numbers from 0 to 9 (10 iterations): for ( int count = 0 ; i < 10 ; count ++ ){ System . out . println ( count ); } Keep in mind that the variable count is declared within the loop, and it cannot accessed outside it. Loops may also be placed inside each other. For example, executing for ( int row = 1 ; row <= 12 ; row ++ ){ for ( int col = 1 ; col <= 12 ; col ++ ){ System . out . print ( row * col ); System . out . print ( \" \" ); //adds a space } System . out . println (); //line break } will print a (poorly formatted) times table. Note that all three parts of a for loop are optional. That is, a loop like for (;;) { //something } will execute forever. Questions Determine the number of times the following for loops will execute. for ( int i = 4 ; i <= 8 ; i += 2 ) { /*do something*/ } for ( int i = 10 ; i >= 0 ; i -= 3 ) { /*do something*/ } for ( int j = 2 ; j >= 4 ; j ++ ) { /*do something*/ } Exercises Write a program that computes the sum of all odd integers from 1 to a number specified by the user Write a program that computes b^e (a number raised to the power of an exponent), where b and e are positive integers Write a program that allows the user to enter a number, setSize . setSize numbers, num , follow and are inputted by the user. Print the average, largest, and smallest of the numbers.","title":"for Loops"},{"location":"lead/assess/L2/#loop-control","text":"There are two control statements that are used with loops:","title":"Loop Control"},{"location":"lead/assess/L2/#break","text":"The break statement will immediately exit a while or for loop. This can be useful if you're looking for a specific value, and you want the loop to end after you've found that value. For instance, in the below example, the loop will terminate immediately after the value key is found: int key = 8 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( i == key ) { System . out . println ( \"Found\" ); break ; } System . out . println ( \"Not found...\" ); } As a result, Not found ... will be printed out eight times at first, followed by Found . The loop will then terminate. The break statement will be more useful after you learn about arrays.","title":"break"},{"location":"lead/assess/L2/#continue","text":"The continue statement will immediately go to the next iteration of a for or while loop, bypassing all statements after it. This could be used when you only want to execute a loop for some values. Of course, an if - else statement can often accomplish the same thing, but break and continue statements can prevent too many nested blocks of code. For instance, the following block of code for ( int i = 0 ; i < 4 ; i ++ ) { System . out . println ( \"Going... \" + i ); if ( i >= 2 ) { continue ; } System . out . println ( \"Here\" ); } will print Going ... 0 Here Going ... 1 Here Going ... 2 Going ... 3","title":"continue"},{"location":"lead/assess/L2/#characters","text":"In addition to the primitive data types ( boolean , int , double ) we learned about before, char s represent one of the 256 ASCII characters . These include the numbers, standard symbols and punctuation on a keyboard, and both uppercase and lowercase letters. A char is assigned a value with the declaration char allianceColor = 'R' ; Note the use of single quotation marks rather than double quotation marks (which are used for String s) and that a variable of type char may only contain a single character. Escape characters are the first 32 ASCII characters, which serve special functions. The most commonly used is '\\n' , which creates a line break. In addition, quotation marks must be escaped. Thus, executing the following code char quote1 = '\\'' ; char quote2 = '\\\"' ; char newLine = '\\n' System . out . print ( quote1 ); System . out . print ( newLine ); System . out . print ( quote2 ); will print ' \" Note that strings can be thought of as a series of char s concatenated together. For instance, executing String someText = \"Kickoff, 2017 \\n As we anticipated the new game, the livestream blared, \\\" STEAM POWERED! STEAM POWERED! STEAM POWERED! \\\" \" ; System . out . println ( someText ); will print Kickoff , 2017 As we anticipated the new game , the livestream blared , \"STEAM POWERED! STEAM POWERED! STEAM POWERED!\" The value of characters may be compared with the equivalence ( == ) operator. For example, allianceColor == 'R' is true . Note, however, that a character is not equal its int equivalent. That is, '1' == 1 is false .","title":"Characters"},{"location":"lead/assess/L2/#string-manipulation","text":"The String class in Java contains many methods to manipulate strings. We will present an overview of the most useful ones, though you may read the full documentation here .","title":"String Manipulation"},{"location":"lead/assess/L2/#concatenation","text":"A string can be concatenated , or joined together, with other strings or primitive datatypes (and literals) with the + operator. For example, executing the following: String mascot = \"Raider\" ; int teamNum = 25 ; String teamName = mascot + \" Robotix\" ; System . out . println ( \"The year is \" + 2017 ); System . out . println ( \"I am on Team \" + teamNum + \", \" + teamName ); will print The year is 2017 I am on Team 25 , Raider Robotix You may also concatenate a string onto the end of another with the += operator. Executing String s = \"Hello\" ; s += \" World!\" ; System . out . println ( s ); will print Hello World ! .","title":"Concatenation"},{"location":"lead/assess/L2/#string-properties","text":"You can check the length of a string (number of characters) with the string . length () method. Executing String s = \"Hello\" ; System . out . println ( s + \" is \" + s . length () + \" characters long\" ); System . out . print ( \"World!\" . length ()); will print Hello is 5 characters long 6 You can also check if a string contains a specific character sequence with the string . contains ( < character sequence > ) method, which returns a boolean value. If String s = \"Hello\" ; is declared, s . contains ( \"ell\" ) returns true , while s . contains ( \"f\" ) returns false .","title":"String Properties"},{"location":"lead/assess/L2/#parsing-a-string","text":"You may want to parse through a string sometimes, or check the sequence of its characters. The string . charAt ( /*index*/ ) method will return the character currently at the index. There are two things you should know about the method: The method will return a value of type char (character), rather than String . The index is a value that is greater than or equal to 0 and less than string . length () . That is, the index of the first character in the string is 0 , and the index of the last character in the string is string . length () - 1 . If String s = \"World\" ; is declared, s . charAt ( 0 ) returns 'W' , s . charAt ( 3 ) returns 'l' , and s . charAt ( 4 ) returns 'd' . A standard way to parse through all of the characters of a string is with the following for loop: String str = \"Hello World!\" ; for ( int i = 0 ; i < str . length (); i ++ ){ char currentChar = str . charAt ( i ); //Do something here }","title":"Parsing a String"},{"location":"lead/assess/L2/#substrings","text":"Suppose you want to return a slice of a string, known as a substring, such as the first letter four letters of String s = \"Raider Robotix\" ; . An easy-to-understand way would be to use string parsing, similar to what we did above: String s = \"Raider Robotix\" ; String result = \"\" ; // an empty string for ( int i = 0 ; i < 4 && i < s . length (); i ++ ){ result += s . charAt ( i ); } System . out . println ( result ); This would print out Raid . Note that the expression i < s . length () was still present in the exit condition in order to prevent errors if s was an input string that was less than four characters long. However, a faster way to get result would be to use the substring ( beginIndex , endIndex ) method, in which beginIndex and endIndex are integers that represent the indicies that you want to search. Similar to the for loop above, beginIndex is inclusive, while endIndex is exclusive. Here are some examples: s . substring ( 0 , 4 ); returns Raid s . substring ( 7 , s . length ()); returns Robotix \"hamburger\" . substring ( 4 , 8 ); returns urge","title":"Substrings"},{"location":"lead/assess/L2/#miscellaneous-string-functions","text":"Assume that String s = \"Hello\" ; is declared in the following examples: s . toLowerCase (); returns hello s . toUpperCase (); returns HELLO s . indexOf ( \"l\" ); returns 2 (the first occurence of l in s ), while s . lastIndexOf ( \"l\" ) returns 3 s . concat ( \"world\" ); returns Helloworld As mentioned before, string equality is checked with s . equals ( \"Hello\" ); , which would return true . On the other hand, after declaring String anotherString = \"Hello\" ; , the boolean expression s == anotherString || s == \"Hello\" would be false , as string are objects , not primitives . Exercises * Write a program to reverse a string if it has an R in it. * Write a program to check if a string is a palindrome (reads the same backward as forward, such as racecar) * Write a program to replaces all commas from a string with semicolons","title":"Miscellaneous String Functions"},{"location":"lead/assess/L2/#the-math-class","text":"The Math class contains several methods that you may find helpful. It is imported by default, and documentation is found here . For these examples, we will declare double a = 4.5 , b = - 2.5 ; Math . abs ( b ) : takes the absolute value of a number, returns 2.5 in the example Math . ceil ( a ) : takes the ceiling of a number (rounds it up if it is a decimal), returns 5 in the example Math . floor ( a ) : takes the floor of a number (rounds it down if it is a decimal), returns 4 in the example Math . pow ( a - 0.5 , - b + 0.5 ) : takes the first number to the power of the second number, returns 125.0 in the example Math . sqrt ( a - 0.5 ) : takes the square root of a number, returns 2.0 in this example Math . PI : returns the value of pi (3.141592653589793) Math . random () : returns a random double in the interval [0.0, 1.0). This can be used to generate a random integer within a particular range by clamping the number down, then casting it to an int . For example, if you want a random integer in the interval [ lower , upper ], you would declare int randInt = ( int ) ( Math . random () * ( upper - lower )) + lower ; . Try it out! Exercises * Write a program that solves quadratic equations of the form 0=ax^2+bx+c for x, where a, b, and c are coefficients given by the user * Write a program that calculates the average of a data set, given the numbers in the set and its length * Write a program to find the surface area and volume of a square pyramid, given its side length and height * Write a program to round a number to a specific number of decimal places","title":"The Math Class"},{"location":"lead/assess/L2/#assignment","text":"Complete the \"Raider Robotix Printer\" and \"Binary Converter\" programs on HackerRank.","title":"Assignment"},{"location":"lead/assess/L3/","text":"Lesson 3 - Methods Here's a short lesson on one of the building blocks of Java that will prepare you for object-orientated programming: methods. Method signature A method (also known as a function in other languages) is essentially a function, very similar to one that you would encounter in math class. It has an input, an output, and a name (or identifier), though these must have specific data types (think a limited domain/range). Here is a sample method ( isEven ) being declared within a class: public class Example { public boolean isEven ( int num ){ if ( num % 2 == 0 ){ return true ; } return false ; } public static void main ( String [] args ){ //main method //code executed here first } } In this example, the method signature is simply public boolean isEven ( int num ) . It consists of visibility modifiers ( public , private , protected , etc.), a return type ( boolean ), a method identifier ( isEven ), and a set of parameters ( int num ). These parameters must each have a datatype, followed by an identifier, similar to declaring a variable. To list multiple parameters, list each one individually within the parentheses, then separate them with a comma, like in the following example: public int getNumRpPowerUp ( int redScore , int blueScore , boolean autoQuestComplete , int numClimbs , boolean levitateUsed ){ int totalRp = 0 ; if ( redScore > blueScore ) totalRp += 2 ; if ( redScore == blueScore ) totalRp ++ ; if ( autoQuestComplete ) totalRp ++ if ( numClimbs == 3 || numClimbs == 2 && levitateUsed ) totalRp ++ return totalRp ; } Note that a value with the same type as the specified return type ( int in this case) must be returned by the method. This is accomplished by typing the word return followed by a variable or literal value of the specified return type. For instance, the statement return 0 ; would be valid in getNumRpPowerUp as well. Note that the method immediately ends once a return statement is executed. It it possible for a method to have no parameters and/or return type as well. With no parameters, simply leave the contents of the parentheses following the method name blank: public String getInfoString (){ return \"Hello World!\" ; } If you don't want to return a value from the method, the return type should be specified as void . A return statement is not necessary: public void printInfo ( int currentMatchNum , String scoutName ){ System . out . println ( scoutName + \" - Match \" + currentMatchNum ); } You've already used methods to find properties of an object or to compute values, such as with str . length () or Math . pow ( base , power ) . In general, a method call is accomplished by typing the method name, followed by its parameters. The return value (if there is one) can then be used, either within a conditional statement, loop, or assigned to a variable: int red = 200 , blue = 30 , climbs = 1 ; boolean levitated = true ; int rpGained = getNumRpPowerUp ( red , blue , true , climbs , levitated ); while ( isEven ( rpGained )){ //do something } Why methods? So, why are methods so important if they're just executing a block of pre-written code? Well, creating multiple methods in an application or program allows you to break down a problem and do certain tasks repeatedly. For instance, if you wanted to test if a series of numbers were even in different parts of a program, it would be easier to make a call to isEven ( num ) rather than remembering that if a number mod 2 is 0, it is even. Another way to structure an application is to have methods responsible for specific tasks, such as saving a file or verifying if a password matches the one that was stored. As long as you test a method after you write it and ensure it gives the correct output for a variety of input parameters, you can use it throughout an application without needing to refer back to the actual method's source code. That also makes it easy to collaborate with each other, as each person working on a project could be responsible for writing and testing one method; as long as those work independently, you could implement them together in the final product. Overloading methods Sometimes, a method should be able to have different set of parameters, of different data types. In this case, the parameter list will need to be modfied: public double average ( int num1 , int num2 ){ return ( num1 + num2 ) / 2.0 ; } public double average ( double a , double b ){ return ( a + b ) / 2.0 ; } Depending on the datatypes of the parameters when you make the method call, the compiler will know which method to execute. Note that the return type for a particular method name must always be the same, and a method cannot be overloaded if its signature is otherwise identical (parameters have the same datatypes, in the same order). Recursion Like in math, methods can call themselves or other methods within the body of their code. For instance, the following returns the n th Fibonacci number (1, 1, 2, 3, 5, ...): int fib ( int n ){ if ( n == 1 ) return 1 ; if ( n == 2 ) return 1 ; return fib ( n - 1 ) + fib ( n - 2 ); } Recursion is useful for creating simple methods, but their running time can sometimes be slow, and you must always ensure that you reach a base case ( n == 1 or n == 2 in this example) that returns a literal value. Refer to the binary search method if you want to see a more complex example of recursion. Algorithmic challenges Do as many as you want, until you get a good feel of when to implement methods and how to break down a problem: Write a recursive method to compute the factorial of a number. Note that 0! is equal to 1. Write a program that takes any English sentence without punctuation as an input, then converts it to Pig Latin . Implement a more efficient (non-recursive) algorithm to find the n th Fibonacci number Determine the sum of all prime numbers from 2 to a number specified by the user. A number is superb if and only if the sum of all of its factors (excluding itself) is less than a number. Write a program to determine the number of superb numbers between two numbers (e.g. 1 and 100) that are specified by the user. Given a series of variable identifiers in camelCase, identify the number of actual words in the string (e.g. numberOfRankingPoints has four actual words). Given the length of a set of integers S, followed the elements (numbers) of S, determine if S contains only consecutive integers, without repeats (e.g. {3, 5, 4, 6} does, while {6, 4, 3} and {1, 2, 2, 3} do not). Given a series of lowercase strings without spaces or punctuation, determine if any two adjacent strings (inputted right after each other) are anagrams of each other. Write a program to determine if a number is a palindrome. Write methods that compute the least common multiple and greatest common factor of two positive integers. Please email or DM me via Slack any challenges that you finish for feedback!","title":"Lesson 3: Week Zero"},{"location":"lead/assess/L3/#lesson-3-methods","text":"Here's a short lesson on one of the building blocks of Java that will prepare you for object-orientated programming: methods.","title":"Lesson 3 - Methods"},{"location":"lead/assess/L3/#method-signature","text":"A method (also known as a function in other languages) is essentially a function, very similar to one that you would encounter in math class. It has an input, an output, and a name (or identifier), though these must have specific data types (think a limited domain/range). Here is a sample method ( isEven ) being declared within a class: public class Example { public boolean isEven ( int num ){ if ( num % 2 == 0 ){ return true ; } return false ; } public static void main ( String [] args ){ //main method //code executed here first } } In this example, the method signature is simply public boolean isEven ( int num ) . It consists of visibility modifiers ( public , private , protected , etc.), a return type ( boolean ), a method identifier ( isEven ), and a set of parameters ( int num ). These parameters must each have a datatype, followed by an identifier, similar to declaring a variable. To list multiple parameters, list each one individually within the parentheses, then separate them with a comma, like in the following example: public int getNumRpPowerUp ( int redScore , int blueScore , boolean autoQuestComplete , int numClimbs , boolean levitateUsed ){ int totalRp = 0 ; if ( redScore > blueScore ) totalRp += 2 ; if ( redScore == blueScore ) totalRp ++ ; if ( autoQuestComplete ) totalRp ++ if ( numClimbs == 3 || numClimbs == 2 && levitateUsed ) totalRp ++ return totalRp ; } Note that a value with the same type as the specified return type ( int in this case) must be returned by the method. This is accomplished by typing the word return followed by a variable or literal value of the specified return type. For instance, the statement return 0 ; would be valid in getNumRpPowerUp as well. Note that the method immediately ends once a return statement is executed. It it possible for a method to have no parameters and/or return type as well. With no parameters, simply leave the contents of the parentheses following the method name blank: public String getInfoString (){ return \"Hello World!\" ; } If you don't want to return a value from the method, the return type should be specified as void . A return statement is not necessary: public void printInfo ( int currentMatchNum , String scoutName ){ System . out . println ( scoutName + \" - Match \" + currentMatchNum ); } You've already used methods to find properties of an object or to compute values, such as with str . length () or Math . pow ( base , power ) . In general, a method call is accomplished by typing the method name, followed by its parameters. The return value (if there is one) can then be used, either within a conditional statement, loop, or assigned to a variable: int red = 200 , blue = 30 , climbs = 1 ; boolean levitated = true ; int rpGained = getNumRpPowerUp ( red , blue , true , climbs , levitated ); while ( isEven ( rpGained )){ //do something }","title":"Method signature"},{"location":"lead/assess/L3/#why-methods","text":"So, why are methods so important if they're just executing a block of pre-written code? Well, creating multiple methods in an application or program allows you to break down a problem and do certain tasks repeatedly. For instance, if you wanted to test if a series of numbers were even in different parts of a program, it would be easier to make a call to isEven ( num ) rather than remembering that if a number mod 2 is 0, it is even. Another way to structure an application is to have methods responsible for specific tasks, such as saving a file or verifying if a password matches the one that was stored. As long as you test a method after you write it and ensure it gives the correct output for a variety of input parameters, you can use it throughout an application without needing to refer back to the actual method's source code. That also makes it easy to collaborate with each other, as each person working on a project could be responsible for writing and testing one method; as long as those work independently, you could implement them together in the final product.","title":"Why methods?"},{"location":"lead/assess/L3/#overloading-methods","text":"Sometimes, a method should be able to have different set of parameters, of different data types. In this case, the parameter list will need to be modfied: public double average ( int num1 , int num2 ){ return ( num1 + num2 ) / 2.0 ; } public double average ( double a , double b ){ return ( a + b ) / 2.0 ; } Depending on the datatypes of the parameters when you make the method call, the compiler will know which method to execute. Note that the return type for a particular method name must always be the same, and a method cannot be overloaded if its signature is otherwise identical (parameters have the same datatypes, in the same order).","title":"Overloading methods"},{"location":"lead/assess/L3/#recursion","text":"Like in math, methods can call themselves or other methods within the body of their code. For instance, the following returns the n th Fibonacci number (1, 1, 2, 3, 5, ...): int fib ( int n ){ if ( n == 1 ) return 1 ; if ( n == 2 ) return 1 ; return fib ( n - 1 ) + fib ( n - 2 ); } Recursion is useful for creating simple methods, but their running time can sometimes be slow, and you must always ensure that you reach a base case ( n == 1 or n == 2 in this example) that returns a literal value. Refer to the binary search method if you want to see a more complex example of recursion.","title":"Recursion"},{"location":"lead/assess/L3/#algorithmic-challenges","text":"Do as many as you want, until you get a good feel of when to implement methods and how to break down a problem: Write a recursive method to compute the factorial of a number. Note that 0! is equal to 1. Write a program that takes any English sentence without punctuation as an input, then converts it to Pig Latin . Implement a more efficient (non-recursive) algorithm to find the n th Fibonacci number Determine the sum of all prime numbers from 2 to a number specified by the user. A number is superb if and only if the sum of all of its factors (excluding itself) is less than a number. Write a program to determine the number of superb numbers between two numbers (e.g. 1 and 100) that are specified by the user. Given a series of variable identifiers in camelCase, identify the number of actual words in the string (e.g. numberOfRankingPoints has four actual words). Given the length of a set of integers S, followed the elements (numbers) of S, determine if S contains only consecutive integers, without repeats (e.g. {3, 5, 4, 6} does, while {6, 4, 3} and {1, 2, 2, 3} do not). Given a series of lowercase strings without spaces or punctuation, determine if any two adjacent strings (inputted right after each other) are anagrams of each other. Write a program to determine if a number is a palindrome. Write methods that compute the least common multiple and greatest common factor of two positive integers. Please email or DM me via Slack any challenges that you finish for feedback!","title":"Algorithmic challenges"},{"location":"lead/assess/L4/","text":"Lesson 4 - Object Orientated Design We explored String s in previous lessons, which was your first look at an object in Java. In fact, you've been writing programs inside of a main function, which is a method inside a function! In this lesson, we'll see what an object really is and why they're so useful. Why objects? Objects have both state , variables that remain constant until you modify them, and behavior , which are seen through callable methods that either feed your main method information about that object or operate on its state. As programmers, you need to design objects so that their state and behavior are appropriate for what you're trying to accomplish, while breaking down code into testable and understandable building blocks. It's probably easiest to think of an object like an object in the real world, such as a person or a dog. It could have states like a name, age, favorite color, and friends. Similarly, a Person object could have behaviors like befriending another person if they have the same favorite color, increasing its age every year, or saying its name. Objects may also want to keep some state variables private , such as a credit card number. These are just examples, but you'll see as we go about modeling a person in this lesson. In essence, objects make programming real-world mechanisms and representing real-world entities a lot easier. You could have a Robot object drive a certain distance, deposit and earn interest in a BankAccount , or read the state of an Actuator on a Robot . Constructors and member variables A class is the blueprint behind an object, which is something you should already be familiar with from writing programs. Each class should generally be in its own . java file, called ClassName . java . It's possible to have multiple classes within a file, but we'll get to that later. Inside Person . java : // Import statements come first import java.util.Scanner ; public class Person { public static void main ( String [] args ){ // do stuff here } } This is probably what you're familiar with right now. Now, we'll add in some fields, called member variables , to the Person class that will help identify it: public class Person { String name , favoriteColor ; int age , numFriends ; } To initialize these attributes, we'll also need a constructor , which is essentially a method that returns an instance of that class while assigning values to as many member variables as you'd like. public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } Note that the identifier for a constructor is simply the name of the class, though the parameters can be any datatype, and there is no return statement. Like other methods, constructors can also be overloaded with arguments of different datatypes. An empty constructor is automatically created if no constructor is declared for a class, which simply doesn't set any member variables. To access member variables, we use the keyword this , referring to the new instance of the object, followed by the dot operator and the identifiers of the variables you want to modify. This also distinguishes the name variable in the parameter of the constructor with the name variable that's part of the object's state. Member variables must be assigned a value, either explicitly through the code of the class or via a constructor, before their value can be accessed. They can also either be objects or primitive values. Declaring objects So, how exactly do you create an object with the constructor? Well, it's similar to declaring any other variable in Java, complete with a datatype and identifier, except you'll need to use the new keyword: public static void main ( String [] args ){ Person mentor = new Person ( \"Cokeley\" ); } This creates an instance of a Person , which is stored in mentor . Now, if you want to access or modify attributes of mentor , you'll use the same dot operator that was used in the constructor: mentor . age = 25 ; System . out . println ( mentor . name + \" is \" + mentor . age + \" years old\" ); This will print out Cokeley is 25 years old . Class methods While having objects as a simple data structure with various attributes is useful, sometimes you want a little more interactivity. That's when we can create our own methods in a class. We can spice up the Person class by adding in the following: public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } boolean makeFriends ( Person possibleFriend ){ if ( possibleFriend . favoriteColor . equals ( this . favoriteColor )){ this . numFriends ++ ; possibleFriend . numFriends ++ ; return true ; } return false ; } } This makeFriends method mutually has two people become friends if their favoriteColor is the same, then returns true if they've become friends, or false otherwise. Another example can be seen with this RightTriangle class: class RightTriangle { double legOne , legTwo , hypotenuse ; RightTriangle ( double side1 , double side2 , double side3 ){ this . hypotenuse = Math . max ( Math . max ( side1 , side2 ), side3 ); this . legOne = Math . min ( Math . min ( side1 , side2 ), side3 ); this . legTwo = side1 + side2 + side3 - this . legOne - this . hypotenuse ; } double getArea (){ return 0.5 * this . legOne * this . legTwo ; } double getPerimeter (){ return this . legOne + this . legTwo + this . hypotenuse ; } // Returns smaller acute angle in radians double getSmallerAngle (){ return Math . atan ( this . legOne / this . legTwo ); } // Returns larger acute angle in radians double getLargerAngle (){ return Math . PI / 2 - this . getSmallerAngle (); } // Extends the length of the shorter leg and // adjusts the length of the hypotenuse accordingly void extendLegOne ( double newLength ){ if ( newLength > this . legTwo ){ this . legOne = this . legTwo ; this . legTwo = newLength ; } else this . legOne = newLength ; this . hypotenuse = Math . sqrt ( Math . pow ( this . legOne , 2 ) + Math . pow ( this . legTwo , 2 )); } } Here, after initializing a RightTriangle object, we can use its different instance methods to get and modify its properties. For instance, executing the following in the main method RightTriangle tri = new RightTriangle ( 4 , 3 , 5 ); System . out . println ( \"Perimeter: \" + tri . getPerimeter ()); System . out . println ( \"Area: \" + tri . getArea ()); System . out . println ( \"Smaller Angle: \" + tri . getSmallestAngle () + \" rad\" ); tri . extendLegOne ( 10 ); System . out . println ( \"New Perimeter: \" + tri . getPerimeter ()); will print Perimeter : 12.0 Area : 6.0 Smallest Angle : 0.6435011087932844 rad New Perimeter : 24.77032961426901 Visibility Sometimes it is desirable to reduce the access and visibility of object methods or instance variables. For example, you generally wouldn't want a main method to be able to change a Person object's name explicitly, or perhaps you want to modify a BankAccount object's balance only through withdrawal and deposit methods, each requiring a PIN code. In that case, it's best to leave member variables private instead of public . To do this, simply put the visibility modifier in front of the variable identifier, like so: public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } That way, private level access only allows those variables to be accessed and modified within the same class (such as within the constructor or other class methods). On the other hand, public level access allows all classes to modify a variable or call a method, while default access (not putting any modifier) only allows classes of the same package to access variables/methods. We'll get into packages later on, but just know that they're ways of grouping similar classes for now. So, how are we supposed to modify and access attributes like favoriteColor so the method makeFriends can still function properly? For the first case, we'll use a special type of method called a setter , while we create a getter to do the latter: private public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } public void setFavoriteColor ( String favoriteColor ){ this . favoriteColor = favoriteColor ; } public String getFavoriteColor (){ return this . favoriteColor ; } } It's pretty simple: a setter has an argument datatype that's the same as the member variable, sets the member variable, then returns nothing. Meanwhile, a getter has the same return type as the member variable, has no parameters, and simply returns the value of the member variable. In fact, these methods are so common (as it's good practice to set variables as private ) that most IDEs (including Eclipse) have a way to automatically generate setters and getters for a class. Finally, static methods and variables are called directly on a class, rather than on an instance of a class. You've already seen examples of these in the Math class: the variable Math . PI and the method Math . pow ( base , exp ) can be called without declaring an instance of a Math object via the new keyword. It's important to note that static variables are shared by all instances of a given class (and thus can be used as temporary storage). Also, static methods cannot access non- static variables or methods. You can make a static method private or public by putting the visibility modifier in front of the word static , such as in public static void main ( String [] args ) . Scope Our last topic is something that we've used throughout this lesson without realizing it; variable identifiers often come in conflict with each other. In that case, which value do we use? The smallest scope is in a loop: for ( int i = 1 ; i < 5 ; i ++ ){ double area = Math . pow ( i , 2 ); } In this case, both i and area have block scope and cannot be modified or accessed outside of the for loop. You'll see that a set of curly braces generally denotes scope. Note that variables with the identifier i or area cannot exist outside of the loop either. Next up are local variables, also known as method scope : public void setSideLength ( int sideLength ){ double squareArea = Math . pow ( sideLength , 2 ); this . sideLength = sideLength ; } Both sideLength and squareArea can be accessed/modified only within the method setSideLength . However, using the keyword this and the dot operator will refer to the member variable sideLength of the class, rather than the one passed in as an argument. All variables other than member variables cannot be accessed outside of a class, which then follow the visibility rules discussed before. HW: Modeling Bank Accounts We've discussed bank accounts throughout this lesson. Now it's time to implement one! Each BankAccount object has the following attributes, which should all be private : balance : a double indicating the amount of money in the bank account. Cannot be negative. pin : a four-digit code that authenticates a user. May contain leading zeroes (i.e. 0000 is a valid PIN) name : the name of the bank account owner interestRate : the percent of interest earned by a user in a given year, shared across all bank accounts Challenge : id : a random, five-digit code that's generated upon the creation of the bank account to identify it. Does not contain leading zeroes. You may want to refer back to the Math . random method from Lesson 2. Methods should be provided to do the following: Construct a BankAccount with a PIN, owner, and initial balance Challenge : Construct a BankAccount with a PIN, owner, and initial balance of $0.00 Get the name of the owner of an account Get the id of the account Change the PIN of the account, given the old PIN and the new PIN. Should return some form of feedback to determine if the PIN was successfully changed Withdraw money from an account, given its PIN and the amount desired. Should indicate if withdrawal was successful and should not allow it if the account doesn't have enough money Deposit a given amount of money into the account Earn interest for the year, based on the interestRate Challenge : Transfer money from one account to another, given another BankAccount object and its PIN You do not need to submit a main method as a driver for your class, though you will need to write one to test if your class works. Next lesson, you'll write one to complete specific tasks when you learn about arrays and HashMaps to create a network of bank accounts. Please email me your completed class or DM me via Slack.","title":"Lesson 4: The Travel Team"},{"location":"lead/assess/L4/#lesson-4-object-orientated-design","text":"We explored String s in previous lessons, which was your first look at an object in Java. In fact, you've been writing programs inside of a main function, which is a method inside a function! In this lesson, we'll see what an object really is and why they're so useful.","title":"Lesson 4 - Object Orientated Design"},{"location":"lead/assess/L4/#why-objects","text":"Objects have both state , variables that remain constant until you modify them, and behavior , which are seen through callable methods that either feed your main method information about that object or operate on its state. As programmers, you need to design objects so that their state and behavior are appropriate for what you're trying to accomplish, while breaking down code into testable and understandable building blocks. It's probably easiest to think of an object like an object in the real world, such as a person or a dog. It could have states like a name, age, favorite color, and friends. Similarly, a Person object could have behaviors like befriending another person if they have the same favorite color, increasing its age every year, or saying its name. Objects may also want to keep some state variables private , such as a credit card number. These are just examples, but you'll see as we go about modeling a person in this lesson. In essence, objects make programming real-world mechanisms and representing real-world entities a lot easier. You could have a Robot object drive a certain distance, deposit and earn interest in a BankAccount , or read the state of an Actuator on a Robot .","title":"Why objects?"},{"location":"lead/assess/L4/#constructors-and-member-variables","text":"A class is the blueprint behind an object, which is something you should already be familiar with from writing programs. Each class should generally be in its own . java file, called ClassName . java . It's possible to have multiple classes within a file, but we'll get to that later. Inside Person . java : // Import statements come first import java.util.Scanner ; public class Person { public static void main ( String [] args ){ // do stuff here } } This is probably what you're familiar with right now. Now, we'll add in some fields, called member variables , to the Person class that will help identify it: public class Person { String name , favoriteColor ; int age , numFriends ; } To initialize these attributes, we'll also need a constructor , which is essentially a method that returns an instance of that class while assigning values to as many member variables as you'd like. public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } Note that the identifier for a constructor is simply the name of the class, though the parameters can be any datatype, and there is no return statement. Like other methods, constructors can also be overloaded with arguments of different datatypes. An empty constructor is automatically created if no constructor is declared for a class, which simply doesn't set any member variables. To access member variables, we use the keyword this , referring to the new instance of the object, followed by the dot operator and the identifiers of the variables you want to modify. This also distinguishes the name variable in the parameter of the constructor with the name variable that's part of the object's state. Member variables must be assigned a value, either explicitly through the code of the class or via a constructor, before their value can be accessed. They can also either be objects or primitive values.","title":"Constructors and member variables"},{"location":"lead/assess/L4/#declaring-objects","text":"So, how exactly do you create an object with the constructor? Well, it's similar to declaring any other variable in Java, complete with a datatype and identifier, except you'll need to use the new keyword: public static void main ( String [] args ){ Person mentor = new Person ( \"Cokeley\" ); } This creates an instance of a Person , which is stored in mentor . Now, if you want to access or modify attributes of mentor , you'll use the same dot operator that was used in the constructor: mentor . age = 25 ; System . out . println ( mentor . name + \" is \" + mentor . age + \" years old\" ); This will print out Cokeley is 25 years old .","title":"Declaring objects"},{"location":"lead/assess/L4/#class-methods","text":"While having objects as a simple data structure with various attributes is useful, sometimes you want a little more interactivity. That's when we can create our own methods in a class. We can spice up the Person class by adding in the following: public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } boolean makeFriends ( Person possibleFriend ){ if ( possibleFriend . favoriteColor . equals ( this . favoriteColor )){ this . numFriends ++ ; possibleFriend . numFriends ++ ; return true ; } return false ; } } This makeFriends method mutually has two people become friends if their favoriteColor is the same, then returns true if they've become friends, or false otherwise. Another example can be seen with this RightTriangle class: class RightTriangle { double legOne , legTwo , hypotenuse ; RightTriangle ( double side1 , double side2 , double side3 ){ this . hypotenuse = Math . max ( Math . max ( side1 , side2 ), side3 ); this . legOne = Math . min ( Math . min ( side1 , side2 ), side3 ); this . legTwo = side1 + side2 + side3 - this . legOne - this . hypotenuse ; } double getArea (){ return 0.5 * this . legOne * this . legTwo ; } double getPerimeter (){ return this . legOne + this . legTwo + this . hypotenuse ; } // Returns smaller acute angle in radians double getSmallerAngle (){ return Math . atan ( this . legOne / this . legTwo ); } // Returns larger acute angle in radians double getLargerAngle (){ return Math . PI / 2 - this . getSmallerAngle (); } // Extends the length of the shorter leg and // adjusts the length of the hypotenuse accordingly void extendLegOne ( double newLength ){ if ( newLength > this . legTwo ){ this . legOne = this . legTwo ; this . legTwo = newLength ; } else this . legOne = newLength ; this . hypotenuse = Math . sqrt ( Math . pow ( this . legOne , 2 ) + Math . pow ( this . legTwo , 2 )); } } Here, after initializing a RightTriangle object, we can use its different instance methods to get and modify its properties. For instance, executing the following in the main method RightTriangle tri = new RightTriangle ( 4 , 3 , 5 ); System . out . println ( \"Perimeter: \" + tri . getPerimeter ()); System . out . println ( \"Area: \" + tri . getArea ()); System . out . println ( \"Smaller Angle: \" + tri . getSmallestAngle () + \" rad\" ); tri . extendLegOne ( 10 ); System . out . println ( \"New Perimeter: \" + tri . getPerimeter ()); will print Perimeter : 12.0 Area : 6.0 Smallest Angle : 0.6435011087932844 rad New Perimeter : 24.77032961426901","title":"Class methods"},{"location":"lead/assess/L4/#visibility","text":"Sometimes it is desirable to reduce the access and visibility of object methods or instance variables. For example, you generally wouldn't want a main method to be able to change a Person object's name explicitly, or perhaps you want to modify a BankAccount object's balance only through withdrawal and deposit methods, each requiring a PIN code. In that case, it's best to leave member variables private instead of public . To do this, simply put the visibility modifier in front of the variable identifier, like so: public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } That way, private level access only allows those variables to be accessed and modified within the same class (such as within the constructor or other class methods). On the other hand, public level access allows all classes to modify a variable or call a method, while default access (not putting any modifier) only allows classes of the same package to access variables/methods. We'll get into packages later on, but just know that they're ways of grouping similar classes for now. So, how are we supposed to modify and access attributes like favoriteColor so the method makeFriends can still function properly? For the first case, we'll use a special type of method called a setter , while we create a getter to do the latter: private public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } public void setFavoriteColor ( String favoriteColor ){ this . favoriteColor = favoriteColor ; } public String getFavoriteColor (){ return this . favoriteColor ; } } It's pretty simple: a setter has an argument datatype that's the same as the member variable, sets the member variable, then returns nothing. Meanwhile, a getter has the same return type as the member variable, has no parameters, and simply returns the value of the member variable. In fact, these methods are so common (as it's good practice to set variables as private ) that most IDEs (including Eclipse) have a way to automatically generate setters and getters for a class. Finally, static methods and variables are called directly on a class, rather than on an instance of a class. You've already seen examples of these in the Math class: the variable Math . PI and the method Math . pow ( base , exp ) can be called without declaring an instance of a Math object via the new keyword. It's important to note that static variables are shared by all instances of a given class (and thus can be used as temporary storage). Also, static methods cannot access non- static variables or methods. You can make a static method private or public by putting the visibility modifier in front of the word static , such as in public static void main ( String [] args ) .","title":"Visibility"},{"location":"lead/assess/L4/#scope","text":"Our last topic is something that we've used throughout this lesson without realizing it; variable identifiers often come in conflict with each other. In that case, which value do we use? The smallest scope is in a loop: for ( int i = 1 ; i < 5 ; i ++ ){ double area = Math . pow ( i , 2 ); } In this case, both i and area have block scope and cannot be modified or accessed outside of the for loop. You'll see that a set of curly braces generally denotes scope. Note that variables with the identifier i or area cannot exist outside of the loop either. Next up are local variables, also known as method scope : public void setSideLength ( int sideLength ){ double squareArea = Math . pow ( sideLength , 2 ); this . sideLength = sideLength ; } Both sideLength and squareArea can be accessed/modified only within the method setSideLength . However, using the keyword this and the dot operator will refer to the member variable sideLength of the class, rather than the one passed in as an argument. All variables other than member variables cannot be accessed outside of a class, which then follow the visibility rules discussed before.","title":"Scope"},{"location":"lead/assess/L4/#hw-modeling-bank-accounts","text":"We've discussed bank accounts throughout this lesson. Now it's time to implement one! Each BankAccount object has the following attributes, which should all be private : balance : a double indicating the amount of money in the bank account. Cannot be negative. pin : a four-digit code that authenticates a user. May contain leading zeroes (i.e. 0000 is a valid PIN) name : the name of the bank account owner interestRate : the percent of interest earned by a user in a given year, shared across all bank accounts Challenge : id : a random, five-digit code that's generated upon the creation of the bank account to identify it. Does not contain leading zeroes. You may want to refer back to the Math . random method from Lesson 2. Methods should be provided to do the following: Construct a BankAccount with a PIN, owner, and initial balance Challenge : Construct a BankAccount with a PIN, owner, and initial balance of $0.00 Get the name of the owner of an account Get the id of the account Change the PIN of the account, given the old PIN and the new PIN. Should return some form of feedback to determine if the PIN was successfully changed Withdraw money from an account, given its PIN and the amount desired. Should indicate if withdrawal was successful and should not allow it if the account doesn't have enough money Deposit a given amount of money into the account Earn interest for the year, based on the interestRate Challenge : Transfer money from one account to another, given another BankAccount object and its PIN You do not need to submit a main method as a driver for your class, though you will need to write one to test if your class works. Next lesson, you'll write one to complete specific tasks when you learn about arrays and HashMaps to create a network of bank accounts. Please email me your completed class or DM me via Slack.","title":"HW: Modeling Bank Accounts"},{"location":"lead/manage/L1/","text":"Lesson 1 - Introduction to Java Raider Robotix and Java FRC Team 25, Raider Robotix , uses the Java programming language for programming both the robot and the scouting system. Java is also taught in NBTHS's computer science courses. These lessons will provide you with the building blocks of Java that are necessary to program, maintain, and understand the scouting system. It currently has two components: * Android scouting app - collects data from scouts during events and exports it in JSON (JavaScript Object Notation) files * Every year, this needs to be updated with the correct metrics, events, game manual, and other options, as necessary * Desktop scouting client - compiles the JSON files from the app and outputs spreadsheets of each scouting entry and aggregated statistics for each team * Every year, this needs to be updated with the correct metrics, which includes averages, percentages, probabilities, and standard deviations, in addition to those in the scouting app Starting from the 2017 season, Tableau is used to visualize and analyze the data from the spreadsheets generated by the client. The goal is to have you understand how the scouting system works and be comfortable with changing its code by next season's kickoff. If you want to work on robot programming instead, additional knowledge of WPILib API will be needed. Lesson Structure Generally, several concepts will be explained and grouped together to form a lesson. As each concept is taught, several practice exercises are given for you to check your understanding. At the end of the lesson, one or two problems will be assigned on HackerRank that test your understanding of all concepts in the lesson. The site allows you to check your program against several test cases and will \"grade\" it (pass or fail) instantly. Java Code Structure Java source files have a . java extension and each contain a class , which acts like an object (we'll get to this later). Each class/source file is located in a package , which acts as a folder to organize various files. Inside an executable program is a main method , in which the code inside it executes. In a desktop Java program, the method signature public static void main ( String [] args ) is used, followed by a set of curly braces. Below is an example inside a file called Example . java : // Place import statements here public class Example { public static void main ( String [] args ){ // Write your code to execute here } } As seen above line comments can be written if they are proceeded with two forward slashes ( // ). Anything following the two slashes will be ignored by the compiler when your program executes. Block comments may also be written like this: /* Hi! * I'm a block comment. */ Note the two slashes showing the beginning/end of the comment and the asterisk on each line. Variables Any data or value you use in Java is stored in a variable . A variable can have one of many different datatypes . The following are common datatypes: * int - an integer with a value between -2^31 - 1 and 2^31 -1 ( 123 , 25 , - 900 , 0 , etc.) * double - a positive or negative decimal number ( 1.23 , - 2.5 , 1.0005 , etc.) * boolean - has either a true or false value * String - a sequence of characters, enclosed in a set of quotation marks ( \"Hello World\" , \"1+1=2\" , \"Raider Robotix\" , etc.) You can declare variables with its datatype, followed by a space and its identifier , then a semicolon. The identifier must start with a letter or underscore, then be followed by more letters, underscores, or numbers, with no spaces. Valid identifiers include: * _t * motor1 * MOTOR_SPEED Generally, variables are named in a camelCase notation, where the first word is lowercase, then the remaining words are uppercase. Examples of variable declarations with camelCase naming include: int teleOpGearsCollected ; double avgKpaPerGame ; boolean baselineCrossed ; String robotComment , pilotComment ; //multiple variables can be declared with a comma separating them On the other hand, variables that are constant throughout a program should be named with only uppercase letters and underscores. Examples of these variables include: double TURN_ANGLE_TOLERANCE ; int LEFT_JOYSTICK_PORT ; String RULES_FILEPATH ; int VERSION_NUMBER ; Keep in mind that variables should not have generic identifiers like x or var1 , but ones that are descriptive. A variable can be assigned a value with its identifier followed by the assignment operator , = , and its value. This value can be literal or that of another variable. A variable may be assigned a value and declared at the same time as well. Some examples: int teleOpGearsCollected ; // declaration double avgHighGoalsTeleOp = 12.555 ; // variable declared and value of 12.555 assigned teleOpGearsCollected = 4 ; // assignment afterwards boolean baselineCrossed = true , readyTakeoff = false ; // two variables declared and assigned value String robotComment = \"This is a good robot\" ; double avgTeleOpKpa = avgHighGoalsTeleOp / 3 ; //value dependent on another variable Output Output to the console in Java can be executed with the following statement : System . out . println ( < some value > ); This calls the println method on a value, where < some value > can be a literal value or a variable. Remember to terminate the print statement with a semicolon. For example, executing System . out . println ( teleOpGearsCollected ); System . out . println ( \"gears collected in tele-op in match\" ); System . out . println ( 25 ); will result in the following output: 4 gears collected in tele - op in match 25 If you don't want a new line after the output, the System . out . print ( < some value > ) method may be used. Executing System . out . print ( teleOpGearsCollected ); System . out . println ( \" gears collected in tele-op.\" ); System . out . println ( \"Robots are cool\" ); will result in the following output: 4 gears collected in tele - op . Robots are cool An IDE An IDE (Integrated Development Environment) will be used to program in Java. It allows you to write code, execute, and debug it in one application. I recommend using Eclipse , as NBTHS and the WPILib API uses it, though alternatives like InteliJ and BlueJ exist. We will be using Android Studio as our IDE for Android development. To get started with Eclipse: 1. Download and extract the ZIP file from the link above 2. Run the executable and choose your workspace (default should work) 3. Go to File > New > Java Project and name your project 4. Close the Welcome window 5. Right click your project and go to New > Class, and name your class (without the . java extension) 6. Write your main method (see above) 7. Try replacing the comment with a statement to print Hello World 8. Press the green \"Play\" button to execute your program If there are any syntax errors in your program, Eclipse will underline them in red, and the program will not run. Try fixing them by reading the error message and reviewing your code or by using Google. A Brief Exercise : Assign the values of true , \"Raider Robotix\" , and 25 to variables. Use print statements with the variables and literal values to generate the output Hello World ! It is true that I am on Team 25 , Raider Robotix 25 is the Team Number . Input To take user input, you will need to use a Scanner object. First, you will need to import the class by placing the following import statement before the class starts (see example above): import java.util.Scanner ; The Scanner object can be declared and constructed like this to read from the system console: Scanner myScanner = new Scanner ( System . in ); The datatype is Scanner , and myScanner can be any valid identifier. Note the use of the new keyword to create a new object and the parentheses following. Several methods can be accessed through the Scanner object for different datatypes. A method essentially acts like a function and returns a value to the main program. These may be used to let users assign values to variables: int anInteger = myScanner . nextInt (); String aLine = myScanner . next (); // takes the next whole line Essentially, the dot operator ( . ) shows that the methods nextInt () and nextLine () are written in the Scanner class, and you are accessing them from an outside class. More methods for input can be found by reading the documentation for the class . If the wrong datatype is used, there will be an error in your program. By default, spaces and line breaks separating tokens in the input will result two different variables. For example, if the input is Raider Robotix executing String teamName = myScanner . next (); System . out . println ( teamName ); will output Raider while executing String teamName = myScanner . nextLine (); System . out . println ( teamName ); will output Raider Robotix Exercise Write a program that allows prompts a user to input a string, an integer, and a floating point number, then print all three once they are inputted. Operators Operators in Java allow you to interact between different datatypes. For these examples, we will declare int a = 5 , b = 4 ; double c = 2.5 ; String s = \"Hello\" ; Mathematical Evaluating these operators will result in a number of type int if both are integers, or of type double if at least one is a double : + - adds the number (an int or double ) to the left and right of it a + b is equal to 9 , a + c is equal to 7.5 - - subtracts the number on the right from the left b - a is equal to - 1 , b - c is equal to 1.5 * - multiplies the number to the left and right of it a * b is equal to 20 , b * c is equal to 10.0 / - divides the number on the left by the number on the right. However, if both numbers are int s, integer division will occur. That is, the remainder is discarded, and only the quotient remains. a / c is equal to 2.0 , b / c is equal to 1.6 a / b is equal to 1 , b / a is equal to 0 A literal int value ( 1 ) may be converted into a double value by adding a decimal point and a zero ( 1.0 ) % - the modulus operator, a % b returns the remainder of a / b a % b is equal to 1 , b % a is equal to 4 , a % c is equal to 0.0 Exercises : * Write a program that allows the user to input (integer) dimensions of a rectangular prism and outputs its surface area and volume * Write a program that prints the day of the week of a day, given the day of the week of the first day of the month (where 1=Monday, 7=Sunday) * Write a program that calculates the score of a match in FIRST Steamworks, where the user inputs the number of rotors activated during tele-op/autonomous, high/low goals in tele-op/autonomous, the times the baseline was crossed, the times robots took off, and foul points that were incurred by the opposing alliance Relational Evaluating these operators will result in a boolean value ( true or false ): < - less than, <= - less than or equal to b < a is true , 4.5 < 0 is false - 2 <= c is true , 5 <= 5 is true > - greater than, >= - greater than or equal to == - checks for equality. This can only be used for primitive datatypes, and not objects a == 5 is true , 2.0 == a / c is true false == true is false For strings, the method someString . equals ( /*another string*/ ) is used for equality because a string is an object. We'll get into this more in the next lesson. s . equals ( \"Hello\" ) is true , s . equals ( \"World\" ) is false != - checks if the two objects are not equal a != 5 is false , 1 != a / c is true false != true is true Exercise : Write a program to determine if it is true that a quadratic equation of the form 0=ax^2+bx+c has a real solution, where the user inputs a, b, and c. (Hint: For now the best way to square an integer x is x * x , as x ^ 2 will not evaluate correctly) Logical These operate on boolean values and evaluating them will also result in a boolean value: OR Operator - written as a || b , evaluates to true only if either a or b are true a b a \\ | \\ | b false false false false true true true false true true true true AND Operator - written as a && b , evaluates to true only if both a and b are true a b a && b false false false false true false true false false true true true NOT Operator - written as !a , evaluates to true only if a is false a !a false true true false Exercises * Evaluate the following expressions (without actually writing any code) for when boolean a = true , b = false and for when boolean a = true , b = true : * ( a || b ) && ( ! a || ! b ) * ! ( a && ! b ) || ( ! a && b ) * ! ( a && b ) Some Shortcuts You already learned about the assignment operator. Here are some shortcuts used for assignment with operators, if x and y are numbers and both are already declared and assigned values: x += y ; // same as x = x+y x -= y ; // same as x = x-y x /= y ; // same as x = x/y x %= y ; // same as x = x % y x ++ ; // same as x+=1 x -- ; // same as x-=1 Exercise : What is the value of x after the following is executed? int x = 60 , y = 10 ; y /= 5 ; x %= x - y ; x ++ ; x *= 4 ; Boolean Expressions A boolean expression is any expression that evaluates to true or false . It may contain literals, variables, and any of the above operators. The order of operations for evaluation are: Parentheses NOT Multiplication, division, modulus Addition, subtraction Greater/less than (or equal to) Equivalence/not equivalent AND OR The following are valid boolean expressions if x and y are numbers and b is a boolean : * x >= 5 + y && ! ( y + 5 == 7 || y < 0 || ! b ) * takeoffPercentage / avgTakeoffPercentage + 0.1 >= 1.2 && ( avgKpa >= 30 || avgGears >= 4 ) && teamNum != 25 && ! droppedGearOften Exercises * The XOR (exclusive-or) operator evaluates to be true if either A or B are true, but not both. Write an expression that is logically equivalent to \"A XOR B\" using the AND, OR, and NOT operators * Write a boolean expression to determine if at least 3 ranking points were earned by the red alliance in a match of FIRST Steamworks, given the scores of both the red and blue alliances, the number of gears delivered by the red alliance, whether or not the reserve gear was used, and the number of high/low goals into the red boiler in autonomous/tele-op. Use appropriate identifiers for variables and declare multiple, intermediate boolean expressions as necessary. Conditionals A conditional statement is one that executes if a particular boolean expression is true. The if , else , and else - if statements are written and used as follows: boolean a = < some expression > ; if ( a ){ //Code here executes if expression a is true } else if ( < some boolean expression b > ){ // Code here executes if expression b is true and a is false } else { // Code here executes if a and b are both false } Note that an if statement may be written without any else statements, but else and else - if statements must follow an if statement or an else statement. The boolean expression may also be placed inside the parentheses, rather than assigning its value to a boolean variable. These conditional statements may also be nested inside each other as follows: boolean a = < some expression > ; boolean b = < some expression > ; boolean c = < some expression > ; if ( a ){ if ( c ){ // Code here executes if a and c are true } else { //Code here executes if a is true and c is false } // Code here executes as long as a is true, no matter what the value of c is } else if ( b ){ // Code here executes if expression b is true and a is false, no matter what the value of c is if ( ! c ){ //Code here executes if a is false, b is true, and c is false } } else { // Code here executes if a and b are both false } Exercises * Write a program to determine if a number is even or odd * Write a program that prints the month, given its numerical value (1 to 12) * Write a program that converts a day of the week to a number (Monday = 1, Sunday = 7) * Write a program that converts feet to yards and vice-versa, depending on what the user wants Assignment Download Eclipse and complete the exercises above as necessary to check your understanding. Afterwards, sign up for a HackerRank account and complete the \"A School Day\" program here . I suggest that you write and test the program on Eclipse, then check if it works on HackerRank.","title":"Lesson 1: Pre-Season"},{"location":"lead/manage/L1/#lesson-1-introduction-to-java","text":"","title":"Lesson 1 - Introduction to Java"},{"location":"lead/manage/L1/#raider-robotix-and-java","text":"FRC Team 25, Raider Robotix , uses the Java programming language for programming both the robot and the scouting system. Java is also taught in NBTHS's computer science courses. These lessons will provide you with the building blocks of Java that are necessary to program, maintain, and understand the scouting system. It currently has two components: * Android scouting app - collects data from scouts during events and exports it in JSON (JavaScript Object Notation) files * Every year, this needs to be updated with the correct metrics, events, game manual, and other options, as necessary * Desktop scouting client - compiles the JSON files from the app and outputs spreadsheets of each scouting entry and aggregated statistics for each team * Every year, this needs to be updated with the correct metrics, which includes averages, percentages, probabilities, and standard deviations, in addition to those in the scouting app Starting from the 2017 season, Tableau is used to visualize and analyze the data from the spreadsheets generated by the client. The goal is to have you understand how the scouting system works and be comfortable with changing its code by next season's kickoff. If you want to work on robot programming instead, additional knowledge of WPILib API will be needed.","title":"Raider Robotix and Java"},{"location":"lead/manage/L1/#lesson-structure","text":"Generally, several concepts will be explained and grouped together to form a lesson. As each concept is taught, several practice exercises are given for you to check your understanding. At the end of the lesson, one or two problems will be assigned on HackerRank that test your understanding of all concepts in the lesson. The site allows you to check your program against several test cases and will \"grade\" it (pass or fail) instantly.","title":"Lesson Structure"},{"location":"lead/manage/L1/#java-code-structure","text":"Java source files have a . java extension and each contain a class , which acts like an object (we'll get to this later). Each class/source file is located in a package , which acts as a folder to organize various files. Inside an executable program is a main method , in which the code inside it executes. In a desktop Java program, the method signature public static void main ( String [] args ) is used, followed by a set of curly braces. Below is an example inside a file called Example . java : // Place import statements here public class Example { public static void main ( String [] args ){ // Write your code to execute here } } As seen above line comments can be written if they are proceeded with two forward slashes ( // ). Anything following the two slashes will be ignored by the compiler when your program executes. Block comments may also be written like this: /* Hi! * I'm a block comment. */ Note the two slashes showing the beginning/end of the comment and the asterisk on each line.","title":"Java Code Structure"},{"location":"lead/manage/L1/#variables","text":"Any data or value you use in Java is stored in a variable . A variable can have one of many different datatypes . The following are common datatypes: * int - an integer with a value between -2^31 - 1 and 2^31 -1 ( 123 , 25 , - 900 , 0 , etc.) * double - a positive or negative decimal number ( 1.23 , - 2.5 , 1.0005 , etc.) * boolean - has either a true or false value * String - a sequence of characters, enclosed in a set of quotation marks ( \"Hello World\" , \"1+1=2\" , \"Raider Robotix\" , etc.) You can declare variables with its datatype, followed by a space and its identifier , then a semicolon. The identifier must start with a letter or underscore, then be followed by more letters, underscores, or numbers, with no spaces. Valid identifiers include: * _t * motor1 * MOTOR_SPEED Generally, variables are named in a camelCase notation, where the first word is lowercase, then the remaining words are uppercase. Examples of variable declarations with camelCase naming include: int teleOpGearsCollected ; double avgKpaPerGame ; boolean baselineCrossed ; String robotComment , pilotComment ; //multiple variables can be declared with a comma separating them On the other hand, variables that are constant throughout a program should be named with only uppercase letters and underscores. Examples of these variables include: double TURN_ANGLE_TOLERANCE ; int LEFT_JOYSTICK_PORT ; String RULES_FILEPATH ; int VERSION_NUMBER ; Keep in mind that variables should not have generic identifiers like x or var1 , but ones that are descriptive. A variable can be assigned a value with its identifier followed by the assignment operator , = , and its value. This value can be literal or that of another variable. A variable may be assigned a value and declared at the same time as well. Some examples: int teleOpGearsCollected ; // declaration double avgHighGoalsTeleOp = 12.555 ; // variable declared and value of 12.555 assigned teleOpGearsCollected = 4 ; // assignment afterwards boolean baselineCrossed = true , readyTakeoff = false ; // two variables declared and assigned value String robotComment = \"This is a good robot\" ; double avgTeleOpKpa = avgHighGoalsTeleOp / 3 ; //value dependent on another variable","title":"Variables"},{"location":"lead/manage/L1/#output","text":"Output to the console in Java can be executed with the following statement : System . out . println ( < some value > ); This calls the println method on a value, where < some value > can be a literal value or a variable. Remember to terminate the print statement with a semicolon. For example, executing System . out . println ( teleOpGearsCollected ); System . out . println ( \"gears collected in tele-op in match\" ); System . out . println ( 25 ); will result in the following output: 4 gears collected in tele - op in match 25 If you don't want a new line after the output, the System . out . print ( < some value > ) method may be used. Executing System . out . print ( teleOpGearsCollected ); System . out . println ( \" gears collected in tele-op.\" ); System . out . println ( \"Robots are cool\" ); will result in the following output: 4 gears collected in tele - op . Robots are cool","title":"Output"},{"location":"lead/manage/L1/#an-ide","text":"An IDE (Integrated Development Environment) will be used to program in Java. It allows you to write code, execute, and debug it in one application. I recommend using Eclipse , as NBTHS and the WPILib API uses it, though alternatives like InteliJ and BlueJ exist. We will be using Android Studio as our IDE for Android development. To get started with Eclipse: 1. Download and extract the ZIP file from the link above 2. Run the executable and choose your workspace (default should work) 3. Go to File > New > Java Project and name your project 4. Close the Welcome window 5. Right click your project and go to New > Class, and name your class (without the . java extension) 6. Write your main method (see above) 7. Try replacing the comment with a statement to print Hello World 8. Press the green \"Play\" button to execute your program If there are any syntax errors in your program, Eclipse will underline them in red, and the program will not run. Try fixing them by reading the error message and reviewing your code or by using Google. A Brief Exercise : Assign the values of true , \"Raider Robotix\" , and 25 to variables. Use print statements with the variables and literal values to generate the output Hello World ! It is true that I am on Team 25 , Raider Robotix 25 is the Team Number .","title":"An IDE"},{"location":"lead/manage/L1/#input","text":"To take user input, you will need to use a Scanner object. First, you will need to import the class by placing the following import statement before the class starts (see example above): import java.util.Scanner ; The Scanner object can be declared and constructed like this to read from the system console: Scanner myScanner = new Scanner ( System . in ); The datatype is Scanner , and myScanner can be any valid identifier. Note the use of the new keyword to create a new object and the parentheses following. Several methods can be accessed through the Scanner object for different datatypes. A method essentially acts like a function and returns a value to the main program. These may be used to let users assign values to variables: int anInteger = myScanner . nextInt (); String aLine = myScanner . next (); // takes the next whole line Essentially, the dot operator ( . ) shows that the methods nextInt () and nextLine () are written in the Scanner class, and you are accessing them from an outside class. More methods for input can be found by reading the documentation for the class . If the wrong datatype is used, there will be an error in your program. By default, spaces and line breaks separating tokens in the input will result two different variables. For example, if the input is Raider Robotix executing String teamName = myScanner . next (); System . out . println ( teamName ); will output Raider while executing String teamName = myScanner . nextLine (); System . out . println ( teamName ); will output Raider Robotix Exercise Write a program that allows prompts a user to input a string, an integer, and a floating point number, then print all three once they are inputted.","title":"Input"},{"location":"lead/manage/L1/#operators","text":"Operators in Java allow you to interact between different datatypes. For these examples, we will declare int a = 5 , b = 4 ; double c = 2.5 ; String s = \"Hello\" ;","title":"Operators"},{"location":"lead/manage/L1/#mathematical","text":"Evaluating these operators will result in a number of type int if both are integers, or of type double if at least one is a double : + - adds the number (an int or double ) to the left and right of it a + b is equal to 9 , a + c is equal to 7.5 - - subtracts the number on the right from the left b - a is equal to - 1 , b - c is equal to 1.5 * - multiplies the number to the left and right of it a * b is equal to 20 , b * c is equal to 10.0 / - divides the number on the left by the number on the right. However, if both numbers are int s, integer division will occur. That is, the remainder is discarded, and only the quotient remains. a / c is equal to 2.0 , b / c is equal to 1.6 a / b is equal to 1 , b / a is equal to 0 A literal int value ( 1 ) may be converted into a double value by adding a decimal point and a zero ( 1.0 ) % - the modulus operator, a % b returns the remainder of a / b a % b is equal to 1 , b % a is equal to 4 , a % c is equal to 0.0 Exercises : * Write a program that allows the user to input (integer) dimensions of a rectangular prism and outputs its surface area and volume * Write a program that prints the day of the week of a day, given the day of the week of the first day of the month (where 1=Monday, 7=Sunday) * Write a program that calculates the score of a match in FIRST Steamworks, where the user inputs the number of rotors activated during tele-op/autonomous, high/low goals in tele-op/autonomous, the times the baseline was crossed, the times robots took off, and foul points that were incurred by the opposing alliance","title":"Mathematical"},{"location":"lead/manage/L1/#relational","text":"Evaluating these operators will result in a boolean value ( true or false ): < - less than, <= - less than or equal to b < a is true , 4.5 < 0 is false - 2 <= c is true , 5 <= 5 is true > - greater than, >= - greater than or equal to == - checks for equality. This can only be used for primitive datatypes, and not objects a == 5 is true , 2.0 == a / c is true false == true is false For strings, the method someString . equals ( /*another string*/ ) is used for equality because a string is an object. We'll get into this more in the next lesson. s . equals ( \"Hello\" ) is true , s . equals ( \"World\" ) is false != - checks if the two objects are not equal a != 5 is false , 1 != a / c is true false != true is true Exercise : Write a program to determine if it is true that a quadratic equation of the form 0=ax^2+bx+c has a real solution, where the user inputs a, b, and c. (Hint: For now the best way to square an integer x is x * x , as x ^ 2 will not evaluate correctly)","title":"Relational"},{"location":"lead/manage/L1/#logical","text":"These operate on boolean values and evaluating them will also result in a boolean value: OR Operator - written as a || b , evaluates to true only if either a or b are true a b a \\ | \\ | b false false false false true true true false true true true true AND Operator - written as a && b , evaluates to true only if both a and b are true a b a && b false false false false true false true false false true true true NOT Operator - written as !a , evaluates to true only if a is false a !a false true true false Exercises * Evaluate the following expressions (without actually writing any code) for when boolean a = true , b = false and for when boolean a = true , b = true : * ( a || b ) && ( ! a || ! b ) * ! ( a && ! b ) || ( ! a && b ) * ! ( a && b )","title":"Logical"},{"location":"lead/manage/L1/#some-shortcuts","text":"You already learned about the assignment operator. Here are some shortcuts used for assignment with operators, if x and y are numbers and both are already declared and assigned values: x += y ; // same as x = x+y x -= y ; // same as x = x-y x /= y ; // same as x = x/y x %= y ; // same as x = x % y x ++ ; // same as x+=1 x -- ; // same as x-=1 Exercise : What is the value of x after the following is executed? int x = 60 , y = 10 ; y /= 5 ; x %= x - y ; x ++ ; x *= 4 ;","title":"Some Shortcuts"},{"location":"lead/manage/L1/#boolean-expressions","text":"A boolean expression is any expression that evaluates to true or false . It may contain literals, variables, and any of the above operators. The order of operations for evaluation are: Parentheses NOT Multiplication, division, modulus Addition, subtraction Greater/less than (or equal to) Equivalence/not equivalent AND OR The following are valid boolean expressions if x and y are numbers and b is a boolean : * x >= 5 + y && ! ( y + 5 == 7 || y < 0 || ! b ) * takeoffPercentage / avgTakeoffPercentage + 0.1 >= 1.2 && ( avgKpa >= 30 || avgGears >= 4 ) && teamNum != 25 && ! droppedGearOften Exercises * The XOR (exclusive-or) operator evaluates to be true if either A or B are true, but not both. Write an expression that is logically equivalent to \"A XOR B\" using the AND, OR, and NOT operators * Write a boolean expression to determine if at least 3 ranking points were earned by the red alliance in a match of FIRST Steamworks, given the scores of both the red and blue alliances, the number of gears delivered by the red alliance, whether or not the reserve gear was used, and the number of high/low goals into the red boiler in autonomous/tele-op. Use appropriate identifiers for variables and declare multiple, intermediate boolean expressions as necessary.","title":"Boolean Expressions"},{"location":"lead/manage/L1/#conditionals","text":"A conditional statement is one that executes if a particular boolean expression is true. The if , else , and else - if statements are written and used as follows: boolean a = < some expression > ; if ( a ){ //Code here executes if expression a is true } else if ( < some boolean expression b > ){ // Code here executes if expression b is true and a is false } else { // Code here executes if a and b are both false } Note that an if statement may be written without any else statements, but else and else - if statements must follow an if statement or an else statement. The boolean expression may also be placed inside the parentheses, rather than assigning its value to a boolean variable. These conditional statements may also be nested inside each other as follows: boolean a = < some expression > ; boolean b = < some expression > ; boolean c = < some expression > ; if ( a ){ if ( c ){ // Code here executes if a and c are true } else { //Code here executes if a is true and c is false } // Code here executes as long as a is true, no matter what the value of c is } else if ( b ){ // Code here executes if expression b is true and a is false, no matter what the value of c is if ( ! c ){ //Code here executes if a is false, b is true, and c is false } } else { // Code here executes if a and b are both false } Exercises * Write a program to determine if a number is even or odd * Write a program that prints the month, given its numerical value (1 to 12) * Write a program that converts a day of the week to a number (Monday = 1, Sunday = 7) * Write a program that converts feet to yards and vice-versa, depending on what the user wants","title":"Conditionals"},{"location":"lead/manage/L1/#assignment","text":"Download Eclipse and complete the exercises above as necessary to check your understanding. Afterwards, sign up for a HackerRank account and complete the \"A School Day\" program here . I suggest that you write and test the program on Eclipse, then check if it works on HackerRank.","title":"Assignment"},{"location":"lead/manage/L2/","text":"Lesson 2 - Loops, Strings, Math After a (probably pretty long) first lesson, let's explore a couple more features of Java and see what you can do with everything that you learned. Loops Loops are used to execute a block of code enclosed in a set of braces ( {} ) multiple times. After all, computers are very good at doing the same thing over and over again! The number of times a block executes depends on a boolean expression. while Loops while loops execute as long as a boolean expression is true . It may not execute at all if the expression is false before entering the loop. while ( /*some boolean expression*/ ){ //Execute code here multiple times as long as the expression is true } Remember that the boolean expression should become false at some point during the execution of the code in the loop. Otherwise, an infinite loop will be created. For example, the following will print the numbers from 1 to 10 (inclusive): int counter = 1 ; while ( counter <= 10 ){ System . out . println ( counter ); counter ++ ; } do - while loops may also be written. The main difference between these and while loops is that the boolean expression must be true at the end of the loop, not at the beginning. The following prints the numbers from 1 to 10 (inclusive): int counter = - 1 ; do { counter ++ ; System . out . println ( counter ); } while ( counter < 10 ); for Loops for loops provide a more controlled way for iterating through a loop multiple times. There are three components to the for loop: the initial statement, the exit condition (boolean expression), and the post-excution statement. The example for ( /*initial statement*/ ; /*exit condition*/ ; /*post-execution statement*/ ){ //Code to be executed each loop } is essentially equal to the following while loop: //Initial statement while ( /*exit condition*/ ){ //Code to be executed each loop //Post-execution statement } The for loop is commonly used to execute a loop a certain number of times. Below, the loop prints the numbers from 0 to 9 (10 iterations): for ( int count = 0 ; i < 10 ; count ++ ){ System . out . println ( count ); } Keep in mind that the variable count is declared within the loop, and it cannot accessed outside it. Loops may also be placed inside each other. For example, executing for ( int row = 1 ; row <= 12 ; row ++ ){ for ( int col = 1 ; col <= 12 ; col ++ ){ System . out . print ( row * col ); System . out . print ( \" \" ); //adds a space } System . out . println (); //line break } will print a (poorly formatted) times table. Note that all three parts of a for loop are optional. That is, a loop like for (;;) { //something } will execute forever. Questions Determine the number of times the following for loops will execute. for ( int i = 4 ; i <= 8 ; i += 2 ) { /*do something*/ } for ( int i = 10 ; i >= 0 ; i -= 3 ) { /*do something*/ } for ( int j = 2 ; j >= 4 ; j ++ ) { /*do something*/ } Exercises Write a program that computes the sum of all odd integers from 1 to a number specified by the user Write a program that computes b^e (a number raised to the power of an exponent), where b and e are positive integers Write a program that allows the user to enter a number, setSize . setSize numbers, num , follow and are inputted by the user. Print the average, largest, and smallest of the numbers. Loop Control There are two control statements that are used with loops: break The break statement will immediately exit a while or for loop. This can be useful if you're looking for a specific value, and you want the loop to end after you've found that value. For instance, in the below example, the loop will terminate immediately after the value key is found: int key = 8 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( i == key ) { System . out . println ( \"Found\" ); break ; } System . out . println ( \"Not found...\" ); } As a result, Not found ... will be printed out eight times at first, followed by Found . The loop will then terminate. The break statement will be more useful after you learn about arrays. continue The continue statement will immediately go to the next iteration of a for or while loop, bypassing all statements after it. This could be used when you only want to execute a loop for some values. Of course, an if - else statement can often accomplish the same thing, but break and continue statements can prevent too many nested blocks of code. For instance, the following block of code for ( int i = 0 ; i < 4 ; i ++ ) { System . out . println ( \"Going... \" + i ); if ( i >= 2 ) { continue ; } System . out . println ( \"Here\" ); } will print Going ... 0 Here Going ... 1 Here Going ... 2 Going ... 3 Characters In addition to the primitive data types ( boolean , int , double ) we learned about before, char s represent one of the 256 ASCII characters . These include the numbers, standard symbols and punctuation on a keyboard, and both uppercase and lowercase letters. A char is assigned a value with the declaration char allianceColor = 'R' ; Note the use of single quotation marks rather than double quotation marks (which are used for String s) and that a variable of type char may only contain a single character. Escape characters are the first 32 ASCII characters, which serve special functions. The most commonly used is '\\n' , which creates a line break. In addition, quotation marks must be escaped. Thus, executing the following code char quote1 = '\\'' ; char quote2 = '\\\"' ; char newLine = '\\n' System . out . print ( quote1 ); System . out . print ( newLine ); System . out . print ( quote2 ); will print ' \" Note that strings can be thought of as a series of char s concatenated together. For instance, executing String someText = \"Kickoff, 2017 \\n As we anticipated the new game, the livestream blared, \\\" STEAM POWERED! STEAM POWERED! STEAM POWERED! \\\" \" ; System . out . println ( someText ); will print Kickoff , 2017 As we anticipated the new game , the livestream blared , \"STEAM POWERED! STEAM POWERED! STEAM POWERED!\" The value of characters may be compared with the equivalence ( == ) operator. For example, allianceColor == 'R' is true . Note, however, that a character is not equal its int equivalent. That is, '1' == 1 is false . String Manipulation The String class in Java contains many methods to manipulate strings. We will present an overview of the most useful ones, though you may read the full documentation here . Concatenation A string can be concatenated , or joined together, with other strings or primitive datatypes (and literals) with the + operator. For example, executing the following: String mascot = \"Raider\" ; int teamNum = 25 ; String teamName = mascot + \" Robotix\" ; System . out . println ( \"The year is \" + 2017 ); System . out . println ( \"I am on Team \" + teamNum + \", \" + teamName ); will print The year is 2017 I am on Team 25 , Raider Robotix You may also concatenate a string onto the end of another with the += operator. Executing String s = \"Hello\" ; s += \" World!\" ; System . out . println ( s ); will print Hello World ! . String Properties You can check the length of a string (number of characters) with the string . length () method. Executing String s = \"Hello\" ; System . out . println ( s + \" is \" + s . length () + \" characters long\" ); System . out . print ( \"World!\" . length ()); will print Hello is 5 characters long 6 You can also check if a string contains a specific character sequence with the string . contains ( < character sequence > ) method, which returns a boolean value. If String s = \"Hello\" ; is declared, s . contains ( \"ell\" ) returns true , while s . contains ( \"f\" ) returns false . Parsing a String You may want to parse through a string sometimes, or check the sequence of its characters. The string . charAt ( /*index*/ ) method will return the character currently at the index. There are two things you should know about the method: The method will return a value of type char (character), rather than String . The index is a value that is greater than or equal to 0 and less than string . length () . That is, the index of the first character in the string is 0 , and the index of the last character in the string is string . length () - 1 . If String s = \"World\" ; is declared, s . charAt ( 0 ) returns 'W' , s . charAt ( 3 ) returns 'l' , and s . charAt ( 4 ) returns 'd' . A standard way to parse through all of the characters of a string is with the following for loop: String str = \"Hello World!\" ; for ( int i = 0 ; i < str . length (); i ++ ){ char currentChar = str . charAt ( i ); //Do something here } Substrings Suppose you want to return a slice of a string, known as a substring, such as the first letter four letters of String s = \"Raider Robotix\" ; . An easy-to-understand way would be to use string parsing, similar to what we did above: String s = \"Raider Robotix\" ; String result = \"\" ; // an empty string for ( int i = 0 ; i < 4 && i < s . length (); i ++ ){ result += s . charAt ( i ); } System . out . println ( result ); This would print out Raid . Note that the expression i < s . length () was still present in the exit condition in order to prevent errors if s was an input string that was less than four characters long. However, a faster way to get result would be to use the substring ( beginIndex , endIndex ) method, in which beginIndex and endIndex are integers that represent the indicies that you want to search. Similar to the for loop above, beginIndex is inclusive, while endIndex is exclusive. Here are some examples: s . substring ( 0 , 4 ); returns Raid s . substring ( 7 , s . length ()); returns Robotix \"hamburger\" . substring ( 4 , 8 ); returns urge Miscellaneous String Functions Assume that String s = \"Hello\" ; is declared in the following examples: s . toLowerCase (); returns hello s . toUpperCase (); returns HELLO s . indexOf ( \"l\" ); returns 2 (the first occurence of l in s ), while s . lastIndexOf ( \"l\" ) returns 3 s . concat ( \"world\" ); returns Helloworld As mentioned before, string equality is checked with s . equals ( \"Hello\" ); , which would return true . On the other hand, after declaring String anotherString = \"Hello\" ; , the boolean expression s == anotherString || s == \"Hello\" would be false , as string are objects , not primitives . Exercises * Write a program to reverse a string if it has an R in it. * Write a program to check if a string is a palindrome (reads the same backward as forward, such as racecar) * Write a program to replaces all commas from a string with semicolons The Math Class The Math class contains several methods that you may find helpful. It is imported by default, and documentation is found here . For these examples, we will declare double a = 4.5 , b = - 2.5 ; Math . abs ( b ) : takes the absolute value of a number, returns 2.5 in the example Math . ceil ( a ) : takes the ceiling of a number (rounds it up if it is a decimal), returns 5 in the example Math . floor ( a ) : takes the floor of a number (rounds it down if it is a decimal), returns 4 in the example Math . pow ( a - 0.5 , - b + 0.5 ) : takes the first number to the power of the second number, returns 125.0 in the example Math . sqrt ( a - 0.5 ) : takes the square root of a number, returns 2.0 in this example Math . PI : returns the value of pi (3.141592653589793) Math . random () : returns a random double in the interval [0.0, 1.0). This can be used to generate a random integer within a particular range by clamping the number down, then casting it to an int . For example, if you want a random integer in the interval [ lower , upper ], you would declare int randInt = ( int ) ( Math . random () * ( upper - lower )) + lower ; . Try it out! Exercises * Write a program that solves quadratic equations of the form 0=ax^2+bx+c for x, where a, b, and c are coefficients given by the user * Write a program that calculates the average of a data set, given the numbers in the set and its length * Write a program to find the surface area and volume of a square pyramid, given its side length and height * Write a program to round a number to a specific number of decimal places Assignment Complete the \"Raider Robotix Printer\" and \"Binary Converter\" programs on HackerRank.","title":"Lesson 2: Kickoff!"},{"location":"lead/manage/L2/#lesson-2-loops-strings-math","text":"After a (probably pretty long) first lesson, let's explore a couple more features of Java and see what you can do with everything that you learned.","title":"Lesson 2 - Loops, Strings, Math"},{"location":"lead/manage/L2/#loops","text":"Loops are used to execute a block of code enclosed in a set of braces ( {} ) multiple times. After all, computers are very good at doing the same thing over and over again! The number of times a block executes depends on a boolean expression.","title":"Loops"},{"location":"lead/manage/L2/#while-loops","text":"while loops execute as long as a boolean expression is true . It may not execute at all if the expression is false before entering the loop. while ( /*some boolean expression*/ ){ //Execute code here multiple times as long as the expression is true } Remember that the boolean expression should become false at some point during the execution of the code in the loop. Otherwise, an infinite loop will be created. For example, the following will print the numbers from 1 to 10 (inclusive): int counter = 1 ; while ( counter <= 10 ){ System . out . println ( counter ); counter ++ ; } do - while loops may also be written. The main difference between these and while loops is that the boolean expression must be true at the end of the loop, not at the beginning. The following prints the numbers from 1 to 10 (inclusive): int counter = - 1 ; do { counter ++ ; System . out . println ( counter ); } while ( counter < 10 );","title":"while Loops"},{"location":"lead/manage/L2/#for-loops","text":"for loops provide a more controlled way for iterating through a loop multiple times. There are three components to the for loop: the initial statement, the exit condition (boolean expression), and the post-excution statement. The example for ( /*initial statement*/ ; /*exit condition*/ ; /*post-execution statement*/ ){ //Code to be executed each loop } is essentially equal to the following while loop: //Initial statement while ( /*exit condition*/ ){ //Code to be executed each loop //Post-execution statement } The for loop is commonly used to execute a loop a certain number of times. Below, the loop prints the numbers from 0 to 9 (10 iterations): for ( int count = 0 ; i < 10 ; count ++ ){ System . out . println ( count ); } Keep in mind that the variable count is declared within the loop, and it cannot accessed outside it. Loops may also be placed inside each other. For example, executing for ( int row = 1 ; row <= 12 ; row ++ ){ for ( int col = 1 ; col <= 12 ; col ++ ){ System . out . print ( row * col ); System . out . print ( \" \" ); //adds a space } System . out . println (); //line break } will print a (poorly formatted) times table. Note that all three parts of a for loop are optional. That is, a loop like for (;;) { //something } will execute forever. Questions Determine the number of times the following for loops will execute. for ( int i = 4 ; i <= 8 ; i += 2 ) { /*do something*/ } for ( int i = 10 ; i >= 0 ; i -= 3 ) { /*do something*/ } for ( int j = 2 ; j >= 4 ; j ++ ) { /*do something*/ } Exercises Write a program that computes the sum of all odd integers from 1 to a number specified by the user Write a program that computes b^e (a number raised to the power of an exponent), where b and e are positive integers Write a program that allows the user to enter a number, setSize . setSize numbers, num , follow and are inputted by the user. Print the average, largest, and smallest of the numbers.","title":"for Loops"},{"location":"lead/manage/L2/#loop-control","text":"There are two control statements that are used with loops:","title":"Loop Control"},{"location":"lead/manage/L2/#break","text":"The break statement will immediately exit a while or for loop. This can be useful if you're looking for a specific value, and you want the loop to end after you've found that value. For instance, in the below example, the loop will terminate immediately after the value key is found: int key = 8 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( i == key ) { System . out . println ( \"Found\" ); break ; } System . out . println ( \"Not found...\" ); } As a result, Not found ... will be printed out eight times at first, followed by Found . The loop will then terminate. The break statement will be more useful after you learn about arrays.","title":"break"},{"location":"lead/manage/L2/#continue","text":"The continue statement will immediately go to the next iteration of a for or while loop, bypassing all statements after it. This could be used when you only want to execute a loop for some values. Of course, an if - else statement can often accomplish the same thing, but break and continue statements can prevent too many nested blocks of code. For instance, the following block of code for ( int i = 0 ; i < 4 ; i ++ ) { System . out . println ( \"Going... \" + i ); if ( i >= 2 ) { continue ; } System . out . println ( \"Here\" ); } will print Going ... 0 Here Going ... 1 Here Going ... 2 Going ... 3","title":"continue"},{"location":"lead/manage/L2/#characters","text":"In addition to the primitive data types ( boolean , int , double ) we learned about before, char s represent one of the 256 ASCII characters . These include the numbers, standard symbols and punctuation on a keyboard, and both uppercase and lowercase letters. A char is assigned a value with the declaration char allianceColor = 'R' ; Note the use of single quotation marks rather than double quotation marks (which are used for String s) and that a variable of type char may only contain a single character. Escape characters are the first 32 ASCII characters, which serve special functions. The most commonly used is '\\n' , which creates a line break. In addition, quotation marks must be escaped. Thus, executing the following code char quote1 = '\\'' ; char quote2 = '\\\"' ; char newLine = '\\n' System . out . print ( quote1 ); System . out . print ( newLine ); System . out . print ( quote2 ); will print ' \" Note that strings can be thought of as a series of char s concatenated together. For instance, executing String someText = \"Kickoff, 2017 \\n As we anticipated the new game, the livestream blared, \\\" STEAM POWERED! STEAM POWERED! STEAM POWERED! \\\" \" ; System . out . println ( someText ); will print Kickoff , 2017 As we anticipated the new game , the livestream blared , \"STEAM POWERED! STEAM POWERED! STEAM POWERED!\" The value of characters may be compared with the equivalence ( == ) operator. For example, allianceColor == 'R' is true . Note, however, that a character is not equal its int equivalent. That is, '1' == 1 is false .","title":"Characters"},{"location":"lead/manage/L2/#string-manipulation","text":"The String class in Java contains many methods to manipulate strings. We will present an overview of the most useful ones, though you may read the full documentation here .","title":"String Manipulation"},{"location":"lead/manage/L2/#concatenation","text":"A string can be concatenated , or joined together, with other strings or primitive datatypes (and literals) with the + operator. For example, executing the following: String mascot = \"Raider\" ; int teamNum = 25 ; String teamName = mascot + \" Robotix\" ; System . out . println ( \"The year is \" + 2017 ); System . out . println ( \"I am on Team \" + teamNum + \", \" + teamName ); will print The year is 2017 I am on Team 25 , Raider Robotix You may also concatenate a string onto the end of another with the += operator. Executing String s = \"Hello\" ; s += \" World!\" ; System . out . println ( s ); will print Hello World ! .","title":"Concatenation"},{"location":"lead/manage/L2/#string-properties","text":"You can check the length of a string (number of characters) with the string . length () method. Executing String s = \"Hello\" ; System . out . println ( s + \" is \" + s . length () + \" characters long\" ); System . out . print ( \"World!\" . length ()); will print Hello is 5 characters long 6 You can also check if a string contains a specific character sequence with the string . contains ( < character sequence > ) method, which returns a boolean value. If String s = \"Hello\" ; is declared, s . contains ( \"ell\" ) returns true , while s . contains ( \"f\" ) returns false .","title":"String Properties"},{"location":"lead/manage/L2/#parsing-a-string","text":"You may want to parse through a string sometimes, or check the sequence of its characters. The string . charAt ( /*index*/ ) method will return the character currently at the index. There are two things you should know about the method: The method will return a value of type char (character), rather than String . The index is a value that is greater than or equal to 0 and less than string . length () . That is, the index of the first character in the string is 0 , and the index of the last character in the string is string . length () - 1 . If String s = \"World\" ; is declared, s . charAt ( 0 ) returns 'W' , s . charAt ( 3 ) returns 'l' , and s . charAt ( 4 ) returns 'd' . A standard way to parse through all of the characters of a string is with the following for loop: String str = \"Hello World!\" ; for ( int i = 0 ; i < str . length (); i ++ ){ char currentChar = str . charAt ( i ); //Do something here }","title":"Parsing a String"},{"location":"lead/manage/L2/#substrings","text":"Suppose you want to return a slice of a string, known as a substring, such as the first letter four letters of String s = \"Raider Robotix\" ; . An easy-to-understand way would be to use string parsing, similar to what we did above: String s = \"Raider Robotix\" ; String result = \"\" ; // an empty string for ( int i = 0 ; i < 4 && i < s . length (); i ++ ){ result += s . charAt ( i ); } System . out . println ( result ); This would print out Raid . Note that the expression i < s . length () was still present in the exit condition in order to prevent errors if s was an input string that was less than four characters long. However, a faster way to get result would be to use the substring ( beginIndex , endIndex ) method, in which beginIndex and endIndex are integers that represent the indicies that you want to search. Similar to the for loop above, beginIndex is inclusive, while endIndex is exclusive. Here are some examples: s . substring ( 0 , 4 ); returns Raid s . substring ( 7 , s . length ()); returns Robotix \"hamburger\" . substring ( 4 , 8 ); returns urge","title":"Substrings"},{"location":"lead/manage/L2/#miscellaneous-string-functions","text":"Assume that String s = \"Hello\" ; is declared in the following examples: s . toLowerCase (); returns hello s . toUpperCase (); returns HELLO s . indexOf ( \"l\" ); returns 2 (the first occurence of l in s ), while s . lastIndexOf ( \"l\" ) returns 3 s . concat ( \"world\" ); returns Helloworld As mentioned before, string equality is checked with s . equals ( \"Hello\" ); , which would return true . On the other hand, after declaring String anotherString = \"Hello\" ; , the boolean expression s == anotherString || s == \"Hello\" would be false , as string are objects , not primitives . Exercises * Write a program to reverse a string if it has an R in it. * Write a program to check if a string is a palindrome (reads the same backward as forward, such as racecar) * Write a program to replaces all commas from a string with semicolons","title":"Miscellaneous String Functions"},{"location":"lead/manage/L2/#the-math-class","text":"The Math class contains several methods that you may find helpful. It is imported by default, and documentation is found here . For these examples, we will declare double a = 4.5 , b = - 2.5 ; Math . abs ( b ) : takes the absolute value of a number, returns 2.5 in the example Math . ceil ( a ) : takes the ceiling of a number (rounds it up if it is a decimal), returns 5 in the example Math . floor ( a ) : takes the floor of a number (rounds it down if it is a decimal), returns 4 in the example Math . pow ( a - 0.5 , - b + 0.5 ) : takes the first number to the power of the second number, returns 125.0 in the example Math . sqrt ( a - 0.5 ) : takes the square root of a number, returns 2.0 in this example Math . PI : returns the value of pi (3.141592653589793) Math . random () : returns a random double in the interval [0.0, 1.0). This can be used to generate a random integer within a particular range by clamping the number down, then casting it to an int . For example, if you want a random integer in the interval [ lower , upper ], you would declare int randInt = ( int ) ( Math . random () * ( upper - lower )) + lower ; . Try it out! Exercises * Write a program that solves quadratic equations of the form 0=ax^2+bx+c for x, where a, b, and c are coefficients given by the user * Write a program that calculates the average of a data set, given the numbers in the set and its length * Write a program to find the surface area and volume of a square pyramid, given its side length and height * Write a program to round a number to a specific number of decimal places","title":"The Math Class"},{"location":"lead/manage/L2/#assignment","text":"Complete the \"Raider Robotix Printer\" and \"Binary Converter\" programs on HackerRank.","title":"Assignment"},{"location":"lead/manage/L3/","text":"Lesson 3 - Methods Here's a short lesson on one of the building blocks of Java that will prepare you for object-orientated programming: methods. Method signature A method (also known as a function in other languages) is essentially a function, very similar to one that you would encounter in math class. It has an input, an output, and a name (or identifier), though these must have specific data types (think a limited domain/range). Here is a sample method ( isEven ) being declared within a class: public class Example { public boolean isEven ( int num ){ if ( num % 2 == 0 ){ return true ; } return false ; } public static void main ( String [] args ){ //main method //code executed here first } } In this example, the method signature is simply public boolean isEven ( int num ) . It consists of visibility modifiers ( public , private , protected , etc.), a return type ( boolean ), a method identifier ( isEven ), and a set of parameters ( int num ). These parameters must each have a datatype, followed by an identifier, similar to declaring a variable. To list multiple parameters, list each one individually within the parentheses, then separate them with a comma, like in the following example: public int getNumRpPowerUp ( int redScore , int blueScore , boolean autoQuestComplete , int numClimbs , boolean levitateUsed ){ int totalRp = 0 ; if ( redScore > blueScore ) totalRp += 2 ; if ( redScore == blueScore ) totalRp ++ ; if ( autoQuestComplete ) totalRp ++ if ( numClimbs == 3 || numClimbs == 2 && levitateUsed ) totalRp ++ return totalRp ; } Note that a value with the same type as the specified return type ( int in this case) must be returned by the method. This is accomplished by typing the word return followed by a variable or literal value of the specified return type. For instance, the statement return 0 ; would be valid in getNumRpPowerUp as well. Note that the method immediately ends once a return statement is executed. It it possible for a method to have no parameters and/or return type as well. With no parameters, simply leave the contents of the parentheses following the method name blank: public String getInfoString (){ return \"Hello World!\" ; } If you don't want to return a value from the method, the return type should be specified as void . A return statement is not necessary: public void printInfo ( int currentMatchNum , String scoutName ){ System . out . println ( scoutName + \" - Match \" + currentMatchNum ); } You've already used methods to find properties of an object or to compute values, such as with str . length () or Math . pow ( base , power ) . In general, a method call is accomplished by typing the method name, followed by its parameters. The return value (if there is one) can then be used, either within a conditional statement, loop, or assigned to a variable: int red = 200 , blue = 30 , climbs = 1 ; boolean levitated = true ; int rpGained = getNumRpPowerUp ( red , blue , true , climbs , levitated ); while ( isEven ( rpGained )){ //do something } Why methods? So, why are methods so important if they're just executing a block of pre-written code? Well, creating multiple methods in an application or program allows you to break down a problem and do certain tasks repeatedly. For instance, if you wanted to test if a series of numbers were even in different parts of a program, it would be easier to make a call to isEven ( num ) rather than remembering that if a number mod 2 is 0, it is even. Another way to structure an application is to have methods responsible for specific tasks, such as saving a file or verifying if a password matches the one that was stored. As long as you test a method after you write it and ensure it gives the correct output for a variety of input parameters, you can use it throughout an application without needing to refer back to the actual method's source code. That also makes it easy to collaborate with each other, as each person working on a project could be responsible for writing and testing one method; as long as those work independently, you could implement them together in the final product. Overloading methods Sometimes, a method should be able to have different set of parameters, of different data types. In this case, the parameter list will need to be modfied: public double average ( int num1 , int num2 ){ return ( num1 + num2 ) / 2.0 ; } public double average ( double a , double b ){ return ( a + b ) / 2.0 ; } Depending on the datatypes of the parameters when you make the method call, the compiler will know which method to execute. Note that the return type for a particular method name must always be the same, and a method cannot be overloaded if its signature is otherwise identical (parameters have the same datatypes, in the same order). Recursion Like in math, methods can call themselves or other methods within the body of their code. For instance, the following returns the n th Fibonacci number (1, 1, 2, 3, 5, ...): int fib ( int n ){ if ( n == 1 ) return 1 ; if ( n == 2 ) return 1 ; return fib ( n - 1 ) + fib ( n - 2 ); } Recursion is useful for creating simple methods, but their running time can sometimes be slow, and you must always ensure that you reach a base case ( n == 1 or n == 2 in this example) that returns a literal value. Refer to the binary search method if you want to see a more complex example of recursion. Algorithmic challenges Do as many as you want, until you get a good feel of when to implement methods and how to break down a problem: Write a recursive method to compute the factorial of a number. Note that 0! is equal to 1. Write a program that takes any English sentence without punctuation as an input, then converts it to Pig Latin . Implement a more efficient (non-recursive) algorithm to find the n th Fibonacci number Determine the sum of all prime numbers from 2 to a number specified by the user. A number is superb if and only if the sum of all of its factors (excluding itself) is less than a number. Write a program to determine the number of superb numbers between two numbers (e.g. 1 and 100) that are specified by the user. Given a series of variable identifiers in camelCase, identify the number of actual words in the string (e.g. numberOfRankingPoints has four actual words). Given the length of a set of integers S, followed the elements (numbers) of S, determine if S contains only consecutive integers, without repeats (e.g. {3, 5, 4, 6} does, while {6, 4, 3} and {1, 2, 2, 3} do not). Given a series of lowercase strings without spaces or punctuation, determine if any two adjacent strings (inputted right after each other) are anagrams of each other. Write a program to determine if a number is a palindrome. Write methods that compute the least common multiple and greatest common factor of two positive integers. Please email or DM me via Slack any challenges that you finish for feedback!","title":"Lesson 3: Competition"},{"location":"lead/manage/L3/#lesson-3-methods","text":"Here's a short lesson on one of the building blocks of Java that will prepare you for object-orientated programming: methods.","title":"Lesson 3 - Methods"},{"location":"lead/manage/L3/#method-signature","text":"A method (also known as a function in other languages) is essentially a function, very similar to one that you would encounter in math class. It has an input, an output, and a name (or identifier), though these must have specific data types (think a limited domain/range). Here is a sample method ( isEven ) being declared within a class: public class Example { public boolean isEven ( int num ){ if ( num % 2 == 0 ){ return true ; } return false ; } public static void main ( String [] args ){ //main method //code executed here first } } In this example, the method signature is simply public boolean isEven ( int num ) . It consists of visibility modifiers ( public , private , protected , etc.), a return type ( boolean ), a method identifier ( isEven ), and a set of parameters ( int num ). These parameters must each have a datatype, followed by an identifier, similar to declaring a variable. To list multiple parameters, list each one individually within the parentheses, then separate them with a comma, like in the following example: public int getNumRpPowerUp ( int redScore , int blueScore , boolean autoQuestComplete , int numClimbs , boolean levitateUsed ){ int totalRp = 0 ; if ( redScore > blueScore ) totalRp += 2 ; if ( redScore == blueScore ) totalRp ++ ; if ( autoQuestComplete ) totalRp ++ if ( numClimbs == 3 || numClimbs == 2 && levitateUsed ) totalRp ++ return totalRp ; } Note that a value with the same type as the specified return type ( int in this case) must be returned by the method. This is accomplished by typing the word return followed by a variable or literal value of the specified return type. For instance, the statement return 0 ; would be valid in getNumRpPowerUp as well. Note that the method immediately ends once a return statement is executed. It it possible for a method to have no parameters and/or return type as well. With no parameters, simply leave the contents of the parentheses following the method name blank: public String getInfoString (){ return \"Hello World!\" ; } If you don't want to return a value from the method, the return type should be specified as void . A return statement is not necessary: public void printInfo ( int currentMatchNum , String scoutName ){ System . out . println ( scoutName + \" - Match \" + currentMatchNum ); } You've already used methods to find properties of an object or to compute values, such as with str . length () or Math . pow ( base , power ) . In general, a method call is accomplished by typing the method name, followed by its parameters. The return value (if there is one) can then be used, either within a conditional statement, loop, or assigned to a variable: int red = 200 , blue = 30 , climbs = 1 ; boolean levitated = true ; int rpGained = getNumRpPowerUp ( red , blue , true , climbs , levitated ); while ( isEven ( rpGained )){ //do something }","title":"Method signature"},{"location":"lead/manage/L3/#why-methods","text":"So, why are methods so important if they're just executing a block of pre-written code? Well, creating multiple methods in an application or program allows you to break down a problem and do certain tasks repeatedly. For instance, if you wanted to test if a series of numbers were even in different parts of a program, it would be easier to make a call to isEven ( num ) rather than remembering that if a number mod 2 is 0, it is even. Another way to structure an application is to have methods responsible for specific tasks, such as saving a file or verifying if a password matches the one that was stored. As long as you test a method after you write it and ensure it gives the correct output for a variety of input parameters, you can use it throughout an application without needing to refer back to the actual method's source code. That also makes it easy to collaborate with each other, as each person working on a project could be responsible for writing and testing one method; as long as those work independently, you could implement them together in the final product.","title":"Why methods?"},{"location":"lead/manage/L3/#overloading-methods","text":"Sometimes, a method should be able to have different set of parameters, of different data types. In this case, the parameter list will need to be modfied: public double average ( int num1 , int num2 ){ return ( num1 + num2 ) / 2.0 ; } public double average ( double a , double b ){ return ( a + b ) / 2.0 ; } Depending on the datatypes of the parameters when you make the method call, the compiler will know which method to execute. Note that the return type for a particular method name must always be the same, and a method cannot be overloaded if its signature is otherwise identical (parameters have the same datatypes, in the same order).","title":"Overloading methods"},{"location":"lead/manage/L3/#recursion","text":"Like in math, methods can call themselves or other methods within the body of their code. For instance, the following returns the n th Fibonacci number (1, 1, 2, 3, 5, ...): int fib ( int n ){ if ( n == 1 ) return 1 ; if ( n == 2 ) return 1 ; return fib ( n - 1 ) + fib ( n - 2 ); } Recursion is useful for creating simple methods, but their running time can sometimes be slow, and you must always ensure that you reach a base case ( n == 1 or n == 2 in this example) that returns a literal value. Refer to the binary search method if you want to see a more complex example of recursion.","title":"Recursion"},{"location":"lead/manage/L3/#algorithmic-challenges","text":"Do as many as you want, until you get a good feel of when to implement methods and how to break down a problem: Write a recursive method to compute the factorial of a number. Note that 0! is equal to 1. Write a program that takes any English sentence without punctuation as an input, then converts it to Pig Latin . Implement a more efficient (non-recursive) algorithm to find the n th Fibonacci number Determine the sum of all prime numbers from 2 to a number specified by the user. A number is superb if and only if the sum of all of its factors (excluding itself) is less than a number. Write a program to determine the number of superb numbers between two numbers (e.g. 1 and 100) that are specified by the user. Given a series of variable identifiers in camelCase, identify the number of actual words in the string (e.g. numberOfRankingPoints has four actual words). Given the length of a set of integers S, followed the elements (numbers) of S, determine if S contains only consecutive integers, without repeats (e.g. {3, 5, 4, 6} does, while {6, 4, 3} and {1, 2, 2, 3} do not). Given a series of lowercase strings without spaces or punctuation, determine if any two adjacent strings (inputted right after each other) are anagrams of each other. Write a program to determine if a number is a palindrome. Write methods that compute the least common multiple and greatest common factor of two positive integers. Please email or DM me via Slack any challenges that you finish for feedback!","title":"Algorithmic challenges"},{"location":"lead/manage/L4/","text":"Lesson 4 - Object Orientated Design We explored String s in previous lessons, which was your first look at an object in Java. In fact, you've been writing programs inside of a main function, which is a method inside a function! In this lesson, we'll see what an object really is and why they're so useful. Why objects? Objects have both state , variables that remain constant until you modify them, and behavior , which are seen through callable methods that either feed your main method information about that object or operate on its state. As programmers, you need to design objects so that their state and behavior are appropriate for what you're trying to accomplish, while breaking down code into testable and understandable building blocks. It's probably easiest to think of an object like an object in the real world, such as a person or a dog. It could have states like a name, age, favorite color, and friends. Similarly, a Person object could have behaviors like befriending another person if they have the same favorite color, increasing its age every year, or saying its name. Objects may also want to keep some state variables private , such as a credit card number. These are just examples, but you'll see as we go about modeling a person in this lesson. In essence, objects make programming real-world mechanisms and representing real-world entities a lot easier. You could have a Robot object drive a certain distance, deposit and earn interest in a BankAccount , or read the state of an Actuator on a Robot . Constructors and member variables A class is the blueprint behind an object, which is something you should already be familiar with from writing programs. Each class should generally be in its own . java file, called ClassName . java . It's possible to have multiple classes within a file, but we'll get to that later. Inside Person . java : // Import statements come first import java.util.Scanner ; public class Person { public static void main ( String [] args ){ // do stuff here } } This is probably what you're familiar with right now. Now, we'll add in some fields, called member variables , to the Person class that will help identify it: public class Person { String name , favoriteColor ; int age , numFriends ; } To initialize these attributes, we'll also need a constructor , which is essentially a method that returns an instance of that class while assigning values to as many member variables as you'd like. public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } Note that the identifier for a constructor is simply the name of the class, though the parameters can be any datatype, and there is no return statement. Like other methods, constructors can also be overloaded with arguments of different datatypes. An empty constructor is automatically created if no constructor is declared for a class, which simply doesn't set any member variables. To access member variables, we use the keyword this , referring to the new instance of the object, followed by the dot operator and the identifiers of the variables you want to modify. This also distinguishes the name variable in the parameter of the constructor with the name variable that's part of the object's state. Member variables must be assigned a value, either explicitly through the code of the class or via a constructor, before their value can be accessed. They can also either be objects or primitive values. Declaring objects So, how exactly do you create an object with the constructor? Well, it's similar to declaring any other variable in Java, complete with a datatype and identifier, except you'll need to use the new keyword: public static void main ( String [] args ){ Person mentor = new Person ( \"Cokeley\" ); } This creates an instance of a Person , which is stored in mentor . Now, if you want to access or modify attributes of mentor , you'll use the same dot operator that was used in the constructor: mentor . age = 25 ; System . out . println ( mentor . name + \" is \" + mentor . age + \" years old\" ); This will print out Cokeley is 25 years old . Class methods While having objects as a simple data structure with various attributes is useful, sometimes you want a little more interactivity. That's when we can create our own methods in a class. We can spice up the Person class by adding in the following: public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } boolean makeFriends ( Person possibleFriend ){ if ( possibleFriend . favoriteColor . equals ( this . favoriteColor )){ this . numFriends ++ ; possibleFriend . numFriends ++ ; return true ; } return false ; } } This makeFriends method mutually has two people become friends if their favoriteColor is the same, then returns true if they've become friends, or false otherwise. Another example can be seen with this RightTriangle class: class RightTriangle { double legOne , legTwo , hypotenuse ; RightTriangle ( double side1 , double side2 , double side3 ){ this . hypotenuse = Math . max ( Math . max ( side1 , side2 ), side3 ); this . legOne = Math . min ( Math . min ( side1 , side2 ), side3 ); this . legTwo = side1 + side2 + side3 - this . legOne - this . hypotenuse ; } double getArea (){ return 0.5 * this . legOne * this . legTwo ; } double getPerimeter (){ return this . legOne + this . legTwo + this . hypotenuse ; } // Returns smaller acute angle in radians double getSmallerAngle (){ return Math . atan ( this . legOne / this . legTwo ); } // Returns larger acute angle in radians double getLargerAngle (){ return Math . PI / 2 - this . getSmallerAngle (); } // Extends the length of the shorter leg and // adjusts the length of the hypotenuse accordingly void extendLegOne ( double newLength ){ if ( newLength > this . legTwo ){ this . legOne = this . legTwo ; this . legTwo = newLength ; } else this . legOne = newLength ; this . hypotenuse = Math . sqrt ( Math . pow ( this . legOne , 2 ) + Math . pow ( this . legTwo , 2 )); } } Here, after initializing a RightTriangle object, we can use its different instance methods to get and modify its properties. For instance, executing the following in the main method RightTriangle tri = new RightTriangle ( 4 , 3 , 5 ); System . out . println ( \"Perimeter: \" + tri . getPerimeter ()); System . out . println ( \"Area: \" + tri . getArea ()); System . out . println ( \"Smaller Angle: \" + tri . getSmallestAngle () + \" rad\" ); tri . extendLegOne ( 10 ); System . out . println ( \"New Perimeter: \" + tri . getPerimeter ()); will print Perimeter : 12.0 Area : 6.0 Smallest Angle : 0.6435011087932844 rad New Perimeter : 24.77032961426901 Visibility Sometimes it is desirable to reduce the access and visibility of object methods or instance variables. For example, you generally wouldn't want a main method to be able to change a Person object's name explicitly, or perhaps you want to modify a BankAccount object's balance only through withdrawal and deposit methods, each requiring a PIN code. In that case, it's best to leave member variables private instead of public . To do this, simply put the visibility modifier in front of the variable identifier, like so: public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } That way, private level access only allows those variables to be accessed and modified within the same class (such as within the constructor or other class methods). On the other hand, public level access allows all classes to modify a variable or call a method, while default access (not putting any modifier) only allows classes of the same package to access variables/methods. We'll get into packages later on, but just know that they're ways of grouping similar classes for now. So, how are we supposed to modify and access attributes like favoriteColor so the method makeFriends can still function properly? For the first case, we'll use a special type of method called a setter , while we create a getter to do the latter: private public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } public void setFavoriteColor ( String favoriteColor ){ this . favoriteColor = favoriteColor ; } public String getFavoriteColor (){ return this . favoriteColor ; } } It's pretty simple: a setter has an argument datatype that's the same as the member variable, sets the member variable, then returns nothing. Meanwhile, a getter has the same return type as the member variable, has no parameters, and simply returns the value of the member variable. In fact, these methods are so common (as it's good practice to set variables as private ) that most IDEs (including Eclipse) have a way to automatically generate setters and getters for a class. Finally, static methods and variables are called directly on a class, rather than on an instance of a class. You've already seen examples of these in the Math class: the variable Math . PI and the method Math . pow ( base , exp ) can be called without declaring an instance of a Math object via the new keyword. It's important to note that static variables are shared by all instances of a given class (and thus can be used as temporary storage). Also, static methods cannot access non- static variables or methods. You can make a static method private or public by putting the visibility modifier in front of the word static , such as in public static void main ( String [] args ) . Scope Our last topic is something that we've used throughout this lesson without realizing it; variable identifiers often come in conflict with each other. In that case, which value do we use? The smallest scope is in a loop: for ( int i = 1 ; i < 5 ; i ++ ){ double area = Math . pow ( i , 2 ); } In this case, both i and area have block scope and cannot be modified or accessed outside of the for loop. You'll see that a set of curly braces generally denotes scope. Note that variables with the identifier i or area cannot exist outside of the loop either. Next up are local variables, also known as method scope : public void setSideLength ( int sideLength ){ double squareArea = Math . pow ( sideLength , 2 ); this . sideLength = sideLength ; } Both sideLength and squareArea can be accessed/modified only within the method setSideLength . However, using the keyword this and the dot operator will refer to the member variable sideLength of the class, rather than the one passed in as an argument. All variables other than member variables cannot be accessed outside of a class, which then follow the visibility rules discussed before. HW: Modeling Bank Accounts We've discussed bank accounts throughout this lesson. Now it's time to implement one! Each BankAccount object has the following attributes, which should all be private : balance : a double indicating the amount of money in the bank account. Cannot be negative. pin : a four-digit code that authenticates a user. May contain leading zeroes (i.e. 0000 is a valid PIN) name : the name of the bank account owner interestRate : the percent of interest earned by a user in a given year, shared across all bank accounts Challenge : id : a random, five-digit code that's generated upon the creation of the bank account to identify it. Does not contain leading zeroes. You may want to refer back to the Math . random method from Lesson 2. Methods should be provided to do the following: Construct a BankAccount with a PIN, owner, and initial balance Challenge : Construct a BankAccount with a PIN, owner, and initial balance of $0.00 Get the name of the owner of an account Get the id of the account Change the PIN of the account, given the old PIN and the new PIN. Should return some form of feedback to determine if the PIN was successfully changed Withdraw money from an account, given its PIN and the amount desired. Should indicate if withdrawal was successful and should not allow it if the account doesn't have enough money Deposit a given amount of money into the account Earn interest for the year, based on the interestRate Challenge : Transfer money from one account to another, given another BankAccount object and its PIN You do not need to submit a main method as a driver for your class, though you will need to write one to test if your class works. Next lesson, you'll write one to complete specific tasks when you learn about arrays and HashMaps to create a network of bank accounts. Please email me your completed class or DM me via Slack.","title":"Lesson 4: Traveling"},{"location":"lead/manage/L4/#lesson-4-object-orientated-design","text":"We explored String s in previous lessons, which was your first look at an object in Java. In fact, you've been writing programs inside of a main function, which is a method inside a function! In this lesson, we'll see what an object really is and why they're so useful.","title":"Lesson 4 - Object Orientated Design"},{"location":"lead/manage/L4/#why-objects","text":"Objects have both state , variables that remain constant until you modify them, and behavior , which are seen through callable methods that either feed your main method information about that object or operate on its state. As programmers, you need to design objects so that their state and behavior are appropriate for what you're trying to accomplish, while breaking down code into testable and understandable building blocks. It's probably easiest to think of an object like an object in the real world, such as a person or a dog. It could have states like a name, age, favorite color, and friends. Similarly, a Person object could have behaviors like befriending another person if they have the same favorite color, increasing its age every year, or saying its name. Objects may also want to keep some state variables private , such as a credit card number. These are just examples, but you'll see as we go about modeling a person in this lesson. In essence, objects make programming real-world mechanisms and representing real-world entities a lot easier. You could have a Robot object drive a certain distance, deposit and earn interest in a BankAccount , or read the state of an Actuator on a Robot .","title":"Why objects?"},{"location":"lead/manage/L4/#constructors-and-member-variables","text":"A class is the blueprint behind an object, which is something you should already be familiar with from writing programs. Each class should generally be in its own . java file, called ClassName . java . It's possible to have multiple classes within a file, but we'll get to that later. Inside Person . java : // Import statements come first import java.util.Scanner ; public class Person { public static void main ( String [] args ){ // do stuff here } } This is probably what you're familiar with right now. Now, we'll add in some fields, called member variables , to the Person class that will help identify it: public class Person { String name , favoriteColor ; int age , numFriends ; } To initialize these attributes, we'll also need a constructor , which is essentially a method that returns an instance of that class while assigning values to as many member variables as you'd like. public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } Note that the identifier for a constructor is simply the name of the class, though the parameters can be any datatype, and there is no return statement. Like other methods, constructors can also be overloaded with arguments of different datatypes. An empty constructor is automatically created if no constructor is declared for a class, which simply doesn't set any member variables. To access member variables, we use the keyword this , referring to the new instance of the object, followed by the dot operator and the identifiers of the variables you want to modify. This also distinguishes the name variable in the parameter of the constructor with the name variable that's part of the object's state. Member variables must be assigned a value, either explicitly through the code of the class or via a constructor, before their value can be accessed. They can also either be objects or primitive values.","title":"Constructors and member variables"},{"location":"lead/manage/L4/#declaring-objects","text":"So, how exactly do you create an object with the constructor? Well, it's similar to declaring any other variable in Java, complete with a datatype and identifier, except you'll need to use the new keyword: public static void main ( String [] args ){ Person mentor = new Person ( \"Cokeley\" ); } This creates an instance of a Person , which is stored in mentor . Now, if you want to access or modify attributes of mentor , you'll use the same dot operator that was used in the constructor: mentor . age = 25 ; System . out . println ( mentor . name + \" is \" + mentor . age + \" years old\" ); This will print out Cokeley is 25 years old .","title":"Declaring objects"},{"location":"lead/manage/L4/#class-methods","text":"While having objects as a simple data structure with various attributes is useful, sometimes you want a little more interactivity. That's when we can create our own methods in a class. We can spice up the Person class by adding in the following: public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } boolean makeFriends ( Person possibleFriend ){ if ( possibleFriend . favoriteColor . equals ( this . favoriteColor )){ this . numFriends ++ ; possibleFriend . numFriends ++ ; return true ; } return false ; } } This makeFriends method mutually has two people become friends if their favoriteColor is the same, then returns true if they've become friends, or false otherwise. Another example can be seen with this RightTriangle class: class RightTriangle { double legOne , legTwo , hypotenuse ; RightTriangle ( double side1 , double side2 , double side3 ){ this . hypotenuse = Math . max ( Math . max ( side1 , side2 ), side3 ); this . legOne = Math . min ( Math . min ( side1 , side2 ), side3 ); this . legTwo = side1 + side2 + side3 - this . legOne - this . hypotenuse ; } double getArea (){ return 0.5 * this . legOne * this . legTwo ; } double getPerimeter (){ return this . legOne + this . legTwo + this . hypotenuse ; } // Returns smaller acute angle in radians double getSmallerAngle (){ return Math . atan ( this . legOne / this . legTwo ); } // Returns larger acute angle in radians double getLargerAngle (){ return Math . PI / 2 - this . getSmallerAngle (); } // Extends the length of the shorter leg and // adjusts the length of the hypotenuse accordingly void extendLegOne ( double newLength ){ if ( newLength > this . legTwo ){ this . legOne = this . legTwo ; this . legTwo = newLength ; } else this . legOne = newLength ; this . hypotenuse = Math . sqrt ( Math . pow ( this . legOne , 2 ) + Math . pow ( this . legTwo , 2 )); } } Here, after initializing a RightTriangle object, we can use its different instance methods to get and modify its properties. For instance, executing the following in the main method RightTriangle tri = new RightTriangle ( 4 , 3 , 5 ); System . out . println ( \"Perimeter: \" + tri . getPerimeter ()); System . out . println ( \"Area: \" + tri . getArea ()); System . out . println ( \"Smaller Angle: \" + tri . getSmallestAngle () + \" rad\" ); tri . extendLegOne ( 10 ); System . out . println ( \"New Perimeter: \" + tri . getPerimeter ()); will print Perimeter : 12.0 Area : 6.0 Smallest Angle : 0.6435011087932844 rad New Perimeter : 24.77032961426901","title":"Class methods"},{"location":"lead/manage/L4/#visibility","text":"Sometimes it is desirable to reduce the access and visibility of object methods or instance variables. For example, you generally wouldn't want a main method to be able to change a Person object's name explicitly, or perhaps you want to modify a BankAccount object's balance only through withdrawal and deposit methods, each requiring a PIN code. In that case, it's best to leave member variables private instead of public . To do this, simply put the visibility modifier in front of the variable identifier, like so: public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } That way, private level access only allows those variables to be accessed and modified within the same class (such as within the constructor or other class methods). On the other hand, public level access allows all classes to modify a variable or call a method, while default access (not putting any modifier) only allows classes of the same package to access variables/methods. We'll get into packages later on, but just know that they're ways of grouping similar classes for now. So, how are we supposed to modify and access attributes like favoriteColor so the method makeFriends can still function properly? For the first case, we'll use a special type of method called a setter , while we create a getter to do the latter: private public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } public void setFavoriteColor ( String favoriteColor ){ this . favoriteColor = favoriteColor ; } public String getFavoriteColor (){ return this . favoriteColor ; } } It's pretty simple: a setter has an argument datatype that's the same as the member variable, sets the member variable, then returns nothing. Meanwhile, a getter has the same return type as the member variable, has no parameters, and simply returns the value of the member variable. In fact, these methods are so common (as it's good practice to set variables as private ) that most IDEs (including Eclipse) have a way to automatically generate setters and getters for a class. Finally, static methods and variables are called directly on a class, rather than on an instance of a class. You've already seen examples of these in the Math class: the variable Math . PI and the method Math . pow ( base , exp ) can be called without declaring an instance of a Math object via the new keyword. It's important to note that static variables are shared by all instances of a given class (and thus can be used as temporary storage). Also, static methods cannot access non- static variables or methods. You can make a static method private or public by putting the visibility modifier in front of the word static , such as in public static void main ( String [] args ) .","title":"Visibility"},{"location":"lead/manage/L4/#scope","text":"Our last topic is something that we've used throughout this lesson without realizing it; variable identifiers often come in conflict with each other. In that case, which value do we use? The smallest scope is in a loop: for ( int i = 1 ; i < 5 ; i ++ ){ double area = Math . pow ( i , 2 ); } In this case, both i and area have block scope and cannot be modified or accessed outside of the for loop. You'll see that a set of curly braces generally denotes scope. Note that variables with the identifier i or area cannot exist outside of the loop either. Next up are local variables, also known as method scope : public void setSideLength ( int sideLength ){ double squareArea = Math . pow ( sideLength , 2 ); this . sideLength = sideLength ; } Both sideLength and squareArea can be accessed/modified only within the method setSideLength . However, using the keyword this and the dot operator will refer to the member variable sideLength of the class, rather than the one passed in as an argument. All variables other than member variables cannot be accessed outside of a class, which then follow the visibility rules discussed before.","title":"Scope"},{"location":"lead/manage/L4/#hw-modeling-bank-accounts","text":"We've discussed bank accounts throughout this lesson. Now it's time to implement one! Each BankAccount object has the following attributes, which should all be private : balance : a double indicating the amount of money in the bank account. Cannot be negative. pin : a four-digit code that authenticates a user. May contain leading zeroes (i.e. 0000 is a valid PIN) name : the name of the bank account owner interestRate : the percent of interest earned by a user in a given year, shared across all bank accounts Challenge : id : a random, five-digit code that's generated upon the creation of the bank account to identify it. Does not contain leading zeroes. You may want to refer back to the Math . random method from Lesson 2. Methods should be provided to do the following: Construct a BankAccount with a PIN, owner, and initial balance Challenge : Construct a BankAccount with a PIN, owner, and initial balance of $0.00 Get the name of the owner of an account Get the id of the account Change the PIN of the account, given the old PIN and the new PIN. Should return some form of feedback to determine if the PIN was successfully changed Withdraw money from an account, given its PIN and the amount desired. Should indicate if withdrawal was successful and should not allow it if the account doesn't have enough money Deposit a given amount of money into the account Earn interest for the year, based on the interestRate Challenge : Transfer money from one account to another, given another BankAccount object and its PIN You do not need to submit a main method as a driver for your class, though you will need to write one to test if your class works. Next lesson, you'll write one to complete specific tasks when you learn about arrays and HashMaps to create a network of bank accounts. Please email me your completed class or DM me via Slack.","title":"HW: Modeling Bank Accounts"},{"location":"scout/appusage/","text":"Here's how you'll install and use the scouting app for this year: Installation Allow third-party app installation on your device by going to the Settings app, then go to Security > check Unknown Sources. Instructions may vary based on your device model Download the latest version of the app on your Android device by clicking here . Alternatively, download the APK on your computer and transfer it over to the / Downloads folder of your device. Click on the APK that you downloaded (in the notification bar or in / Downloads ) and press install! Be sure to disable any apps that draw over your screen, such as Lux Lite, if you can't press install. Enjoy the app! Usage Opening the app to the main menu will reveal four icons, the current game logo, and an info bar containing the current scout, the current scouting position, and the current match. Add match Contains several user-friendly inputs to add and save match data, across different screens. Data is saved when going between different screens, though certain fields must be filled in to progress to the next screen. Prematch Contains all information that can be obtained before the match starts, with all fields required to proceed to autonomous. Usually consistent between seasons. Scout name - pulled from the settings. Left blank at the start of a new rotation. Match number - pulled from the settings and incremented after match data is saved. Determines team number verification and auto-fill. Scouting position - pulled from the settings. Determines team number verification and auto-fill. Team number - current team being scouted. May be auto-filled or verified if the option is selected in the settings Robot starting position - physical starting location of the robot, relative to the drive team behind the center driver station. Options are left (near driver station 1), center, and right (near driver station 3). Changing the scout name, match number, and scouting position will save those settings for future matches. Autonomous Contains all robot actions during autonomous. Usually specific to each game, though tasks may be similar between seasons (such as reaching a baseline/auto line) Reached auto line Own switch plate cubes Own scale plate cubes Exchange cubes Accidentally dropped cubes Cube(s) dropped on opponent plate(s) - selecting this enables the below two options to be selected Opponent plate of own switch Opponent scale plate Cubes picked up from power cube pile Cubes picked up from next to switch Passed null territory or went into opponent's null territory Tele-Op Contains all robot actions during tele-op, including the endgame. Also includes general field info that must be determined during the match, not before or after, as well as increment adjustment settings. Time to deliver first cube - how long a robot takes to complete its first full cycle. The timer is started at the beginning of tele-op if the robot ends autonomous with no cube in its intake, or when it first releases a cube. The timer is ended once the robot delivers the first cube it picks up in tele-op. Plate configuration - a grpahic is displayed with a valid field lighting configuration. Tap the image to cycle through the four different possibilities, then leave the one that matches with the field Own switch cubes Scale cubes Opponent switch cubes Exchange cubes Dropped cubes Parked on platform Attempts to climb on rung - selecting this option enables the successful in attempt input. Successful in attempt - selecting this option disables the parked input. Climbs assisted Climbs on other robot - selecting this enables type of robot climbed on, which must be filled in Type of robot climbed on (ramp bot, robot with rung, iron cross, single lift, other) Timer manual increment - provides an easy way to modify the setting without exiting to the settings menu Postmatch Contains subjective options that reflect on the robot's performance as a whole Tele-op primary focus(es) (own switch, opponent switch, scale, vault, defense) Robot and driver comments - contain common, \"quick\" comments as well as a free-response input Pick number - would the robot be a good 1 st , 2 nd , or not a good pick? Criteria changes throughout the season, as the level of competition increases. Robot comparison - prompts the scout to compare the robot playing in the current match to the one that he/she scouted in the previous match. Prompt is hidden during the first match. Upon pressing finish, the data is converted into JSON and appended to the existing JSON data file, or a new JSON data file is created it is the first match. Rules A cheat sheet of the game rules (usually the one created by Andy Smith from Team 5546) and common fouls (created by Team 25 at the beginning of the season) is available to view here. The information should have nearly everything a scouter needs to know to add match data and scout accurately. Export data JSON data for the selected current event, located at / Raider Robotix Scouting and named Data - < Scout Position > - < event key > . json , will be exported It is important that you do not accidentally delete or rename files through a file manager. How the data is exported (email, SMS, Slack, etc.) is up to the user and follows the standard Android interface. If no data exists for the current event (not necessarily for other events), a popup message will indicate so. Settings General Settings Scout name - changes the name of the current scout Shift duration - changes how long a scouting shift is, between 1 and 25 matches. If a shift is M matches long, the app will prompt for a new scout name after every M matches (e.g. the 11 th , 21 st , 31 st matches if M=10). Scout position - the driver station whose robot is being scouted on the device. Options are the Red/Blue alliance, positions 1-3. Positions are given from left to right from the driver's point of view, same as FMS. This option should be constant for a particular device, and all six devices that are used to scout should have a different scout position. Match number - current (or next) match being played. This value automatically updates, and its maximum value depends on the event. Current event - current event that is being scouted. It is critical that this does not change throughout an event, as the event data is downloaded for and the file to which data is saved is dependent on this value. Year - current season, automatically updated based on the system calendar. The downloaded event data is dependent on this value. Game-specific settings ( FIRST Power Up) Left alliance color - the left alliance station color, from the scouter's point of view. Determines the orientation of the plate lighting graphic when adding match data. Timer increment amount - adjusts the precision of manual timer increments when adding match data. Also changeable in the data entry interface Data transfer Use team lists - enabling this option will automatically fill in the correct team number for a particular scouting position/match number when adding match data, if the match schedule for the event is downloaded. If only the team list is available, this verifies that the entered team number is playing at the event. Download match schedule - downloads the match schedule, team list, and score breakdowns from previous matches from The Blue Alliance, if internet is available. Change password - brings up menu to change the password used to delete scouting data Delete scouting data - deletes all scouting data (the JSON file) for the current event in / Raider Robotix Scouting . Retains a backup copy of the data in / Downloads . The user-set password or the master password is required to delete. An info section is also present, with the current game name and version number, which should be consistent with the tag of the lastest release of the app in the master branch of the GitHub repository. If the version number is different, the app will attempt to download the lastest APK release from GitHub (if internet is available) upon startup.","title":"App Usage"},{"location":"scout/appusage/#installation","text":"Allow third-party app installation on your device by going to the Settings app, then go to Security > check Unknown Sources. Instructions may vary based on your device model Download the latest version of the app on your Android device by clicking here . Alternatively, download the APK on your computer and transfer it over to the / Downloads folder of your device. Click on the APK that you downloaded (in the notification bar or in / Downloads ) and press install! Be sure to disable any apps that draw over your screen, such as Lux Lite, if you can't press install. Enjoy the app!","title":"Installation"},{"location":"scout/appusage/#usage","text":"Opening the app to the main menu will reveal four icons, the current game logo, and an info bar containing the current scout, the current scouting position, and the current match.","title":"Usage"},{"location":"scout/appusage/#add-match","text":"Contains several user-friendly inputs to add and save match data, across different screens. Data is saved when going between different screens, though certain fields must be filled in to progress to the next screen.","title":"Add match"},{"location":"scout/appusage/#prematch","text":"Contains all information that can be obtained before the match starts, with all fields required to proceed to autonomous. Usually consistent between seasons. Scout name - pulled from the settings. Left blank at the start of a new rotation. Match number - pulled from the settings and incremented after match data is saved. Determines team number verification and auto-fill. Scouting position - pulled from the settings. Determines team number verification and auto-fill. Team number - current team being scouted. May be auto-filled or verified if the option is selected in the settings Robot starting position - physical starting location of the robot, relative to the drive team behind the center driver station. Options are left (near driver station 1), center, and right (near driver station 3). Changing the scout name, match number, and scouting position will save those settings for future matches.","title":"Prematch"},{"location":"scout/appusage/#autonomous","text":"Contains all robot actions during autonomous. Usually specific to each game, though tasks may be similar between seasons (such as reaching a baseline/auto line) Reached auto line Own switch plate cubes Own scale plate cubes Exchange cubes Accidentally dropped cubes Cube(s) dropped on opponent plate(s) - selecting this enables the below two options to be selected Opponent plate of own switch Opponent scale plate Cubes picked up from power cube pile Cubes picked up from next to switch Passed null territory or went into opponent's null territory","title":"Autonomous"},{"location":"scout/appusage/#tele-op","text":"Contains all robot actions during tele-op, including the endgame. Also includes general field info that must be determined during the match, not before or after, as well as increment adjustment settings. Time to deliver first cube - how long a robot takes to complete its first full cycle. The timer is started at the beginning of tele-op if the robot ends autonomous with no cube in its intake, or when it first releases a cube. The timer is ended once the robot delivers the first cube it picks up in tele-op. Plate configuration - a grpahic is displayed with a valid field lighting configuration. Tap the image to cycle through the four different possibilities, then leave the one that matches with the field Own switch cubes Scale cubes Opponent switch cubes Exchange cubes Dropped cubes Parked on platform Attempts to climb on rung - selecting this option enables the successful in attempt input. Successful in attempt - selecting this option disables the parked input. Climbs assisted Climbs on other robot - selecting this enables type of robot climbed on, which must be filled in Type of robot climbed on (ramp bot, robot with rung, iron cross, single lift, other) Timer manual increment - provides an easy way to modify the setting without exiting to the settings menu","title":"Tele-Op"},{"location":"scout/appusage/#postmatch","text":"Contains subjective options that reflect on the robot's performance as a whole Tele-op primary focus(es) (own switch, opponent switch, scale, vault, defense) Robot and driver comments - contain common, \"quick\" comments as well as a free-response input Pick number - would the robot be a good 1 st , 2 nd , or not a good pick? Criteria changes throughout the season, as the level of competition increases. Robot comparison - prompts the scout to compare the robot playing in the current match to the one that he/she scouted in the previous match. Prompt is hidden during the first match. Upon pressing finish, the data is converted into JSON and appended to the existing JSON data file, or a new JSON data file is created it is the first match.","title":"Postmatch"},{"location":"scout/appusage/#rules","text":"A cheat sheet of the game rules (usually the one created by Andy Smith from Team 5546) and common fouls (created by Team 25 at the beginning of the season) is available to view here. The information should have nearly everything a scouter needs to know to add match data and scout accurately.","title":"Rules"},{"location":"scout/appusage/#export-data","text":"JSON data for the selected current event, located at / Raider Robotix Scouting and named Data - < Scout Position > - < event key > . json , will be exported It is important that you do not accidentally delete or rename files through a file manager. How the data is exported (email, SMS, Slack, etc.) is up to the user and follows the standard Android interface. If no data exists for the current event (not necessarily for other events), a popup message will indicate so.","title":"Export data"},{"location":"scout/appusage/#settings","text":"","title":"Settings"},{"location":"scout/appusage/#general-settings","text":"Scout name - changes the name of the current scout Shift duration - changes how long a scouting shift is, between 1 and 25 matches. If a shift is M matches long, the app will prompt for a new scout name after every M matches (e.g. the 11 th , 21 st , 31 st matches if M=10). Scout position - the driver station whose robot is being scouted on the device. Options are the Red/Blue alliance, positions 1-3. Positions are given from left to right from the driver's point of view, same as FMS. This option should be constant for a particular device, and all six devices that are used to scout should have a different scout position. Match number - current (or next) match being played. This value automatically updates, and its maximum value depends on the event. Current event - current event that is being scouted. It is critical that this does not change throughout an event, as the event data is downloaded for and the file to which data is saved is dependent on this value. Year - current season, automatically updated based on the system calendar. The downloaded event data is dependent on this value.","title":"General Settings"},{"location":"scout/appusage/#game-specific-settings-first-power-up","text":"Left alliance color - the left alliance station color, from the scouter's point of view. Determines the orientation of the plate lighting graphic when adding match data. Timer increment amount - adjusts the precision of manual timer increments when adding match data. Also changeable in the data entry interface","title":"Game-specific settings (FIRST Power Up)"},{"location":"scout/appusage/#data-transfer","text":"Use team lists - enabling this option will automatically fill in the correct team number for a particular scouting position/match number when adding match data, if the match schedule for the event is downloaded. If only the team list is available, this verifies that the entered team number is playing at the event. Download match schedule - downloads the match schedule, team list, and score breakdowns from previous matches from The Blue Alliance, if internet is available. Change password - brings up menu to change the password used to delete scouting data Delete scouting data - deletes all scouting data (the JSON file) for the current event in / Raider Robotix Scouting . Retains a backup copy of the data in / Downloads . The user-set password or the master password is required to delete. An info section is also present, with the current game name and version number, which should be consistent with the tag of the lastest release of the app in the master branch of the GitHub repository. If the version number is different, the app will attempt to download the lastest APK release from GitHub (if internet is available) upon startup.","title":"Data transfer"},{"location":"scout/assessments/","text":"Assessments Here are the forms and assessments that you should complete for the 2018 season, FIRST Power Up: Registration Due date: 10:00 AM, Saturday, January 6, 2018 You must complete this form to be a part of the scouting team: Loading... Quiz 1 Due date: 11:59 PM, Monday, January 15, 2018 Please read the game manual before taking the quiz and aim for 85% or better. Good luck! Loading... Quiz 2 This quiz is optional , but you may take it for the opportunity to earn bonus Theory points before Stop Build Day, Tuesday, February 19, 2019 . Loading... Kahoots Two Kahoots on the game manual are scheduled for the meetings on Wednesday, January 16, 2019 and Wednesday, February 13, 2019 . If you are absent on those meetings, click the following links to make up the Kahoots. You'll need to download the Kahoot app on your phone: Kahoot 1 : due Tuesday, January 22, 2019 Kahoot 2 : due Tuesday, February 19, 2019 If you missed the deadlines stated above, you'll need to DM the scouting lead(s) for a link. Week Zero A crucial part of scouting is preparation for actual competition by scouting Week Zero matches. We'll be doing this during the meeting on Wednesday, February 20, 2019 . If you are absent and have an Android phone, follow these instructions to install and use the app. You'll need to scout at least three of the following four matches. Despite what the Field Management System says, please label the matches with the match numbers given here and the position Red 1 for each robot. Also, use your real name! Once you're done, DM your data to the scouting lead(s) via Slack by using the Export Data feature on the main menu to the app. Please complete this by Tuesday, February 19, 2019 . Of course, don't worry about it if you don't have an Android device; you'll get the chance to practice scout at the next meeting. Match 1, Team 78 Match 2, Team 5687 Match 3, Team 238 Match 4, Team 58","title":"Assessments"},{"location":"scout/assessments/#assessments","text":"Here are the forms and assessments that you should complete for the 2018 season, FIRST Power Up:","title":"Assessments"},{"location":"scout/assessments/#registration","text":"Due date: 10:00 AM, Saturday, January 6, 2018 You must complete this form to be a part of the scouting team: Loading...","title":"Registration"},{"location":"scout/assessments/#quiz-1","text":"Due date: 11:59 PM, Monday, January 15, 2018 Please read the game manual before taking the quiz and aim for 85% or better. Good luck! Loading...","title":"Quiz 1"},{"location":"scout/assessments/#quiz-2","text":"This quiz is optional , but you may take it for the opportunity to earn bonus Theory points before Stop Build Day, Tuesday, February 19, 2019 . Loading...","title":"Quiz 2"},{"location":"scout/assessments/#kahoots","text":"Two Kahoots on the game manual are scheduled for the meetings on Wednesday, January 16, 2019 and Wednesday, February 13, 2019 . If you are absent on those meetings, click the following links to make up the Kahoots. You'll need to download the Kahoot app on your phone: Kahoot 1 : due Tuesday, January 22, 2019 Kahoot 2 : due Tuesday, February 19, 2019 If you missed the deadlines stated above, you'll need to DM the scouting lead(s) for a link.","title":"Kahoots"},{"location":"scout/assessments/#week-zero","text":"A crucial part of scouting is preparation for actual competition by scouting Week Zero matches. We'll be doing this during the meeting on Wednesday, February 20, 2019 . If you are absent and have an Android phone, follow these instructions to install and use the app. You'll need to scout at least three of the following four matches. Despite what the Field Management System says, please label the matches with the match numbers given here and the position Red 1 for each robot. Also, use your real name! Once you're done, DM your data to the scouting lead(s) via Slack by using the Export Data feature on the main menu to the app. Please complete this by Tuesday, February 19, 2019 . Of course, don't worry about it if you don't have an Android device; you'll get the chance to practice scout at the next meeting.","title":"Week Zero"},{"location":"scout/assessments/#match-1-team-78","text":"","title":"Match 1, Team 78"},{"location":"scout/assessments/#match-2-team-5687","text":"","title":"Match 2, Team 5687"},{"location":"scout/assessments/#match-3-team-238","text":"","title":"Match 3, Team 238"},{"location":"scout/assessments/#match-4-team-58","text":"","title":"Match 4, Team 58"},{"location":"scout/history/","text":"Scouting History Here's a chronology of the team's scouting history, starting from the most recent season: 2019 - Destination: Deep Space Scouting Leads : Spencer Ng, ??? 2018 - FIRST Power Up Scouting Leads : Owais Aftab, Arushi Bhatia, Spencer Ng This season saw the introduction of six Kindle Fire 7 tablets (with significantly better battery life) used for electronic scouting, with continuing use of the electronic scouting system from 2017, which involved the Android app, a desktop Java client, and Tableau for analysis. Assessments of scouts were done with a Google forms quiz, Kahoots, and Week Zero scouting, as well as scores for punctuality and reliability of scouts, which were all published in a public spreadsheet. These scores, along with several qualitative factors, were used to form the very-accurate scouting travel team, which used three rotations at the District Championship and two rotations at the World Championship. As a time-based game, timers were used in parts of the scouting app, while solely using statistics to make judgement calls was deemphasized due to robots focusing on different aspects of the game depending on the match. Instead, many members of the scouting team took qualitative notes on robots' on-field capabilities and argued for or against them during the scouting meetings. Video review was heavily used to judge the speed and reliability of autonomous modes and power cube intakes, and we received a new camera with better battery life for the World Championship. A new feature introduced this year was automatic picklist generation, based on ratings and pairwise-comparisons made by scouts with sequential robots that they scouted. These were fairly effective at providing a launch point for scouting meeting discussions, and adjustments were made with further pairwise-comparisons. Also introduced was a data auto-correction feature, which pulled from the Blue Alliance API to correct inaccurate data such as robot climbs and auto line crossings. Our picking strategy involved forming an overall list of the best robots at district and offseason competitons, while forming distinct first/third and second picklists at the District and World Championships. We were fortunate to have compatible alliance captains approach us during four of our competitions this season due to our robot's outstanding on-field performance, which meant only needing to choose a second pick. We only emphasized quickly placing cubes on the exchange and switch at the beginning of the season due to the low skill floor, while having a climb and a (multicube) center switch auto was crucial toward the end of the season. For first picks, we emphasized a multicube scale auto and quickly and precisely placing cubes on the scale during tele-op. Mount Olive District Event Accepted Team 303's offer as the first overall pick. Accepting their offer as the second seed was the best strategic decision, as the top-tier scale robots at the event were Teams 25, 303, and 1923. Selected Team 6203 as our second pick due to their exchange ability out of those in the remaining pool of robots. Event Winners Montgomery District Event Accepted Team 225's offer as the first overall pick due to their three-cube scale autonomous and superior tele-op ability over the remaining pool of robots. Selected Team 5992 as our second pick due to their exchange ability out of those in the remaining pool of robots. Event Winners Hatboro-Horsham District Event Accepted Team 2590's offer as the first overall pick due to their iron cross design that enabled an extra climb, their fast scale ability, and the lack of strategic options as the third seed. The top-tier scale robots at the event were Teams 25, 1218, 1640, and 2590, followed by Teams 1391 and 5407. Selected Team 6223 as the second pick due to their exchange ability out of those in the remaining pool of robots. Event Winners FIRST Mid-Atlantic District Championship Selected Team 1640 for our first pick as the second alliance captain due to their two-cube scale autonomous, fast climb, and overall tele-op ability. Other options that we considered were Teams 365, 316, 1923, and 1712. Selected Team 1089 as our second pick due to their fast climb and center switch autonomous, as well as ability to play any role required, including the scale. We also strongly considered Team 2016 for their two-cube center switch autonomous and tele-op exchange, switch, and defense ability, despite lacking a climb and scale ability. Event Finalists FIRST Championship: Detroit - Carson Division Accepted Team 225's offer as the first overall pick due to being the 19 th seed. We were fortunate to be chosen despite our communication problems the previous day Selected Team 3015 as our second pick due to their climb, multicube center switch autonomous, and precise tele-op scale placement, which was crucial to our playoff strategy Selected Team 88 as our third pick due to their climb, exchange ability, and strategic calls made by their drive coach Division Semifinalists 2017 - FIRST Steamworks Scouting Leads : Owais Aftab, Arushi Bhatia, Spencer Ng This season saw a new set of scouting leads and a complete overhaul of the scouting subteam. Computer-based and practical assessments were given to the scouting team to form the basis of travel decisions, while the rules of the game were explained to scouts during meetings. This was highly successful and led to accurate scouting, partially due to the large number of freshmen scouts on the team. However, motivation for scouting tended to decrease as the season progressed. The system itself was reinvented, with an Android app that converted collected data to JSON files that could be exported to the desktop client. The app itself utilized a modular, user-friendly material design interface with large buttons and checkboxes throughout, which could easily be modified for a given year. Meanwhile, the desktop client compiled the data from the six tablets together and provided team-based and alliance-based statistics, such as the overall average number of gears or the probability of one, two, or three climbs. Tableau (introduced this year) and Excel were heavily used for data analysis, with Excel for looking at individual match data and Tableau for visualizing overall trends. In fact, much of the picklisting was done by looking at a plot of the average number of gears compared to takeoff percentage. The teams in the top-right indicated the best picks, while those in the bottom-left were the worst picks. We generally ignored autonomous capabilities due to the difficulty of a two-rotor auto and the reliability of our robot's autonomous mode. It is also notable that due to the \"rope roulette\" of the qualification matches, team rankings did not strongly correlate to robot ability. Overall, despite our mediocore robot design, our scouting and strategy enabled us to select dark horses and win our first blue banners in five years. Mount Olive District Event Selected Team 303 for our first pick as the second alliance captain due to their high number of gears, reliable climb, and shooter. They were the only objectively standout pick remaining after Teams 293 and 222 formed Alliance 1. Selected Team 1923 for our second pick due to their high number of gears, active gear placement, and reliable climb out of those available in the remaining pool. Event Winners Montgomery District Event Accepted Team 75's offer as the eighth overall pick due to being 21 st seed Selected Team 1923 for our second pick due to their high number of gears, center auto, and reliable climb out of those available in the remaining pool. This pairing enabled us to complete four rotors and up to two in auto. Event Winners FIRST Mid-Atlantic District Championship Accepted Team 1923's offer as the eighth overall pick due to being the 37 th seed Selected Team 75 for our second pick due to having the highest average number of gears, a gear intake, a side gear autonomous, and a reliable climb. We were also well-coordinated as an alliance after the Montgomery event, despite not having any fuel ability. Event Quarterfinalists FIRST Championship: St. Louis - Carson Division Accepted Team 303's offer as the 17 th overall pick (fourth member of the alliance) due to being the 25 th seed Division Semifinalists 2016 - FIRST Stronghold Scouting Leads : Arjun Bansil, Haley Williams This year saw a new Android app, which collected data on defense crossings and boulders put into the high and low goals during both autonomous and teleop. The app exported a spreadsheet, which formed the basis of picklist discussions. Due to our robot's outstanding low goal performance and reliable climb, we were fortunate enough to have picklist discussions with other teams before Alliance Selection, and our picklists tended to focus on the robots that could score the most points on average in a given match, through any means possible. Hatboro-Horsham District Event Invited Team 341 for our first pick as the first alliance captain Selected Team 1807 as our second pick Event Semifinalists Bridgewater-Raritan District Event Accepted Team 1257's offer as the first overall pick Selected Team 555 as our second pick Event Finalists Mid-Atlantic Robotics District Championship Accepted Team 3314's offer as the third overall pick due to being the 11 th seed Selected Team 1089 as our second pick Event Finalists FIRST Championship - Curie Division Selected Team 2848 for our first pick as the third alliance captain. Many believe that Team 3641 should have been chosen instead. Selected Team 4329 as our second pick Selected Team 1885 as our third pick Division Quarterfinalists 2015 - Recycle Rush 2014 - Aerial Assist 2013 - Ultimate Ascent 2012 - Rebound Rumble 2011 - Logomotion 2010 - Breakaway 2009 - Lunacy 2008 - FIRST Overdrive 2007 - Rack 'n Roll 2006 - Aim High 2005 - Triple Play 2004 - FIRST Frenzy: Raising the Bar 2003 - Stack Attack 2002 - Zone Zeal 2001 - Diabolical Dynamics 2000 - Co-Opertition FIRST 1999 - Double Trouble 1998 - Ladder Logic 1997 - Torroid Terror","title":"History"},{"location":"scout/history/#scouting-history","text":"Here's a chronology of the team's scouting history, starting from the most recent season:","title":"Scouting History"},{"location":"scout/history/#2019-destination-deep-space","text":"Scouting Leads : Spencer Ng, ???","title":"2019 - Destination: Deep Space"},{"location":"scout/history/#2018-first-power-up","text":"Scouting Leads : Owais Aftab, Arushi Bhatia, Spencer Ng This season saw the introduction of six Kindle Fire 7 tablets (with significantly better battery life) used for electronic scouting, with continuing use of the electronic scouting system from 2017, which involved the Android app, a desktop Java client, and Tableau for analysis. Assessments of scouts were done with a Google forms quiz, Kahoots, and Week Zero scouting, as well as scores for punctuality and reliability of scouts, which were all published in a public spreadsheet. These scores, along with several qualitative factors, were used to form the very-accurate scouting travel team, which used three rotations at the District Championship and two rotations at the World Championship. As a time-based game, timers were used in parts of the scouting app, while solely using statistics to make judgement calls was deemphasized due to robots focusing on different aspects of the game depending on the match. Instead, many members of the scouting team took qualitative notes on robots' on-field capabilities and argued for or against them during the scouting meetings. Video review was heavily used to judge the speed and reliability of autonomous modes and power cube intakes, and we received a new camera with better battery life for the World Championship. A new feature introduced this year was automatic picklist generation, based on ratings and pairwise-comparisons made by scouts with sequential robots that they scouted. These were fairly effective at providing a launch point for scouting meeting discussions, and adjustments were made with further pairwise-comparisons. Also introduced was a data auto-correction feature, which pulled from the Blue Alliance API to correct inaccurate data such as robot climbs and auto line crossings. Our picking strategy involved forming an overall list of the best robots at district and offseason competitons, while forming distinct first/third and second picklists at the District and World Championships. We were fortunate to have compatible alliance captains approach us during four of our competitions this season due to our robot's outstanding on-field performance, which meant only needing to choose a second pick. We only emphasized quickly placing cubes on the exchange and switch at the beginning of the season due to the low skill floor, while having a climb and a (multicube) center switch auto was crucial toward the end of the season. For first picks, we emphasized a multicube scale auto and quickly and precisely placing cubes on the scale during tele-op.","title":"2018 - FIRST Power Up"},{"location":"scout/history/#mount-olive-district-event","text":"Accepted Team 303's offer as the first overall pick. Accepting their offer as the second seed was the best strategic decision, as the top-tier scale robots at the event were Teams 25, 303, and 1923. Selected Team 6203 as our second pick due to their exchange ability out of those in the remaining pool of robots. Event Winners","title":"Mount Olive District Event"},{"location":"scout/history/#montgomery-district-event","text":"Accepted Team 225's offer as the first overall pick due to their three-cube scale autonomous and superior tele-op ability over the remaining pool of robots. Selected Team 5992 as our second pick due to their exchange ability out of those in the remaining pool of robots. Event Winners","title":"Montgomery District Event"},{"location":"scout/history/#hatboro-horsham-district-event","text":"Accepted Team 2590's offer as the first overall pick due to their iron cross design that enabled an extra climb, their fast scale ability, and the lack of strategic options as the third seed. The top-tier scale robots at the event were Teams 25, 1218, 1640, and 2590, followed by Teams 1391 and 5407. Selected Team 6223 as the second pick due to their exchange ability out of those in the remaining pool of robots. Event Winners","title":"Hatboro-Horsham District Event"},{"location":"scout/history/#first-mid-atlantic-district-championship","text":"Selected Team 1640 for our first pick as the second alliance captain due to their two-cube scale autonomous, fast climb, and overall tele-op ability. Other options that we considered were Teams 365, 316, 1923, and 1712. Selected Team 1089 as our second pick due to their fast climb and center switch autonomous, as well as ability to play any role required, including the scale. We also strongly considered Team 2016 for their two-cube center switch autonomous and tele-op exchange, switch, and defense ability, despite lacking a climb and scale ability. Event Finalists","title":"FIRST Mid-Atlantic District Championship"},{"location":"scout/history/#first-championship-detroit-carson-division","text":"Accepted Team 225's offer as the first overall pick due to being the 19 th seed. We were fortunate to be chosen despite our communication problems the previous day Selected Team 3015 as our second pick due to their climb, multicube center switch autonomous, and precise tele-op scale placement, which was crucial to our playoff strategy Selected Team 88 as our third pick due to their climb, exchange ability, and strategic calls made by their drive coach Division Semifinalists","title":"FIRST Championship: Detroit - Carson Division"},{"location":"scout/history/#2017-first-steamworks","text":"Scouting Leads : Owais Aftab, Arushi Bhatia, Spencer Ng This season saw a new set of scouting leads and a complete overhaul of the scouting subteam. Computer-based and practical assessments were given to the scouting team to form the basis of travel decisions, while the rules of the game were explained to scouts during meetings. This was highly successful and led to accurate scouting, partially due to the large number of freshmen scouts on the team. However, motivation for scouting tended to decrease as the season progressed. The system itself was reinvented, with an Android app that converted collected data to JSON files that could be exported to the desktop client. The app itself utilized a modular, user-friendly material design interface with large buttons and checkboxes throughout, which could easily be modified for a given year. Meanwhile, the desktop client compiled the data from the six tablets together and provided team-based and alliance-based statistics, such as the overall average number of gears or the probability of one, two, or three climbs. Tableau (introduced this year) and Excel were heavily used for data analysis, with Excel for looking at individual match data and Tableau for visualizing overall trends. In fact, much of the picklisting was done by looking at a plot of the average number of gears compared to takeoff percentage. The teams in the top-right indicated the best picks, while those in the bottom-left were the worst picks. We generally ignored autonomous capabilities due to the difficulty of a two-rotor auto and the reliability of our robot's autonomous mode. It is also notable that due to the \"rope roulette\" of the qualification matches, team rankings did not strongly correlate to robot ability. Overall, despite our mediocore robot design, our scouting and strategy enabled us to select dark horses and win our first blue banners in five years.","title":"2017 - FIRST Steamworks"},{"location":"scout/history/#mount-olive-district-event_1","text":"Selected Team 303 for our first pick as the second alliance captain due to their high number of gears, reliable climb, and shooter. They were the only objectively standout pick remaining after Teams 293 and 222 formed Alliance 1. Selected Team 1923 for our second pick due to their high number of gears, active gear placement, and reliable climb out of those available in the remaining pool. Event Winners","title":"Mount Olive District Event"},{"location":"scout/history/#montgomery-district-event_1","text":"Accepted Team 75's offer as the eighth overall pick due to being 21 st seed Selected Team 1923 for our second pick due to their high number of gears, center auto, and reliable climb out of those available in the remaining pool. This pairing enabled us to complete four rotors and up to two in auto. Event Winners","title":"Montgomery District Event"},{"location":"scout/history/#first-mid-atlantic-district-championship_1","text":"Accepted Team 1923's offer as the eighth overall pick due to being the 37 th seed Selected Team 75 for our second pick due to having the highest average number of gears, a gear intake, a side gear autonomous, and a reliable climb. We were also well-coordinated as an alliance after the Montgomery event, despite not having any fuel ability. Event Quarterfinalists","title":"FIRST Mid-Atlantic District Championship"},{"location":"scout/history/#first-championship-st-louis-carson-division","text":"Accepted Team 303's offer as the 17 th overall pick (fourth member of the alliance) due to being the 25 th seed Division Semifinalists","title":"FIRST Championship: St. Louis - Carson Division"},{"location":"scout/history/#2016-first-stronghold","text":"Scouting Leads : Arjun Bansil, Haley Williams This year saw a new Android app, which collected data on defense crossings and boulders put into the high and low goals during both autonomous and teleop. The app exported a spreadsheet, which formed the basis of picklist discussions. Due to our robot's outstanding low goal performance and reliable climb, we were fortunate enough to have picklist discussions with other teams before Alliance Selection, and our picklists tended to focus on the robots that could score the most points on average in a given match, through any means possible.","title":"2016 - FIRST Stronghold"},{"location":"scout/history/#hatboro-horsham-district-event_1","text":"Invited Team 341 for our first pick as the first alliance captain Selected Team 1807 as our second pick Event Semifinalists","title":"Hatboro-Horsham District Event"},{"location":"scout/history/#bridgewater-raritan-district-event","text":"Accepted Team 1257's offer as the first overall pick Selected Team 555 as our second pick Event Finalists","title":"Bridgewater-Raritan District Event"},{"location":"scout/history/#mid-atlantic-robotics-district-championship","text":"Accepted Team 3314's offer as the third overall pick due to being the 11 th seed Selected Team 1089 as our second pick Event Finalists","title":"Mid-Atlantic Robotics District Championship"},{"location":"scout/history/#first-championship-curie-division","text":"Selected Team 2848 for our first pick as the third alliance captain. Many believe that Team 3641 should have been chosen instead. Selected Team 4329 as our second pick Selected Team 1885 as our third pick Division Quarterfinalists","title":"FIRST Championship - Curie Division"},{"location":"scout/history/#2015-recycle-rush","text":"","title":"2015 - Recycle Rush"},{"location":"scout/history/#2014-aerial-assist","text":"","title":"2014 - Aerial Assist"},{"location":"scout/history/#2013-ultimate-ascent","text":"","title":"2013 - Ultimate Ascent"},{"location":"scout/history/#2012-rebound-rumble","text":"","title":"2012 - Rebound Rumble"},{"location":"scout/history/#2011-logomotion","text":"","title":"2011 - Logomotion"},{"location":"scout/history/#2010-breakaway","text":"","title":"2010 - Breakaway"},{"location":"scout/history/#2009-lunacy","text":"","title":"2009 - Lunacy"},{"location":"scout/history/#2008-first-overdrive","text":"","title":"2008 - FIRST Overdrive"},{"location":"scout/history/#2007-rack-n-roll","text":"","title":"2007 -  Rack 'n Roll"},{"location":"scout/history/#2006-aim-high","text":"","title":"2006 - Aim High"},{"location":"scout/history/#2005-triple-play","text":"","title":"2005 - Triple Play"},{"location":"scout/history/#2004-first-frenzy-raising-the-bar","text":"","title":"2004 - FIRST Frenzy: Raising the Bar"},{"location":"scout/history/#2003-stack-attack","text":"","title":"2003 - Stack Attack"},{"location":"scout/history/#2002-zone-zeal","text":"","title":"2002 - Zone Zeal"},{"location":"scout/history/#2001-diabolical-dynamics","text":"","title":"2001 - Diabolical Dynamics"},{"location":"scout/history/#2000-co-opertition-first","text":"","title":"2000 - Co-Opertition FIRST"},{"location":"scout/history/#1999-double-trouble","text":"","title":"1999 - Double Trouble"},{"location":"scout/history/#1998-ladder-logic","text":"","title":"1998 - Ladder Logic"},{"location":"scout/history/#1997-torroid-terror","text":"","title":"1997 - Torroid Terror"},{"location":"scout/resources/","text":"FIRST Power Up Resources Here are some useful links for this year's game: Game Manual It is recommended that you read the manual from cover-to-cover, but at least read sections 2, 3, 4, 7, and 10 in their entirety. This browser does not support PDFs. Please download the PDF to view it: Download PDF . Rules/Fouls Cheatsheet You should be very familiar with everything in this document: This browser does not support PDFs. Please download the PDF to view it: Download PDF . Dimensioned Field This browser does not support PDFs. Please download the PDF to view it: Download PDF . Restricted Field Zones This browser does not support PDFs. Please download the PDF to view it: Download PDF . Other Links The Blue Alliance : a repository of information on teams, events, and matches, both in the past and in the present Chief Delphi : a forum for all things robotics Our Slack! : feel free to message #scouting or DM the strategy & scouting lead(s) if you need anything","title":"Game Resources"},{"location":"scout/resources/#first-power-up-resources","text":"Here are some useful links for this year's game:","title":"FIRST Power Up Resources"},{"location":"scout/resources/#game-manual","text":"It is recommended that you read the manual from cover-to-cover, but at least read sections 2, 3, 4, 7, and 10 in their entirety. This browser does not support PDFs. Please download the PDF to view it: Download PDF .","title":"Game Manual"},{"location":"scout/resources/#rulesfouls-cheatsheet","text":"You should be very familiar with everything in this document: This browser does not support PDFs. Please download the PDF to view it: Download PDF .","title":"Rules/Fouls Cheatsheet"},{"location":"scout/resources/#dimensioned-field","text":"This browser does not support PDFs. Please download the PDF to view it: Download PDF .","title":"Dimensioned Field"},{"location":"scout/resources/#restricted-field-zones","text":"This browser does not support PDFs. Please download the PDF to view it: Download PDF .","title":"Restricted Field Zones"},{"location":"scout/resources/#other-links","text":"The Blue Alliance : a repository of information on teams, events, and matches, both in the past and in the present Chief Delphi : a forum for all things robotics Our Slack! : feel free to message #scouting or DM the strategy & scouting lead(s) if you need anything","title":"Other Links"},{"location":"scout/standings/","text":"Scout Standings Here are the scouting standings for the 2018 season, FIRST Power Up: 2018 Ranking Method Three categories are used to score scouts: Theory (2x weighting) Question-based material based on FRC event rules and the FIRST Power Up manual Quiz 1 - worth 100 points Each question has different weighting Partial credit awarded for multiple select/answer questions Rubric used to grade open-ended questions Opportunity to take Quiz 2 - worth 100 points Theory score/average will be based on three highest scores from all assessments Kahoots - worth 100 points each Points awarded is 100 \\cdot {\\frac{\\text{correct answers}}{\\text{total questions answered}}} 100 \\cdot {\\frac{\\text{correct answers}}{\\text{total questions answered}}} , rounded to the nearest integer Opportunities to make up if you weren\u2019t present at the meeting Skill (3x weighting) Accuracy of scouting matches from Week Zero Four assigned matches worth 100 points each Skill score/average will be based on three highest scores from all matches Formula used to assess accuracy of the data in each section of the app Prematch, auto, teleop, and postmatch data each given different weightings Punctuality (75x weighting) Commitment to the scouting team, communication, and reliability Points deducted each time something is completed past its due date Registration, quizzes/kahoots, etc. 1 pt deduction for less than one week late 2 pt deduction for one week or more late If you registered late, deductions for past due assignments begin 1 week after you registered 0 pt deduction if completed in less than 1 week after registration 1 pt deduction if completed 1-2 weeks after you registered 2 pt deduction if more than 2 weeks All scouts begin with 20 points, unless you registered late Two methods are used for a composite assessment of scouts: Running Score (primary method) Category scores (punctuality/theory/skill) are simply points earned from items from that category added together Running score is 75 \\cdot \\text{punctuality score} + 2 \\cdot \\text{theory score} + 3 \\cdot \\text{skill score} 75 \\cdot \\text{punctuality score} + 2 \\cdot \\text{theory score} + 3 \\cdot \\text{skill score} The higher the score, the better! Maximum is 3000, without bonuses Rewards completing assessments (including optional ones) and a high punctuality score \"Average\" (secondary method) Category averages (punctuality/theory/skill) are the average of points earned from items of that category Averages are 100 if no points are attainable from that category yet Average is 0.5 \\cdot \\text{punctuality average} + 0.2 \\cdot \\text{theory average} + 0.3 \\cdot \\text{skill average} 0.5 \\cdot \\text{punctuality average} + 0.2 \\cdot \\text{theory average} + 0.3 \\cdot \\text{skill average} The higher the average, the better! Maximum is 100 May not be an accurate depiction of how committed a scout is, but easier to understand and very similar to a school average Remember, your performance is relative to the rest of the scouting team - let's just take scouting seriously to help us win competitions!","title":"Scout Standings"},{"location":"scout/standings/#scout-standings","text":"Here are the scouting standings for the 2018 season, FIRST Power Up:","title":"Scout Standings"},{"location":"scout/standings/#2018-ranking-method","text":"Three categories are used to score scouts:","title":"2018 Ranking Method"},{"location":"scout/standings/#theory-2x-weighting","text":"Question-based material based on FRC event rules and the FIRST Power Up manual Quiz 1 - worth 100 points Each question has different weighting Partial credit awarded for multiple select/answer questions Rubric used to grade open-ended questions Opportunity to take Quiz 2 - worth 100 points Theory score/average will be based on three highest scores from all assessments Kahoots - worth 100 points each Points awarded is 100 \\cdot {\\frac{\\text{correct answers}}{\\text{total questions answered}}} 100 \\cdot {\\frac{\\text{correct answers}}{\\text{total questions answered}}} , rounded to the nearest integer Opportunities to make up if you weren\u2019t present at the meeting","title":"Theory (2x weighting)"},{"location":"scout/standings/#skill-3x-weighting","text":"Accuracy of scouting matches from Week Zero Four assigned matches worth 100 points each Skill score/average will be based on three highest scores from all matches Formula used to assess accuracy of the data in each section of the app Prematch, auto, teleop, and postmatch data each given different weightings","title":"Skill (3x weighting)"},{"location":"scout/standings/#punctuality-75x-weighting","text":"Commitment to the scouting team, communication, and reliability Points deducted each time something is completed past its due date Registration, quizzes/kahoots, etc. 1 pt deduction for less than one week late 2 pt deduction for one week or more late If you registered late, deductions for past due assignments begin 1 week after you registered 0 pt deduction if completed in less than 1 week after registration 1 pt deduction if completed 1-2 weeks after you registered 2 pt deduction if more than 2 weeks All scouts begin with 20 points, unless you registered late Two methods are used for a composite assessment of scouts:","title":"Punctuality (75x weighting)"},{"location":"scout/standings/#running-score-primary-method","text":"Category scores (punctuality/theory/skill) are simply points earned from items from that category added together Running score is 75 \\cdot \\text{punctuality score} + 2 \\cdot \\text{theory score} + 3 \\cdot \\text{skill score} 75 \\cdot \\text{punctuality score} + 2 \\cdot \\text{theory score} + 3 \\cdot \\text{skill score} The higher the score, the better! Maximum is 3000, without bonuses Rewards completing assessments (including optional ones) and a high punctuality score","title":"Running Score (primary method)"},{"location":"scout/standings/#average-secondary-method","text":"Category averages (punctuality/theory/skill) are the average of points earned from items of that category Averages are 100 if no points are attainable from that category yet Average is 0.5 \\cdot \\text{punctuality average} + 0.2 \\cdot \\text{theory average} + 0.3 \\cdot \\text{skill average} 0.5 \\cdot \\text{punctuality average} + 0.2 \\cdot \\text{theory average} + 0.3 \\cdot \\text{skill average} The higher the average, the better! Maximum is 100 May not be an accurate depiction of how committed a scout is, but easier to understand and very similar to a school average Remember, your performance is relative to the rest of the scouting team - let's just take scouting seriously to help us win competitions!","title":"\"Average\" (secondary method)"},{"location":"strat/gamestrat/L1/","text":"Lesson 1 - Introduction to Java Raider Robotix and Java FRC Team 25, Raider Robotix , uses the Java programming language for programming both the robot and the scouting system. Java is also taught in NBTHS's computer science courses. These lessons will provide you with the building blocks of Java that are necessary to program, maintain, and understand the scouting system. It currently has two components: * Android scouting app - collects data from scouts during events and exports it in JSON (JavaScript Object Notation) files * Every year, this needs to be updated with the correct metrics, events, game manual, and other options, as necessary * Desktop scouting client - compiles the JSON files from the app and outputs spreadsheets of each scouting entry and aggregated statistics for each team * Every year, this needs to be updated with the correct metrics, which includes averages, percentages, probabilities, and standard deviations, in addition to those in the scouting app Starting from the 2017 season, Tableau is used to visualize and analyze the data from the spreadsheets generated by the client. The goal is to have you understand how the scouting system works and be comfortable with changing its code by next season's kickoff. If you want to work on robot programming instead, additional knowledge of WPILib API will be needed. Lesson Structure Generally, several concepts will be explained and grouped together to form a lesson. As each concept is taught, several practice exercises are given for you to check your understanding. At the end of the lesson, one or two problems will be assigned on HackerRank that test your understanding of all concepts in the lesson. The site allows you to check your program against several test cases and will \"grade\" it (pass or fail) instantly. Java Code Structure Java source files have a . java extension and each contain a class , which acts like an object (we'll get to this later). Each class/source file is located in a package , which acts as a folder to organize various files. Inside an executable program is a main method , in which the code inside it executes. In a desktop Java program, the method signature public static void main ( String [] args ) is used, followed by a set of curly braces. Below is an example inside a file called Example . java : // Place import statements here public class Example { public static void main ( String [] args ){ // Write your code to execute here } } As seen above line comments can be written if they are proceeded with two forward slashes ( // ). Anything following the two slashes will be ignored by the compiler when your program executes. Block comments may also be written like this: /* Hi! * I'm a block comment. */ Note the two slashes showing the beginning/end of the comment and the asterisk on each line. Variables Any data or value you use in Java is stored in a variable . A variable can have one of many different datatypes . The following are common datatypes: * int - an integer with a value between -2^31 - 1 and 2^31 -1 ( 123 , 25 , - 900 , 0 , etc.) * double - a positive or negative decimal number ( 1.23 , - 2.5 , 1.0005 , etc.) * boolean - has either a true or false value * String - a sequence of characters, enclosed in a set of quotation marks ( \"Hello World\" , \"1+1=2\" , \"Raider Robotix\" , etc.) You can declare variables with its datatype, followed by a space and its identifier , then a semicolon. The identifier must start with a letter or underscore, then be followed by more letters, underscores, or numbers, with no spaces. Valid identifiers include: * _t * motor1 * MOTOR_SPEED Generally, variables are named in a camelCase notation, where the first word is lowercase, then the remaining words are uppercase. Examples of variable declarations with camelCase naming include: int teleOpGearsCollected ; double avgKpaPerGame ; boolean baselineCrossed ; String robotComment , pilotComment ; //multiple variables can be declared with a comma separating them On the other hand, variables that are constant throughout a program should be named with only uppercase letters and underscores. Examples of these variables include: double TURN_ANGLE_TOLERANCE ; int LEFT_JOYSTICK_PORT ; String RULES_FILEPATH ; int VERSION_NUMBER ; Keep in mind that variables should not have generic identifiers like x or var1 , but ones that are descriptive. A variable can be assigned a value with its identifier followed by the assignment operator , = , and its value. This value can be literal or that of another variable. A variable may be assigned a value and declared at the same time as well. Some examples: int teleOpGearsCollected ; // declaration double avgHighGoalsTeleOp = 12.555 ; // variable declared and value of 12.555 assigned teleOpGearsCollected = 4 ; // assignment afterwards boolean baselineCrossed = true , readyTakeoff = false ; // two variables declared and assigned value String robotComment = \"This is a good robot\" ; double avgTeleOpKpa = avgHighGoalsTeleOp / 3 ; //value dependent on another variable Output Output to the console in Java can be executed with the following statement : System . out . println ( < some value > ); This calls the println method on a value, where < some value > can be a literal value or a variable. Remember to terminate the print statement with a semicolon. For example, executing System . out . println ( teleOpGearsCollected ); System . out . println ( \"gears collected in tele-op in match\" ); System . out . println ( 25 ); will result in the following output: 4 gears collected in tele - op in match 25 If you don't want a new line after the output, the System . out . print ( < some value > ) method may be used. Executing System . out . print ( teleOpGearsCollected ); System . out . println ( \" gears collected in tele-op.\" ); System . out . println ( \"Robots are cool\" ); will result in the following output: 4 gears collected in tele - op . Robots are cool An IDE An IDE (Integrated Development Environment) will be used to program in Java. It allows you to write code, execute, and debug it in one application. I recommend using Eclipse , as NBTHS and the WPILib API uses it, though alternatives like InteliJ and BlueJ exist. We will be using Android Studio as our IDE for Android development. To get started with Eclipse: 1. Download and extract the ZIP file from the link above 2. Run the executable and choose your workspace (default should work) 3. Go to File > New > Java Project and name your project 4. Close the Welcome window 5. Right click your project and go to New > Class, and name your class (without the . java extension) 6. Write your main method (see above) 7. Try replacing the comment with a statement to print Hello World 8. Press the green \"Play\" button to execute your program If there are any syntax errors in your program, Eclipse will underline them in red, and the program will not run. Try fixing them by reading the error message and reviewing your code or by using Google. A Brief Exercise : Assign the values of true , \"Raider Robotix\" , and 25 to variables. Use print statements with the variables and literal values to generate the output Hello World ! It is true that I am on Team 25 , Raider Robotix 25 is the Team Number . Input To take user input, you will need to use a Scanner object. First, you will need to import the class by placing the following import statement before the class starts (see example above): import java.util.Scanner ; The Scanner object can be declared and constructed like this to read from the system console: Scanner myScanner = new Scanner ( System . in ); The datatype is Scanner , and myScanner can be any valid identifier. Note the use of the new keyword to create a new object and the parentheses following. Several methods can be accessed through the Scanner object for different datatypes. A method essentially acts like a function and returns a value to the main program. These may be used to let users assign values to variables: int anInteger = myScanner . nextInt (); String aLine = myScanner . next (); // takes the next whole line Essentially, the dot operator ( . ) shows that the methods nextInt () and nextLine () are written in the Scanner class, and you are accessing them from an outside class. More methods for input can be found by reading the documentation for the class . If the wrong datatype is used, there will be an error in your program. By default, spaces and line breaks separating tokens in the input will result two different variables. For example, if the input is Raider Robotix executing String teamName = myScanner . next (); System . out . println ( teamName ); will output Raider while executing String teamName = myScanner . nextLine (); System . out . println ( teamName ); will output Raider Robotix Exercise Write a program that allows prompts a user to input a string, an integer, and a floating point number, then print all three once they are inputted. Operators Operators in Java allow you to interact between different datatypes. For these examples, we will declare int a = 5 , b = 4 ; double c = 2.5 ; String s = \"Hello\" ; Mathematical Evaluating these operators will result in a number of type int if both are integers, or of type double if at least one is a double : + - adds the number (an int or double ) to the left and right of it a + b is equal to 9 , a + c is equal to 7.5 - - subtracts the number on the right from the left b - a is equal to - 1 , b - c is equal to 1.5 * - multiplies the number to the left and right of it a * b is equal to 20 , b * c is equal to 10.0 / - divides the number on the left by the number on the right. However, if both numbers are int s, integer division will occur. That is, the remainder is discarded, and only the quotient remains. a / c is equal to 2.0 , b / c is equal to 1.6 a / b is equal to 1 , b / a is equal to 0 A literal int value ( 1 ) may be converted into a double value by adding a decimal point and a zero ( 1.0 ) % - the modulus operator, a % b returns the remainder of a / b a % b is equal to 1 , b % a is equal to 4 , a % c is equal to 0.0 Exercises : * Write a program that allows the user to input (integer) dimensions of a rectangular prism and outputs its surface area and volume * Write a program that prints the day of the week of a day, given the day of the week of the first day of the month (where 1=Monday, 7=Sunday) * Write a program that calculates the score of a match in FIRST Steamworks, where the user inputs the number of rotors activated during tele-op/autonomous, high/low goals in tele-op/autonomous, the times the baseline was crossed, the times robots took off, and foul points that were incurred by the opposing alliance Relational Evaluating these operators will result in a boolean value ( true or false ): < - less than, <= - less than or equal to b < a is true , 4.5 < 0 is false - 2 <= c is true , 5 <= 5 is true > - greater than, >= - greater than or equal to == - checks for equality. This can only be used for primitive datatypes, and not objects a == 5 is true , 2.0 == a / c is true false == true is false For strings, the method someString . equals ( /*another string*/ ) is used for equality because a string is an object. We'll get into this more in the next lesson. s . equals ( \"Hello\" ) is true , s . equals ( \"World\" ) is false != - checks if the two objects are not equal a != 5 is false , 1 != a / c is true false != true is true Exercise : Write a program to determine if it is true that a quadratic equation of the form 0=ax^2+bx+c has a real solution, where the user inputs a, b, and c. (Hint: For now the best way to square an integer x is x * x , as x ^ 2 will not evaluate correctly) Logical These operate on boolean values and evaluating them will also result in a boolean value: OR Operator - written as a || b , evaluates to true only if either a or b are true a b a \\ | \\ | b false false false false true true true false true true true true AND Operator - written as a && b , evaluates to true only if both a and b are true a b a && b false false false false true false true false false true true true NOT Operator - written as !a , evaluates to true only if a is false a !a false true true false Exercises * Evaluate the following expressions (without actually writing any code) for when boolean a = true , b = false and for when boolean a = true , b = true : * ( a || b ) && ( ! a || ! b ) * ! ( a && ! b ) || ( ! a && b ) * ! ( a && b ) Some Shortcuts You already learned about the assignment operator. Here are some shortcuts used for assignment with operators, if x and y are numbers and both are already declared and assigned values: x += y ; // same as x = x+y x -= y ; // same as x = x-y x /= y ; // same as x = x/y x %= y ; // same as x = x % y x ++ ; // same as x+=1 x -- ; // same as x-=1 Exercise : What is the value of x after the following is executed? int x = 60 , y = 10 ; y /= 5 ; x %= x - y ; x ++ ; x *= 4 ; Boolean Expressions A boolean expression is any expression that evaluates to true or false . It may contain literals, variables, and any of the above operators. The order of operations for evaluation are: Parentheses NOT Multiplication, division, modulus Addition, subtraction Greater/less than (or equal to) Equivalence/not equivalent AND OR The following are valid boolean expressions if x and y are numbers and b is a boolean : * x >= 5 + y && ! ( y + 5 == 7 || y < 0 || ! b ) * takeoffPercentage / avgTakeoffPercentage + 0.1 >= 1.2 && ( avgKpa >= 30 || avgGears >= 4 ) && teamNum != 25 && ! droppedGearOften Exercises * The XOR (exclusive-or) operator evaluates to be true if either A or B are true, but not both. Write an expression that is logically equivalent to \"A XOR B\" using the AND, OR, and NOT operators * Write a boolean expression to determine if at least 3 ranking points were earned by the red alliance in a match of FIRST Steamworks, given the scores of both the red and blue alliances, the number of gears delivered by the red alliance, whether or not the reserve gear was used, and the number of high/low goals into the red boiler in autonomous/tele-op. Use appropriate identifiers for variables and declare multiple, intermediate boolean expressions as necessary. Conditionals A conditional statement is one that executes if a particular boolean expression is true. The if , else , and else - if statements are written and used as follows: boolean a = < some expression > ; if ( a ){ //Code here executes if expression a is true } else if ( < some boolean expression b > ){ // Code here executes if expression b is true and a is false } else { // Code here executes if a and b are both false } Note that an if statement may be written without any else statements, but else and else - if statements must follow an if statement or an else statement. The boolean expression may also be placed inside the parentheses, rather than assigning its value to a boolean variable. These conditional statements may also be nested inside each other as follows: boolean a = < some expression > ; boolean b = < some expression > ; boolean c = < some expression > ; if ( a ){ if ( c ){ // Code here executes if a and c are true } else { //Code here executes if a is true and c is false } // Code here executes as long as a is true, no matter what the value of c is } else if ( b ){ // Code here executes if expression b is true and a is false, no matter what the value of c is if ( ! c ){ //Code here executes if a is false, b is true, and c is false } } else { // Code here executes if a and b are both false } Exercises * Write a program to determine if a number is even or odd * Write a program that prints the month, given its numerical value (1 to 12) * Write a program that converts a day of the week to a number (Monday = 1, Sunday = 7) * Write a program that converts feet to yards and vice-versa, depending on what the user wants Assignment Download Eclipse and complete the exercises above as necessary to check your understanding. Afterwards, sign up for a HackerRank account and complete the \"A School Day\" program here . I suggest that you write and test the program on Eclipse, then check if it works on HackerRank.","title":"Lesson 1: Kickoff!"},{"location":"strat/gamestrat/L1/#lesson-1-introduction-to-java","text":"","title":"Lesson 1 - Introduction to Java"},{"location":"strat/gamestrat/L1/#raider-robotix-and-java","text":"FRC Team 25, Raider Robotix , uses the Java programming language for programming both the robot and the scouting system. Java is also taught in NBTHS's computer science courses. These lessons will provide you with the building blocks of Java that are necessary to program, maintain, and understand the scouting system. It currently has two components: * Android scouting app - collects data from scouts during events and exports it in JSON (JavaScript Object Notation) files * Every year, this needs to be updated with the correct metrics, events, game manual, and other options, as necessary * Desktop scouting client - compiles the JSON files from the app and outputs spreadsheets of each scouting entry and aggregated statistics for each team * Every year, this needs to be updated with the correct metrics, which includes averages, percentages, probabilities, and standard deviations, in addition to those in the scouting app Starting from the 2017 season, Tableau is used to visualize and analyze the data from the spreadsheets generated by the client. The goal is to have you understand how the scouting system works and be comfortable with changing its code by next season's kickoff. If you want to work on robot programming instead, additional knowledge of WPILib API will be needed.","title":"Raider Robotix and Java"},{"location":"strat/gamestrat/L1/#lesson-structure","text":"Generally, several concepts will be explained and grouped together to form a lesson. As each concept is taught, several practice exercises are given for you to check your understanding. At the end of the lesson, one or two problems will be assigned on HackerRank that test your understanding of all concepts in the lesson. The site allows you to check your program against several test cases and will \"grade\" it (pass or fail) instantly.","title":"Lesson Structure"},{"location":"strat/gamestrat/L1/#java-code-structure","text":"Java source files have a . java extension and each contain a class , which acts like an object (we'll get to this later). Each class/source file is located in a package , which acts as a folder to organize various files. Inside an executable program is a main method , in which the code inside it executes. In a desktop Java program, the method signature public static void main ( String [] args ) is used, followed by a set of curly braces. Below is an example inside a file called Example . java : // Place import statements here public class Example { public static void main ( String [] args ){ // Write your code to execute here } } As seen above line comments can be written if they are proceeded with two forward slashes ( // ). Anything following the two slashes will be ignored by the compiler when your program executes. Block comments may also be written like this: /* Hi! * I'm a block comment. */ Note the two slashes showing the beginning/end of the comment and the asterisk on each line.","title":"Java Code Structure"},{"location":"strat/gamestrat/L1/#variables","text":"Any data or value you use in Java is stored in a variable . A variable can have one of many different datatypes . The following are common datatypes: * int - an integer with a value between -2^31 - 1 and 2^31 -1 ( 123 , 25 , - 900 , 0 , etc.) * double - a positive or negative decimal number ( 1.23 , - 2.5 , 1.0005 , etc.) * boolean - has either a true or false value * String - a sequence of characters, enclosed in a set of quotation marks ( \"Hello World\" , \"1+1=2\" , \"Raider Robotix\" , etc.) You can declare variables with its datatype, followed by a space and its identifier , then a semicolon. The identifier must start with a letter or underscore, then be followed by more letters, underscores, or numbers, with no spaces. Valid identifiers include: * _t * motor1 * MOTOR_SPEED Generally, variables are named in a camelCase notation, where the first word is lowercase, then the remaining words are uppercase. Examples of variable declarations with camelCase naming include: int teleOpGearsCollected ; double avgKpaPerGame ; boolean baselineCrossed ; String robotComment , pilotComment ; //multiple variables can be declared with a comma separating them On the other hand, variables that are constant throughout a program should be named with only uppercase letters and underscores. Examples of these variables include: double TURN_ANGLE_TOLERANCE ; int LEFT_JOYSTICK_PORT ; String RULES_FILEPATH ; int VERSION_NUMBER ; Keep in mind that variables should not have generic identifiers like x or var1 , but ones that are descriptive. A variable can be assigned a value with its identifier followed by the assignment operator , = , and its value. This value can be literal or that of another variable. A variable may be assigned a value and declared at the same time as well. Some examples: int teleOpGearsCollected ; // declaration double avgHighGoalsTeleOp = 12.555 ; // variable declared and value of 12.555 assigned teleOpGearsCollected = 4 ; // assignment afterwards boolean baselineCrossed = true , readyTakeoff = false ; // two variables declared and assigned value String robotComment = \"This is a good robot\" ; double avgTeleOpKpa = avgHighGoalsTeleOp / 3 ; //value dependent on another variable","title":"Variables"},{"location":"strat/gamestrat/L1/#output","text":"Output to the console in Java can be executed with the following statement : System . out . println ( < some value > ); This calls the println method on a value, where < some value > can be a literal value or a variable. Remember to terminate the print statement with a semicolon. For example, executing System . out . println ( teleOpGearsCollected ); System . out . println ( \"gears collected in tele-op in match\" ); System . out . println ( 25 ); will result in the following output: 4 gears collected in tele - op in match 25 If you don't want a new line after the output, the System . out . print ( < some value > ) method may be used. Executing System . out . print ( teleOpGearsCollected ); System . out . println ( \" gears collected in tele-op.\" ); System . out . println ( \"Robots are cool\" ); will result in the following output: 4 gears collected in tele - op . Robots are cool","title":"Output"},{"location":"strat/gamestrat/L1/#an-ide","text":"An IDE (Integrated Development Environment) will be used to program in Java. It allows you to write code, execute, and debug it in one application. I recommend using Eclipse , as NBTHS and the WPILib API uses it, though alternatives like InteliJ and BlueJ exist. We will be using Android Studio as our IDE for Android development. To get started with Eclipse: 1. Download and extract the ZIP file from the link above 2. Run the executable and choose your workspace (default should work) 3. Go to File > New > Java Project and name your project 4. Close the Welcome window 5. Right click your project and go to New > Class, and name your class (without the . java extension) 6. Write your main method (see above) 7. Try replacing the comment with a statement to print Hello World 8. Press the green \"Play\" button to execute your program If there are any syntax errors in your program, Eclipse will underline them in red, and the program will not run. Try fixing them by reading the error message and reviewing your code or by using Google. A Brief Exercise : Assign the values of true , \"Raider Robotix\" , and 25 to variables. Use print statements with the variables and literal values to generate the output Hello World ! It is true that I am on Team 25 , Raider Robotix 25 is the Team Number .","title":"An IDE"},{"location":"strat/gamestrat/L1/#input","text":"To take user input, you will need to use a Scanner object. First, you will need to import the class by placing the following import statement before the class starts (see example above): import java.util.Scanner ; The Scanner object can be declared and constructed like this to read from the system console: Scanner myScanner = new Scanner ( System . in ); The datatype is Scanner , and myScanner can be any valid identifier. Note the use of the new keyword to create a new object and the parentheses following. Several methods can be accessed through the Scanner object for different datatypes. A method essentially acts like a function and returns a value to the main program. These may be used to let users assign values to variables: int anInteger = myScanner . nextInt (); String aLine = myScanner . next (); // takes the next whole line Essentially, the dot operator ( . ) shows that the methods nextInt () and nextLine () are written in the Scanner class, and you are accessing them from an outside class. More methods for input can be found by reading the documentation for the class . If the wrong datatype is used, there will be an error in your program. By default, spaces and line breaks separating tokens in the input will result two different variables. For example, if the input is Raider Robotix executing String teamName = myScanner . next (); System . out . println ( teamName ); will output Raider while executing String teamName = myScanner . nextLine (); System . out . println ( teamName ); will output Raider Robotix Exercise Write a program that allows prompts a user to input a string, an integer, and a floating point number, then print all three once they are inputted.","title":"Input"},{"location":"strat/gamestrat/L1/#operators","text":"Operators in Java allow you to interact between different datatypes. For these examples, we will declare int a = 5 , b = 4 ; double c = 2.5 ; String s = \"Hello\" ;","title":"Operators"},{"location":"strat/gamestrat/L1/#mathematical","text":"Evaluating these operators will result in a number of type int if both are integers, or of type double if at least one is a double : + - adds the number (an int or double ) to the left and right of it a + b is equal to 9 , a + c is equal to 7.5 - - subtracts the number on the right from the left b - a is equal to - 1 , b - c is equal to 1.5 * - multiplies the number to the left and right of it a * b is equal to 20 , b * c is equal to 10.0 / - divides the number on the left by the number on the right. However, if both numbers are int s, integer division will occur. That is, the remainder is discarded, and only the quotient remains. a / c is equal to 2.0 , b / c is equal to 1.6 a / b is equal to 1 , b / a is equal to 0 A literal int value ( 1 ) may be converted into a double value by adding a decimal point and a zero ( 1.0 ) % - the modulus operator, a % b returns the remainder of a / b a % b is equal to 1 , b % a is equal to 4 , a % c is equal to 0.0 Exercises : * Write a program that allows the user to input (integer) dimensions of a rectangular prism and outputs its surface area and volume * Write a program that prints the day of the week of a day, given the day of the week of the first day of the month (where 1=Monday, 7=Sunday) * Write a program that calculates the score of a match in FIRST Steamworks, where the user inputs the number of rotors activated during tele-op/autonomous, high/low goals in tele-op/autonomous, the times the baseline was crossed, the times robots took off, and foul points that were incurred by the opposing alliance","title":"Mathematical"},{"location":"strat/gamestrat/L1/#relational","text":"Evaluating these operators will result in a boolean value ( true or false ): < - less than, <= - less than or equal to b < a is true , 4.5 < 0 is false - 2 <= c is true , 5 <= 5 is true > - greater than, >= - greater than or equal to == - checks for equality. This can only be used for primitive datatypes, and not objects a == 5 is true , 2.0 == a / c is true false == true is false For strings, the method someString . equals ( /*another string*/ ) is used for equality because a string is an object. We'll get into this more in the next lesson. s . equals ( \"Hello\" ) is true , s . equals ( \"World\" ) is false != - checks if the two objects are not equal a != 5 is false , 1 != a / c is true false != true is true Exercise : Write a program to determine if it is true that a quadratic equation of the form 0=ax^2+bx+c has a real solution, where the user inputs a, b, and c. (Hint: For now the best way to square an integer x is x * x , as x ^ 2 will not evaluate correctly)","title":"Relational"},{"location":"strat/gamestrat/L1/#logical","text":"These operate on boolean values and evaluating them will also result in a boolean value: OR Operator - written as a || b , evaluates to true only if either a or b are true a b a \\ | \\ | b false false false false true true true false true true true true AND Operator - written as a && b , evaluates to true only if both a and b are true a b a && b false false false false true false true false false true true true NOT Operator - written as !a , evaluates to true only if a is false a !a false true true false Exercises * Evaluate the following expressions (without actually writing any code) for when boolean a = true , b = false and for when boolean a = true , b = true : * ( a || b ) && ( ! a || ! b ) * ! ( a && ! b ) || ( ! a && b ) * ! ( a && b )","title":"Logical"},{"location":"strat/gamestrat/L1/#some-shortcuts","text":"You already learned about the assignment operator. Here are some shortcuts used for assignment with operators, if x and y are numbers and both are already declared and assigned values: x += y ; // same as x = x+y x -= y ; // same as x = x-y x /= y ; // same as x = x/y x %= y ; // same as x = x % y x ++ ; // same as x+=1 x -- ; // same as x-=1 Exercise : What is the value of x after the following is executed? int x = 60 , y = 10 ; y /= 5 ; x %= x - y ; x ++ ; x *= 4 ;","title":"Some Shortcuts"},{"location":"strat/gamestrat/L1/#boolean-expressions","text":"A boolean expression is any expression that evaluates to true or false . It may contain literals, variables, and any of the above operators. The order of operations for evaluation are: Parentheses NOT Multiplication, division, modulus Addition, subtraction Greater/less than (or equal to) Equivalence/not equivalent AND OR The following are valid boolean expressions if x and y are numbers and b is a boolean : * x >= 5 + y && ! ( y + 5 == 7 || y < 0 || ! b ) * takeoffPercentage / avgTakeoffPercentage + 0.1 >= 1.2 && ( avgKpa >= 30 || avgGears >= 4 ) && teamNum != 25 && ! droppedGearOften Exercises * The XOR (exclusive-or) operator evaluates to be true if either A or B are true, but not both. Write an expression that is logically equivalent to \"A XOR B\" using the AND, OR, and NOT operators * Write a boolean expression to determine if at least 3 ranking points were earned by the red alliance in a match of FIRST Steamworks, given the scores of both the red and blue alliances, the number of gears delivered by the red alliance, whether or not the reserve gear was used, and the number of high/low goals into the red boiler in autonomous/tele-op. Use appropriate identifiers for variables and declare multiple, intermediate boolean expressions as necessary.","title":"Boolean Expressions"},{"location":"strat/gamestrat/L1/#conditionals","text":"A conditional statement is one that executes if a particular boolean expression is true. The if , else , and else - if statements are written and used as follows: boolean a = < some expression > ; if ( a ){ //Code here executes if expression a is true } else if ( < some boolean expression b > ){ // Code here executes if expression b is true and a is false } else { // Code here executes if a and b are both false } Note that an if statement may be written without any else statements, but else and else - if statements must follow an if statement or an else statement. The boolean expression may also be placed inside the parentheses, rather than assigning its value to a boolean variable. These conditional statements may also be nested inside each other as follows: boolean a = < some expression > ; boolean b = < some expression > ; boolean c = < some expression > ; if ( a ){ if ( c ){ // Code here executes if a and c are true } else { //Code here executes if a is true and c is false } // Code here executes as long as a is true, no matter what the value of c is } else if ( b ){ // Code here executes if expression b is true and a is false, no matter what the value of c is if ( ! c ){ //Code here executes if a is false, b is true, and c is false } } else { // Code here executes if a and b are both false } Exercises * Write a program to determine if a number is even or odd * Write a program that prints the month, given its numerical value (1 to 12) * Write a program that converts a day of the week to a number (Monday = 1, Sunday = 7) * Write a program that converts feet to yards and vice-versa, depending on what the user wants","title":"Conditionals"},{"location":"strat/gamestrat/L1/#assignment","text":"Download Eclipse and complete the exercises above as necessary to check your understanding. Afterwards, sign up for a HackerRank account and complete the \"A School Day\" program here . I suggest that you write and test the program on Eclipse, then check if it works on HackerRank.","title":"Assignment"},{"location":"strat/gamestrat/L2/","text":"Lesson 2 - Loops, Strings, Math After a (probably pretty long) first lesson, let's explore a couple more features of Java and see what you can do with everything that you learned. Loops Loops are used to execute a block of code enclosed in a set of braces ( {} ) multiple times. After all, computers are very good at doing the same thing over and over again! The number of times a block executes depends on a boolean expression. while Loops while loops execute as long as a boolean expression is true . It may not execute at all if the expression is false before entering the loop. while ( /*some boolean expression*/ ){ //Execute code here multiple times as long as the expression is true } Remember that the boolean expression should become false at some point during the execution of the code in the loop. Otherwise, an infinite loop will be created. For example, the following will print the numbers from 1 to 10 (inclusive): int counter = 1 ; while ( counter <= 10 ){ System . out . println ( counter ); counter ++ ; } do - while loops may also be written. The main difference between these and while loops is that the boolean expression must be true at the end of the loop, not at the beginning. The following prints the numbers from 1 to 10 (inclusive): int counter = - 1 ; do { counter ++ ; System . out . println ( counter ); } while ( counter < 10 ); for Loops for loops provide a more controlled way for iterating through a loop multiple times. There are three components to the for loop: the initial statement, the exit condition (boolean expression), and the post-excution statement. The example for ( /*initial statement*/ ; /*exit condition*/ ; /*post-execution statement*/ ){ //Code to be executed each loop } is essentially equal to the following while loop: //Initial statement while ( /*exit condition*/ ){ //Code to be executed each loop //Post-execution statement } The for loop is commonly used to execute a loop a certain number of times. Below, the loop prints the numbers from 0 to 9 (10 iterations): for ( int count = 0 ; i < 10 ; count ++ ){ System . out . println ( count ); } Keep in mind that the variable count is declared within the loop, and it cannot accessed outside it. Loops may also be placed inside each other. For example, executing for ( int row = 1 ; row <= 12 ; row ++ ){ for ( int col = 1 ; col <= 12 ; col ++ ){ System . out . print ( row * col ); System . out . print ( \" \" ); //adds a space } System . out . println (); //line break } will print a (poorly formatted) times table. Note that all three parts of a for loop are optional. That is, a loop like for (;;) { //something } will execute forever. Questions Determine the number of times the following for loops will execute. for ( int i = 4 ; i <= 8 ; i += 2 ) { /*do something*/ } for ( int i = 10 ; i >= 0 ; i -= 3 ) { /*do something*/ } for ( int j = 2 ; j >= 4 ; j ++ ) { /*do something*/ } Exercises Write a program that computes the sum of all odd integers from 1 to a number specified by the user Write a program that computes b^e (a number raised to the power of an exponent), where b and e are positive integers Write a program that allows the user to enter a number, setSize . setSize numbers, num , follow and are inputted by the user. Print the average, largest, and smallest of the numbers. Loop Control There are two control statements that are used with loops: break The break statement will immediately exit a while or for loop. This can be useful if you're looking for a specific value, and you want the loop to end after you've found that value. For instance, in the below example, the loop will terminate immediately after the value key is found: int key = 8 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( i == key ) { System . out . println ( \"Found\" ); break ; } System . out . println ( \"Not found...\" ); } As a result, Not found ... will be printed out eight times at first, followed by Found . The loop will then terminate. The break statement will be more useful after you learn about arrays. continue The continue statement will immediately go to the next iteration of a for or while loop, bypassing all statements after it. This could be used when you only want to execute a loop for some values. Of course, an if - else statement can often accomplish the same thing, but break and continue statements can prevent too many nested blocks of code. For instance, the following block of code for ( int i = 0 ; i < 4 ; i ++ ) { System . out . println ( \"Going... \" + i ); if ( i >= 2 ) { continue ; } System . out . println ( \"Here\" ); } will print Going ... 0 Here Going ... 1 Here Going ... 2 Going ... 3 Characters In addition to the primitive data types ( boolean , int , double ) we learned about before, char s represent one of the 256 ASCII characters . These include the numbers, standard symbols and punctuation on a keyboard, and both uppercase and lowercase letters. A char is assigned a value with the declaration char allianceColor = 'R' ; Note the use of single quotation marks rather than double quotation marks (which are used for String s) and that a variable of type char may only contain a single character. Escape characters are the first 32 ASCII characters, which serve special functions. The most commonly used is '\\n' , which creates a line break. In addition, quotation marks must be escaped. Thus, executing the following code char quote1 = '\\'' ; char quote2 = '\\\"' ; char newLine = '\\n' System . out . print ( quote1 ); System . out . print ( newLine ); System . out . print ( quote2 ); will print ' \" Note that strings can be thought of as a series of char s concatenated together. For instance, executing String someText = \"Kickoff, 2017 \\n As we anticipated the new game, the livestream blared, \\\" STEAM POWERED! STEAM POWERED! STEAM POWERED! \\\" \" ; System . out . println ( someText ); will print Kickoff , 2017 As we anticipated the new game , the livestream blared , \"STEAM POWERED! STEAM POWERED! STEAM POWERED!\" The value of characters may be compared with the equivalence ( == ) operator. For example, allianceColor == 'R' is true . Note, however, that a character is not equal its int equivalent. That is, '1' == 1 is false . String Manipulation The String class in Java contains many methods to manipulate strings. We will present an overview of the most useful ones, though you may read the full documentation here . Concatenation A string can be concatenated , or joined together, with other strings or primitive datatypes (and literals) with the + operator. For example, executing the following: String mascot = \"Raider\" ; int teamNum = 25 ; String teamName = mascot + \" Robotix\" ; System . out . println ( \"The year is \" + 2017 ); System . out . println ( \"I am on Team \" + teamNum + \", \" + teamName ); will print The year is 2017 I am on Team 25 , Raider Robotix You may also concatenate a string onto the end of another with the += operator. Executing String s = \"Hello\" ; s += \" World!\" ; System . out . println ( s ); will print Hello World ! . String Properties You can check the length of a string (number of characters) with the string . length () method. Executing String s = \"Hello\" ; System . out . println ( s + \" is \" + s . length () + \" characters long\" ); System . out . print ( \"World!\" . length ()); will print Hello is 5 characters long 6 You can also check if a string contains a specific character sequence with the string . contains ( < character sequence > ) method, which returns a boolean value. If String s = \"Hello\" ; is declared, s . contains ( \"ell\" ) returns true , while s . contains ( \"f\" ) returns false . Parsing a String You may want to parse through a string sometimes, or check the sequence of its characters. The string . charAt ( /*index*/ ) method will return the character currently at the index. There are two things you should know about the method: The method will return a value of type char (character), rather than String . The index is a value that is greater than or equal to 0 and less than string . length () . That is, the index of the first character in the string is 0 , and the index of the last character in the string is string . length () - 1 . If String s = \"World\" ; is declared, s . charAt ( 0 ) returns 'W' , s . charAt ( 3 ) returns 'l' , and s . charAt ( 4 ) returns 'd' . A standard way to parse through all of the characters of a string is with the following for loop: String str = \"Hello World!\" ; for ( int i = 0 ; i < str . length (); i ++ ){ char currentChar = str . charAt ( i ); //Do something here } Substrings Suppose you want to return a slice of a string, known as a substring, such as the first letter four letters of String s = \"Raider Robotix\" ; . An easy-to-understand way would be to use string parsing, similar to what we did above: String s = \"Raider Robotix\" ; String result = \"\" ; // an empty string for ( int i = 0 ; i < 4 && i < s . length (); i ++ ){ result += s . charAt ( i ); } System . out . println ( result ); This would print out Raid . Note that the expression i < s . length () was still present in the exit condition in order to prevent errors if s was an input string that was less than four characters long. However, a faster way to get result would be to use the substring ( beginIndex , endIndex ) method, in which beginIndex and endIndex are integers that represent the indicies that you want to search. Similar to the for loop above, beginIndex is inclusive, while endIndex is exclusive. Here are some examples: s . substring ( 0 , 4 ); returns Raid s . substring ( 7 , s . length ()); returns Robotix \"hamburger\" . substring ( 4 , 8 ); returns urge Miscellaneous String Functions Assume that String s = \"Hello\" ; is declared in the following examples: s . toLowerCase (); returns hello s . toUpperCase (); returns HELLO s . indexOf ( \"l\" ); returns 2 (the first occurence of l in s ), while s . lastIndexOf ( \"l\" ) returns 3 s . concat ( \"world\" ); returns Helloworld As mentioned before, string equality is checked with s . equals ( \"Hello\" ); , which would return true . On the other hand, after declaring String anotherString = \"Hello\" ; , the boolean expression s == anotherString || s == \"Hello\" would be false , as string are objects , not primitives . Exercises * Write a program to reverse a string if it has an R in it. * Write a program to check if a string is a palindrome (reads the same backward as forward, such as racecar) * Write a program to replaces all commas from a string with semicolons The Math Class The Math class contains several methods that you may find helpful. It is imported by default, and documentation is found here . For these examples, we will declare double a = 4.5 , b = - 2.5 ; Math . abs ( b ) : takes the absolute value of a number, returns 2.5 in the example Math . ceil ( a ) : takes the ceiling of a number (rounds it up if it is a decimal), returns 5 in the example Math . floor ( a ) : takes the floor of a number (rounds it down if it is a decimal), returns 4 in the example Math . pow ( a - 0.5 , - b + 0.5 ) : takes the first number to the power of the second number, returns 125.0 in the example Math . sqrt ( a - 0.5 ) : takes the square root of a number, returns 2.0 in this example Math . PI : returns the value of pi (3.141592653589793) Math . random () : returns a random double in the interval [0.0, 1.0). This can be used to generate a random integer within a particular range by clamping the number down, then casting it to an int . For example, if you want a random integer in the interval [ lower , upper ], you would declare int randInt = ( int ) ( Math . random () * ( upper - lower )) + lower ; . Try it out! Exercises * Write a program that solves quadratic equations of the form 0=ax^2+bx+c for x, where a, b, and c are coefficients given by the user * Write a program that calculates the average of a data set, given the numbers in the set and its length * Write a program to find the surface area and volume of a square pyramid, given its side length and height * Write a program to round a number to a specific number of decimal places Assignment Complete the \"Raider Robotix Printer\" and \"Binary Converter\" programs on HackerRank.","title":"Lesson 2: Metrics"},{"location":"strat/gamestrat/L2/#lesson-2-loops-strings-math","text":"After a (probably pretty long) first lesson, let's explore a couple more features of Java and see what you can do with everything that you learned.","title":"Lesson 2 - Loops, Strings, Math"},{"location":"strat/gamestrat/L2/#loops","text":"Loops are used to execute a block of code enclosed in a set of braces ( {} ) multiple times. After all, computers are very good at doing the same thing over and over again! The number of times a block executes depends on a boolean expression.","title":"Loops"},{"location":"strat/gamestrat/L2/#while-loops","text":"while loops execute as long as a boolean expression is true . It may not execute at all if the expression is false before entering the loop. while ( /*some boolean expression*/ ){ //Execute code here multiple times as long as the expression is true } Remember that the boolean expression should become false at some point during the execution of the code in the loop. Otherwise, an infinite loop will be created. For example, the following will print the numbers from 1 to 10 (inclusive): int counter = 1 ; while ( counter <= 10 ){ System . out . println ( counter ); counter ++ ; } do - while loops may also be written. The main difference between these and while loops is that the boolean expression must be true at the end of the loop, not at the beginning. The following prints the numbers from 1 to 10 (inclusive): int counter = - 1 ; do { counter ++ ; System . out . println ( counter ); } while ( counter < 10 );","title":"while Loops"},{"location":"strat/gamestrat/L2/#for-loops","text":"for loops provide a more controlled way for iterating through a loop multiple times. There are three components to the for loop: the initial statement, the exit condition (boolean expression), and the post-excution statement. The example for ( /*initial statement*/ ; /*exit condition*/ ; /*post-execution statement*/ ){ //Code to be executed each loop } is essentially equal to the following while loop: //Initial statement while ( /*exit condition*/ ){ //Code to be executed each loop //Post-execution statement } The for loop is commonly used to execute a loop a certain number of times. Below, the loop prints the numbers from 0 to 9 (10 iterations): for ( int count = 0 ; i < 10 ; count ++ ){ System . out . println ( count ); } Keep in mind that the variable count is declared within the loop, and it cannot accessed outside it. Loops may also be placed inside each other. For example, executing for ( int row = 1 ; row <= 12 ; row ++ ){ for ( int col = 1 ; col <= 12 ; col ++ ){ System . out . print ( row * col ); System . out . print ( \" \" ); //adds a space } System . out . println (); //line break } will print a (poorly formatted) times table. Note that all three parts of a for loop are optional. That is, a loop like for (;;) { //something } will execute forever. Questions Determine the number of times the following for loops will execute. for ( int i = 4 ; i <= 8 ; i += 2 ) { /*do something*/ } for ( int i = 10 ; i >= 0 ; i -= 3 ) { /*do something*/ } for ( int j = 2 ; j >= 4 ; j ++ ) { /*do something*/ } Exercises Write a program that computes the sum of all odd integers from 1 to a number specified by the user Write a program that computes b^e (a number raised to the power of an exponent), where b and e are positive integers Write a program that allows the user to enter a number, setSize . setSize numbers, num , follow and are inputted by the user. Print the average, largest, and smallest of the numbers.","title":"for Loops"},{"location":"strat/gamestrat/L2/#loop-control","text":"There are two control statements that are used with loops:","title":"Loop Control"},{"location":"strat/gamestrat/L2/#break","text":"The break statement will immediately exit a while or for loop. This can be useful if you're looking for a specific value, and you want the loop to end after you've found that value. For instance, in the below example, the loop will terminate immediately after the value key is found: int key = 8 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( i == key ) { System . out . println ( \"Found\" ); break ; } System . out . println ( \"Not found...\" ); } As a result, Not found ... will be printed out eight times at first, followed by Found . The loop will then terminate. The break statement will be more useful after you learn about arrays.","title":"break"},{"location":"strat/gamestrat/L2/#continue","text":"The continue statement will immediately go to the next iteration of a for or while loop, bypassing all statements after it. This could be used when you only want to execute a loop for some values. Of course, an if - else statement can often accomplish the same thing, but break and continue statements can prevent too many nested blocks of code. For instance, the following block of code for ( int i = 0 ; i < 4 ; i ++ ) { System . out . println ( \"Going... \" + i ); if ( i >= 2 ) { continue ; } System . out . println ( \"Here\" ); } will print Going ... 0 Here Going ... 1 Here Going ... 2 Going ... 3","title":"continue"},{"location":"strat/gamestrat/L2/#characters","text":"In addition to the primitive data types ( boolean , int , double ) we learned about before, char s represent one of the 256 ASCII characters . These include the numbers, standard symbols and punctuation on a keyboard, and both uppercase and lowercase letters. A char is assigned a value with the declaration char allianceColor = 'R' ; Note the use of single quotation marks rather than double quotation marks (which are used for String s) and that a variable of type char may only contain a single character. Escape characters are the first 32 ASCII characters, which serve special functions. The most commonly used is '\\n' , which creates a line break. In addition, quotation marks must be escaped. Thus, executing the following code char quote1 = '\\'' ; char quote2 = '\\\"' ; char newLine = '\\n' System . out . print ( quote1 ); System . out . print ( newLine ); System . out . print ( quote2 ); will print ' \" Note that strings can be thought of as a series of char s concatenated together. For instance, executing String someText = \"Kickoff, 2017 \\n As we anticipated the new game, the livestream blared, \\\" STEAM POWERED! STEAM POWERED! STEAM POWERED! \\\" \" ; System . out . println ( someText ); will print Kickoff , 2017 As we anticipated the new game , the livestream blared , \"STEAM POWERED! STEAM POWERED! STEAM POWERED!\" The value of characters may be compared with the equivalence ( == ) operator. For example, allianceColor == 'R' is true . Note, however, that a character is not equal its int equivalent. That is, '1' == 1 is false .","title":"Characters"},{"location":"strat/gamestrat/L2/#string-manipulation","text":"The String class in Java contains many methods to manipulate strings. We will present an overview of the most useful ones, though you may read the full documentation here .","title":"String Manipulation"},{"location":"strat/gamestrat/L2/#concatenation","text":"A string can be concatenated , or joined together, with other strings or primitive datatypes (and literals) with the + operator. For example, executing the following: String mascot = \"Raider\" ; int teamNum = 25 ; String teamName = mascot + \" Robotix\" ; System . out . println ( \"The year is \" + 2017 ); System . out . println ( \"I am on Team \" + teamNum + \", \" + teamName ); will print The year is 2017 I am on Team 25 , Raider Robotix You may also concatenate a string onto the end of another with the += operator. Executing String s = \"Hello\" ; s += \" World!\" ; System . out . println ( s ); will print Hello World ! .","title":"Concatenation"},{"location":"strat/gamestrat/L2/#string-properties","text":"You can check the length of a string (number of characters) with the string . length () method. Executing String s = \"Hello\" ; System . out . println ( s + \" is \" + s . length () + \" characters long\" ); System . out . print ( \"World!\" . length ()); will print Hello is 5 characters long 6 You can also check if a string contains a specific character sequence with the string . contains ( < character sequence > ) method, which returns a boolean value. If String s = \"Hello\" ; is declared, s . contains ( \"ell\" ) returns true , while s . contains ( \"f\" ) returns false .","title":"String Properties"},{"location":"strat/gamestrat/L2/#parsing-a-string","text":"You may want to parse through a string sometimes, or check the sequence of its characters. The string . charAt ( /*index*/ ) method will return the character currently at the index. There are two things you should know about the method: The method will return a value of type char (character), rather than String . The index is a value that is greater than or equal to 0 and less than string . length () . That is, the index of the first character in the string is 0 , and the index of the last character in the string is string . length () - 1 . If String s = \"World\" ; is declared, s . charAt ( 0 ) returns 'W' , s . charAt ( 3 ) returns 'l' , and s . charAt ( 4 ) returns 'd' . A standard way to parse through all of the characters of a string is with the following for loop: String str = \"Hello World!\" ; for ( int i = 0 ; i < str . length (); i ++ ){ char currentChar = str . charAt ( i ); //Do something here }","title":"Parsing a String"},{"location":"strat/gamestrat/L2/#substrings","text":"Suppose you want to return a slice of a string, known as a substring, such as the first letter four letters of String s = \"Raider Robotix\" ; . An easy-to-understand way would be to use string parsing, similar to what we did above: String s = \"Raider Robotix\" ; String result = \"\" ; // an empty string for ( int i = 0 ; i < 4 && i < s . length (); i ++ ){ result += s . charAt ( i ); } System . out . println ( result ); This would print out Raid . Note that the expression i < s . length () was still present in the exit condition in order to prevent errors if s was an input string that was less than four characters long. However, a faster way to get result would be to use the substring ( beginIndex , endIndex ) method, in which beginIndex and endIndex are integers that represent the indicies that you want to search. Similar to the for loop above, beginIndex is inclusive, while endIndex is exclusive. Here are some examples: s . substring ( 0 , 4 ); returns Raid s . substring ( 7 , s . length ()); returns Robotix \"hamburger\" . substring ( 4 , 8 ); returns urge","title":"Substrings"},{"location":"strat/gamestrat/L2/#miscellaneous-string-functions","text":"Assume that String s = \"Hello\" ; is declared in the following examples: s . toLowerCase (); returns hello s . toUpperCase (); returns HELLO s . indexOf ( \"l\" ); returns 2 (the first occurence of l in s ), while s . lastIndexOf ( \"l\" ) returns 3 s . concat ( \"world\" ); returns Helloworld As mentioned before, string equality is checked with s . equals ( \"Hello\" ); , which would return true . On the other hand, after declaring String anotherString = \"Hello\" ; , the boolean expression s == anotherString || s == \"Hello\" would be false , as string are objects , not primitives . Exercises * Write a program to reverse a string if it has an R in it. * Write a program to check if a string is a palindrome (reads the same backward as forward, such as racecar) * Write a program to replaces all commas from a string with semicolons","title":"Miscellaneous String Functions"},{"location":"strat/gamestrat/L2/#the-math-class","text":"The Math class contains several methods that you may find helpful. It is imported by default, and documentation is found here . For these examples, we will declare double a = 4.5 , b = - 2.5 ; Math . abs ( b ) : takes the absolute value of a number, returns 2.5 in the example Math . ceil ( a ) : takes the ceiling of a number (rounds it up if it is a decimal), returns 5 in the example Math . floor ( a ) : takes the floor of a number (rounds it down if it is a decimal), returns 4 in the example Math . pow ( a - 0.5 , - b + 0.5 ) : takes the first number to the power of the second number, returns 125.0 in the example Math . sqrt ( a - 0.5 ) : takes the square root of a number, returns 2.0 in this example Math . PI : returns the value of pi (3.141592653589793) Math . random () : returns a random double in the interval [0.0, 1.0). This can be used to generate a random integer within a particular range by clamping the number down, then casting it to an int . For example, if you want a random integer in the interval [ lower , upper ], you would declare int randInt = ( int ) ( Math . random () * ( upper - lower )) + lower ; . Try it out! Exercises * Write a program that solves quadratic equations of the form 0=ax^2+bx+c for x, where a, b, and c are coefficients given by the user * Write a program that calculates the average of a data set, given the numbers in the set and its length * Write a program to find the surface area and volume of a square pyramid, given its side length and height * Write a program to round a number to a specific number of decimal places","title":"The Math Class"},{"location":"strat/gamestrat/L2/#assignment","text":"Complete the \"Raider Robotix Printer\" and \"Binary Converter\" programs on HackerRank.","title":"Assignment"},{"location":"strat/gamestrat/L3/","text":"Lesson 3 - Methods Here's a short lesson on one of the building blocks of Java that will prepare you for object-orientated programming: methods. Method signature A method (also known as a function in other languages) is essentially a function, very similar to one that you would encounter in math class. It has an input, an output, and a name (or identifier), though these must have specific data types (think a limited domain/range). Here is a sample method ( isEven ) being declared within a class: public class Example { public boolean isEven ( int num ){ if ( num % 2 == 0 ){ return true ; } return false ; } public static void main ( String [] args ){ //main method //code executed here first } } In this example, the method signature is simply public boolean isEven ( int num ) . It consists of visibility modifiers ( public , private , protected , etc.), a return type ( boolean ), a method identifier ( isEven ), and a set of parameters ( int num ). These parameters must each have a datatype, followed by an identifier, similar to declaring a variable. To list multiple parameters, list each one individually within the parentheses, then separate them with a comma, like in the following example: public int getNumRpPowerUp ( int redScore , int blueScore , boolean autoQuestComplete , int numClimbs , boolean levitateUsed ){ int totalRp = 0 ; if ( redScore > blueScore ) totalRp += 2 ; if ( redScore == blueScore ) totalRp ++ ; if ( autoQuestComplete ) totalRp ++ if ( numClimbs == 3 || numClimbs == 2 && levitateUsed ) totalRp ++ return totalRp ; } Note that a value with the same type as the specified return type ( int in this case) must be returned by the method. This is accomplished by typing the word return followed by a variable or literal value of the specified return type. For instance, the statement return 0 ; would be valid in getNumRpPowerUp as well. Note that the method immediately ends once a return statement is executed. It it possible for a method to have no parameters and/or return type as well. With no parameters, simply leave the contents of the parentheses following the method name blank: public String getInfoString (){ return \"Hello World!\" ; } If you don't want to return a value from the method, the return type should be specified as void . A return statement is not necessary: public void printInfo ( int currentMatchNum , String scoutName ){ System . out . println ( scoutName + \" - Match \" + currentMatchNum ); } You've already used methods to find properties of an object or to compute values, such as with str . length () or Math . pow ( base , power ) . In general, a method call is accomplished by typing the method name, followed by its parameters. The return value (if there is one) can then be used, either within a conditional statement, loop, or assigned to a variable: int red = 200 , blue = 30 , climbs = 1 ; boolean levitated = true ; int rpGained = getNumRpPowerUp ( red , blue , true , climbs , levitated ); while ( isEven ( rpGained )){ //do something } Why methods? So, why are methods so important if they're just executing a block of pre-written code? Well, creating multiple methods in an application or program allows you to break down a problem and do certain tasks repeatedly. For instance, if you wanted to test if a series of numbers were even in different parts of a program, it would be easier to make a call to isEven ( num ) rather than remembering that if a number mod 2 is 0, it is even. Another way to structure an application is to have methods responsible for specific tasks, such as saving a file or verifying if a password matches the one that was stored. As long as you test a method after you write it and ensure it gives the correct output for a variety of input parameters, you can use it throughout an application without needing to refer back to the actual method's source code. That also makes it easy to collaborate with each other, as each person working on a project could be responsible for writing and testing one method; as long as those work independently, you could implement them together in the final product. Overloading methods Sometimes, a method should be able to have different set of parameters, of different data types. In this case, the parameter list will need to be modfied: public double average ( int num1 , int num2 ){ return ( num1 + num2 ) / 2.0 ; } public double average ( double a , double b ){ return ( a + b ) / 2.0 ; } Depending on the datatypes of the parameters when you make the method call, the compiler will know which method to execute. Note that the return type for a particular method name must always be the same, and a method cannot be overloaded if its signature is otherwise identical (parameters have the same datatypes, in the same order). Recursion Like in math, methods can call themselves or other methods within the body of their code. For instance, the following returns the n th Fibonacci number (1, 1, 2, 3, 5, ...): int fib ( int n ){ if ( n == 1 ) return 1 ; if ( n == 2 ) return 1 ; return fib ( n - 1 ) + fib ( n - 2 ); } Recursion is useful for creating simple methods, but their running time can sometimes be slow, and you must always ensure that you reach a base case ( n == 1 or n == 2 in this example) that returns a literal value. Refer to the binary search method if you want to see a more complex example of recursion. Algorithmic challenges Do as many as you want, until you get a good feel of when to implement methods and how to break down a problem: Write a recursive method to compute the factorial of a number. Note that 0! is equal to 1. Write a program that takes any English sentence without punctuation as an input, then converts it to Pig Latin . Implement a more efficient (non-recursive) algorithm to find the n th Fibonacci number Determine the sum of all prime numbers from 2 to a number specified by the user. A number is superb if and only if the sum of all of its factors (excluding itself) is less than a number. Write a program to determine the number of superb numbers between two numbers (e.g. 1 and 100) that are specified by the user. Given a series of variable identifiers in camelCase, identify the number of actual words in the string (e.g. numberOfRankingPoints has four actual words). Given the length of a set of integers S, followed the elements (numbers) of S, determine if S contains only consecutive integers, without repeats (e.g. {3, 5, 4, 6} does, while {6, 4, 3} and {1, 2, 2, 3} do not). Given a series of lowercase strings without spaces or punctuation, determine if any two adjacent strings (inputted right after each other) are anagrams of each other. Write a program to determine if a number is a palindrome. Write methods that compute the least common multiple and greatest common factor of two positive integers. Please email or DM me via Slack any challenges that you finish for feedback!","title":"Lesson 3: Pre-Scouting"},{"location":"strat/gamestrat/L3/#lesson-3-methods","text":"Here's a short lesson on one of the building blocks of Java that will prepare you for object-orientated programming: methods.","title":"Lesson 3 - Methods"},{"location":"strat/gamestrat/L3/#method-signature","text":"A method (also known as a function in other languages) is essentially a function, very similar to one that you would encounter in math class. It has an input, an output, and a name (or identifier), though these must have specific data types (think a limited domain/range). Here is a sample method ( isEven ) being declared within a class: public class Example { public boolean isEven ( int num ){ if ( num % 2 == 0 ){ return true ; } return false ; } public static void main ( String [] args ){ //main method //code executed here first } } In this example, the method signature is simply public boolean isEven ( int num ) . It consists of visibility modifiers ( public , private , protected , etc.), a return type ( boolean ), a method identifier ( isEven ), and a set of parameters ( int num ). These parameters must each have a datatype, followed by an identifier, similar to declaring a variable. To list multiple parameters, list each one individually within the parentheses, then separate them with a comma, like in the following example: public int getNumRpPowerUp ( int redScore , int blueScore , boolean autoQuestComplete , int numClimbs , boolean levitateUsed ){ int totalRp = 0 ; if ( redScore > blueScore ) totalRp += 2 ; if ( redScore == blueScore ) totalRp ++ ; if ( autoQuestComplete ) totalRp ++ if ( numClimbs == 3 || numClimbs == 2 && levitateUsed ) totalRp ++ return totalRp ; } Note that a value with the same type as the specified return type ( int in this case) must be returned by the method. This is accomplished by typing the word return followed by a variable or literal value of the specified return type. For instance, the statement return 0 ; would be valid in getNumRpPowerUp as well. Note that the method immediately ends once a return statement is executed. It it possible for a method to have no parameters and/or return type as well. With no parameters, simply leave the contents of the parentheses following the method name blank: public String getInfoString (){ return \"Hello World!\" ; } If you don't want to return a value from the method, the return type should be specified as void . A return statement is not necessary: public void printInfo ( int currentMatchNum , String scoutName ){ System . out . println ( scoutName + \" - Match \" + currentMatchNum ); } You've already used methods to find properties of an object or to compute values, such as with str . length () or Math . pow ( base , power ) . In general, a method call is accomplished by typing the method name, followed by its parameters. The return value (if there is one) can then be used, either within a conditional statement, loop, or assigned to a variable: int red = 200 , blue = 30 , climbs = 1 ; boolean levitated = true ; int rpGained = getNumRpPowerUp ( red , blue , true , climbs , levitated ); while ( isEven ( rpGained )){ //do something }","title":"Method signature"},{"location":"strat/gamestrat/L3/#why-methods","text":"So, why are methods so important if they're just executing a block of pre-written code? Well, creating multiple methods in an application or program allows you to break down a problem and do certain tasks repeatedly. For instance, if you wanted to test if a series of numbers were even in different parts of a program, it would be easier to make a call to isEven ( num ) rather than remembering that if a number mod 2 is 0, it is even. Another way to structure an application is to have methods responsible for specific tasks, such as saving a file or verifying if a password matches the one that was stored. As long as you test a method after you write it and ensure it gives the correct output for a variety of input parameters, you can use it throughout an application without needing to refer back to the actual method's source code. That also makes it easy to collaborate with each other, as each person working on a project could be responsible for writing and testing one method; as long as those work independently, you could implement them together in the final product.","title":"Why methods?"},{"location":"strat/gamestrat/L3/#overloading-methods","text":"Sometimes, a method should be able to have different set of parameters, of different data types. In this case, the parameter list will need to be modfied: public double average ( int num1 , int num2 ){ return ( num1 + num2 ) / 2.0 ; } public double average ( double a , double b ){ return ( a + b ) / 2.0 ; } Depending on the datatypes of the parameters when you make the method call, the compiler will know which method to execute. Note that the return type for a particular method name must always be the same, and a method cannot be overloaded if its signature is otherwise identical (parameters have the same datatypes, in the same order).","title":"Overloading methods"},{"location":"strat/gamestrat/L3/#recursion","text":"Like in math, methods can call themselves or other methods within the body of their code. For instance, the following returns the n th Fibonacci number (1, 1, 2, 3, 5, ...): int fib ( int n ){ if ( n == 1 ) return 1 ; if ( n == 2 ) return 1 ; return fib ( n - 1 ) + fib ( n - 2 ); } Recursion is useful for creating simple methods, but their running time can sometimes be slow, and you must always ensure that you reach a base case ( n == 1 or n == 2 in this example) that returns a literal value. Refer to the binary search method if you want to see a more complex example of recursion.","title":"Recursion"},{"location":"strat/gamestrat/L3/#algorithmic-challenges","text":"Do as many as you want, until you get a good feel of when to implement methods and how to break down a problem: Write a recursive method to compute the factorial of a number. Note that 0! is equal to 1. Write a program that takes any English sentence without punctuation as an input, then converts it to Pig Latin . Implement a more efficient (non-recursive) algorithm to find the n th Fibonacci number Determine the sum of all prime numbers from 2 to a number specified by the user. A number is superb if and only if the sum of all of its factors (excluding itself) is less than a number. Write a program to determine the number of superb numbers between two numbers (e.g. 1 and 100) that are specified by the user. Given a series of variable identifiers in camelCase, identify the number of actual words in the string (e.g. numberOfRankingPoints has four actual words). Given the length of a set of integers S, followed the elements (numbers) of S, determine if S contains only consecutive integers, without repeats (e.g. {3, 5, 4, 6} does, while {6, 4, 3} and {1, 2, 2, 3} do not). Given a series of lowercase strings without spaces or punctuation, determine if any two adjacent strings (inputted right after each other) are anagrams of each other. Write a program to determine if a number is a palindrome. Write methods that compute the least common multiple and greatest common factor of two positive integers. Please email or DM me via Slack any challenges that you finish for feedback!","title":"Algorithmic challenges"},{"location":"strat/gamestrat/L4/","text":"Lesson 4 - Object Orientated Design We explored String s in previous lessons, which was your first look at an object in Java. In fact, you've been writing programs inside of a main function, which is a method inside a function! In this lesson, we'll see what an object really is and why they're so useful. Why objects? Objects have both state , variables that remain constant until you modify them, and behavior , which are seen through callable methods that either feed your main method information about that object or operate on its state. As programmers, you need to design objects so that their state and behavior are appropriate for what you're trying to accomplish, while breaking down code into testable and understandable building blocks. It's probably easiest to think of an object like an object in the real world, such as a person or a dog. It could have states like a name, age, favorite color, and friends. Similarly, a Person object could have behaviors like befriending another person if they have the same favorite color, increasing its age every year, or saying its name. Objects may also want to keep some state variables private , such as a credit card number. These are just examples, but you'll see as we go about modeling a person in this lesson. In essence, objects make programming real-world mechanisms and representing real-world entities a lot easier. You could have a Robot object drive a certain distance, deposit and earn interest in a BankAccount , or read the state of an Actuator on a Robot . Constructors and member variables A class is the blueprint behind an object, which is something you should already be familiar with from writing programs. Each class should generally be in its own . java file, called ClassName . java . It's possible to have multiple classes within a file, but we'll get to that later. Inside Person . java : // Import statements come first import java.util.Scanner ; public class Person { public static void main ( String [] args ){ // do stuff here } } This is probably what you're familiar with right now. Now, we'll add in some fields, called member variables , to the Person class that will help identify it: public class Person { String name , favoriteColor ; int age , numFriends ; } To initialize these attributes, we'll also need a constructor , which is essentially a method that returns an instance of that class while assigning values to as many member variables as you'd like. public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } Note that the identifier for a constructor is simply the name of the class, though the parameters can be any datatype, and there is no return statement. Like other methods, constructors can also be overloaded with arguments of different datatypes. An empty constructor is automatically created if no constructor is declared for a class, which simply doesn't set any member variables. To access member variables, we use the keyword this , referring to the new instance of the object, followed by the dot operator and the identifiers of the variables you want to modify. This also distinguishes the name variable in the parameter of the constructor with the name variable that's part of the object's state. Member variables must be assigned a value, either explicitly through the code of the class or via a constructor, before their value can be accessed. They can also either be objects or primitive values. Declaring objects So, how exactly do you create an object with the constructor? Well, it's similar to declaring any other variable in Java, complete with a datatype and identifier, except you'll need to use the new keyword: public static void main ( String [] args ){ Person mentor = new Person ( \"Cokeley\" ); } This creates an instance of a Person , which is stored in mentor . Now, if you want to access or modify attributes of mentor , you'll use the same dot operator that was used in the constructor: mentor . age = 25 ; System . out . println ( mentor . name + \" is \" + mentor . age + \" years old\" ); This will print out Cokeley is 25 years old . Class methods While having objects as a simple data structure with various attributes is useful, sometimes you want a little more interactivity. That's when we can create our own methods in a class. We can spice up the Person class by adding in the following: public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } boolean makeFriends ( Person possibleFriend ){ if ( possibleFriend . favoriteColor . equals ( this . favoriteColor )){ this . numFriends ++ ; possibleFriend . numFriends ++ ; return true ; } return false ; } } This makeFriends method mutually has two people become friends if their favoriteColor is the same, then returns true if they've become friends, or false otherwise. Another example can be seen with this RightTriangle class: class RightTriangle { double legOne , legTwo , hypotenuse ; RightTriangle ( double side1 , double side2 , double side3 ){ this . hypotenuse = Math . max ( Math . max ( side1 , side2 ), side3 ); this . legOne = Math . min ( Math . min ( side1 , side2 ), side3 ); this . legTwo = side1 + side2 + side3 - this . legOne - this . hypotenuse ; } double getArea (){ return 0.5 * this . legOne * this . legTwo ; } double getPerimeter (){ return this . legOne + this . legTwo + this . hypotenuse ; } // Returns smaller acute angle in radians double getSmallerAngle (){ return Math . atan ( this . legOne / this . legTwo ); } // Returns larger acute angle in radians double getLargerAngle (){ return Math . PI / 2 - this . getSmallerAngle (); } // Extends the length of the shorter leg and // adjusts the length of the hypotenuse accordingly void extendLegOne ( double newLength ){ if ( newLength > this . legTwo ){ this . legOne = this . legTwo ; this . legTwo = newLength ; } else this . legOne = newLength ; this . hypotenuse = Math . sqrt ( Math . pow ( this . legOne , 2 ) + Math . pow ( this . legTwo , 2 )); } } Here, after initializing a RightTriangle object, we can use its different instance methods to get and modify its properties. For instance, executing the following in the main method RightTriangle tri = new RightTriangle ( 4 , 3 , 5 ); System . out . println ( \"Perimeter: \" + tri . getPerimeter ()); System . out . println ( \"Area: \" + tri . getArea ()); System . out . println ( \"Smaller Angle: \" + tri . getSmallestAngle () + \" rad\" ); tri . extendLegOne ( 10 ); System . out . println ( \"New Perimeter: \" + tri . getPerimeter ()); will print Perimeter : 12.0 Area : 6.0 Smallest Angle : 0.6435011087932844 rad New Perimeter : 24.77032961426901 Visibility Sometimes it is desirable to reduce the access and visibility of object methods or instance variables. For example, you generally wouldn't want a main method to be able to change a Person object's name explicitly, or perhaps you want to modify a BankAccount object's balance only through withdrawal and deposit methods, each requiring a PIN code. In that case, it's best to leave member variables private instead of public . To do this, simply put the visibility modifier in front of the variable identifier, like so: public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } That way, private level access only allows those variables to be accessed and modified within the same class (such as within the constructor or other class methods). On the other hand, public level access allows all classes to modify a variable or call a method, while default access (not putting any modifier) only allows classes of the same package to access variables/methods. We'll get into packages later on, but just know that they're ways of grouping similar classes for now. So, how are we supposed to modify and access attributes like favoriteColor so the method makeFriends can still function properly? For the first case, we'll use a special type of method called a setter , while we create a getter to do the latter: private public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } public void setFavoriteColor ( String favoriteColor ){ this . favoriteColor = favoriteColor ; } public String getFavoriteColor (){ return this . favoriteColor ; } } It's pretty simple: a setter has an argument datatype that's the same as the member variable, sets the member variable, then returns nothing. Meanwhile, a getter has the same return type as the member variable, has no parameters, and simply returns the value of the member variable. In fact, these methods are so common (as it's good practice to set variables as private ) that most IDEs (including Eclipse) have a way to automatically generate setters and getters for a class. Finally, static methods and variables are called directly on a class, rather than on an instance of a class. You've already seen examples of these in the Math class: the variable Math . PI and the method Math . pow ( base , exp ) can be called without declaring an instance of a Math object via the new keyword. It's important to note that static variables are shared by all instances of a given class (and thus can be used as temporary storage). Also, static methods cannot access non- static variables or methods. You can make a static method private or public by putting the visibility modifier in front of the word static , such as in public static void main ( String [] args ) . Scope Our last topic is something that we've used throughout this lesson without realizing it; variable identifiers often come in conflict with each other. In that case, which value do we use? The smallest scope is in a loop: for ( int i = 1 ; i < 5 ; i ++ ){ double area = Math . pow ( i , 2 ); } In this case, both i and area have block scope and cannot be modified or accessed outside of the for loop. You'll see that a set of curly braces generally denotes scope. Note that variables with the identifier i or area cannot exist outside of the loop either. Next up are local variables, also known as method scope : public void setSideLength ( int sideLength ){ double squareArea = Math . pow ( sideLength , 2 ); this . sideLength = sideLength ; } Both sideLength and squareArea can be accessed/modified only within the method setSideLength . However, using the keyword this and the dot operator will refer to the member variable sideLength of the class, rather than the one passed in as an argument. All variables other than member variables cannot be accessed outside of a class, which then follow the visibility rules discussed before. HW: Modeling Bank Accounts We've discussed bank accounts throughout this lesson. Now it's time to implement one! Each BankAccount object has the following attributes, which should all be private : balance : a double indicating the amount of money in the bank account. Cannot be negative. pin : a four-digit code that authenticates a user. May contain leading zeroes (i.e. 0000 is a valid PIN) name : the name of the bank account owner interestRate : the percent of interest earned by a user in a given year, shared across all bank accounts Challenge : id : a random, five-digit code that's generated upon the creation of the bank account to identify it. Does not contain leading zeroes. You may want to refer back to the Math . random method from Lesson 2. Methods should be provided to do the following: Construct a BankAccount with a PIN, owner, and initial balance Challenge : Construct a BankAccount with a PIN, owner, and initial balance of $0.00 Get the name of the owner of an account Get the id of the account Change the PIN of the account, given the old PIN and the new PIN. Should return some form of feedback to determine if the PIN was successfully changed Withdraw money from an account, given its PIN and the amount desired. Should indicate if withdrawal was successful and should not allow it if the account doesn't have enough money Deposit a given amount of money into the account Earn interest for the year, based on the interestRate Challenge : Transfer money from one account to another, given another BankAccount object and its PIN You do not need to submit a main method as a driver for your class, though you will need to write one to test if your class works. Next lesson, you'll write one to complete specific tasks when you learn about arrays and HashMaps to create a network of bank accounts. Please email me your completed class or DM me via Slack.","title":"Lesson 4: Competition!"},{"location":"strat/gamestrat/L4/#lesson-4-object-orientated-design","text":"We explored String s in previous lessons, which was your first look at an object in Java. In fact, you've been writing programs inside of a main function, which is a method inside a function! In this lesson, we'll see what an object really is and why they're so useful.","title":"Lesson 4 - Object Orientated Design"},{"location":"strat/gamestrat/L4/#why-objects","text":"Objects have both state , variables that remain constant until you modify them, and behavior , which are seen through callable methods that either feed your main method information about that object or operate on its state. As programmers, you need to design objects so that their state and behavior are appropriate for what you're trying to accomplish, while breaking down code into testable and understandable building blocks. It's probably easiest to think of an object like an object in the real world, such as a person or a dog. It could have states like a name, age, favorite color, and friends. Similarly, a Person object could have behaviors like befriending another person if they have the same favorite color, increasing its age every year, or saying its name. Objects may also want to keep some state variables private , such as a credit card number. These are just examples, but you'll see as we go about modeling a person in this lesson. In essence, objects make programming real-world mechanisms and representing real-world entities a lot easier. You could have a Robot object drive a certain distance, deposit and earn interest in a BankAccount , or read the state of an Actuator on a Robot .","title":"Why objects?"},{"location":"strat/gamestrat/L4/#constructors-and-member-variables","text":"A class is the blueprint behind an object, which is something you should already be familiar with from writing programs. Each class should generally be in its own . java file, called ClassName . java . It's possible to have multiple classes within a file, but we'll get to that later. Inside Person . java : // Import statements come first import java.util.Scanner ; public class Person { public static void main ( String [] args ){ // do stuff here } } This is probably what you're familiar with right now. Now, we'll add in some fields, called member variables , to the Person class that will help identify it: public class Person { String name , favoriteColor ; int age , numFriends ; } To initialize these attributes, we'll also need a constructor , which is essentially a method that returns an instance of that class while assigning values to as many member variables as you'd like. public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } Note that the identifier for a constructor is simply the name of the class, though the parameters can be any datatype, and there is no return statement. Like other methods, constructors can also be overloaded with arguments of different datatypes. An empty constructor is automatically created if no constructor is declared for a class, which simply doesn't set any member variables. To access member variables, we use the keyword this , referring to the new instance of the object, followed by the dot operator and the identifiers of the variables you want to modify. This also distinguishes the name variable in the parameter of the constructor with the name variable that's part of the object's state. Member variables must be assigned a value, either explicitly through the code of the class or via a constructor, before their value can be accessed. They can also either be objects or primitive values.","title":"Constructors and member variables"},{"location":"strat/gamestrat/L4/#declaring-objects","text":"So, how exactly do you create an object with the constructor? Well, it's similar to declaring any other variable in Java, complete with a datatype and identifier, except you'll need to use the new keyword: public static void main ( String [] args ){ Person mentor = new Person ( \"Cokeley\" ); } This creates an instance of a Person , which is stored in mentor . Now, if you want to access or modify attributes of mentor , you'll use the same dot operator that was used in the constructor: mentor . age = 25 ; System . out . println ( mentor . name + \" is \" + mentor . age + \" years old\" ); This will print out Cokeley is 25 years old .","title":"Declaring objects"},{"location":"strat/gamestrat/L4/#class-methods","text":"While having objects as a simple data structure with various attributes is useful, sometimes you want a little more interactivity. That's when we can create our own methods in a class. We can spice up the Person class by adding in the following: public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } boolean makeFriends ( Person possibleFriend ){ if ( possibleFriend . favoriteColor . equals ( this . favoriteColor )){ this . numFriends ++ ; possibleFriend . numFriends ++ ; return true ; } return false ; } } This makeFriends method mutually has two people become friends if their favoriteColor is the same, then returns true if they've become friends, or false otherwise. Another example can be seen with this RightTriangle class: class RightTriangle { double legOne , legTwo , hypotenuse ; RightTriangle ( double side1 , double side2 , double side3 ){ this . hypotenuse = Math . max ( Math . max ( side1 , side2 ), side3 ); this . legOne = Math . min ( Math . min ( side1 , side2 ), side3 ); this . legTwo = side1 + side2 + side3 - this . legOne - this . hypotenuse ; } double getArea (){ return 0.5 * this . legOne * this . legTwo ; } double getPerimeter (){ return this . legOne + this . legTwo + this . hypotenuse ; } // Returns smaller acute angle in radians double getSmallerAngle (){ return Math . atan ( this . legOne / this . legTwo ); } // Returns larger acute angle in radians double getLargerAngle (){ return Math . PI / 2 - this . getSmallerAngle (); } // Extends the length of the shorter leg and // adjusts the length of the hypotenuse accordingly void extendLegOne ( double newLength ){ if ( newLength > this . legTwo ){ this . legOne = this . legTwo ; this . legTwo = newLength ; } else this . legOne = newLength ; this . hypotenuse = Math . sqrt ( Math . pow ( this . legOne , 2 ) + Math . pow ( this . legTwo , 2 )); } } Here, after initializing a RightTriangle object, we can use its different instance methods to get and modify its properties. For instance, executing the following in the main method RightTriangle tri = new RightTriangle ( 4 , 3 , 5 ); System . out . println ( \"Perimeter: \" + tri . getPerimeter ()); System . out . println ( \"Area: \" + tri . getArea ()); System . out . println ( \"Smaller Angle: \" + tri . getSmallestAngle () + \" rad\" ); tri . extendLegOne ( 10 ); System . out . println ( \"New Perimeter: \" + tri . getPerimeter ()); will print Perimeter : 12.0 Area : 6.0 Smallest Angle : 0.6435011087932844 rad New Perimeter : 24.77032961426901","title":"Class methods"},{"location":"strat/gamestrat/L4/#visibility","text":"Sometimes it is desirable to reduce the access and visibility of object methods or instance variables. For example, you generally wouldn't want a main method to be able to change a Person object's name explicitly, or perhaps you want to modify a BankAccount object's balance only through withdrawal and deposit methods, each requiring a PIN code. In that case, it's best to leave member variables private instead of public . To do this, simply put the visibility modifier in front of the variable identifier, like so: public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } That way, private level access only allows those variables to be accessed and modified within the same class (such as within the constructor or other class methods). On the other hand, public level access allows all classes to modify a variable or call a method, while default access (not putting any modifier) only allows classes of the same package to access variables/methods. We'll get into packages later on, but just know that they're ways of grouping similar classes for now. So, how are we supposed to modify and access attributes like favoriteColor so the method makeFriends can still function properly? For the first case, we'll use a special type of method called a setter , while we create a getter to do the latter: private public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } public void setFavoriteColor ( String favoriteColor ){ this . favoriteColor = favoriteColor ; } public String getFavoriteColor (){ return this . favoriteColor ; } } It's pretty simple: a setter has an argument datatype that's the same as the member variable, sets the member variable, then returns nothing. Meanwhile, a getter has the same return type as the member variable, has no parameters, and simply returns the value of the member variable. In fact, these methods are so common (as it's good practice to set variables as private ) that most IDEs (including Eclipse) have a way to automatically generate setters and getters for a class. Finally, static methods and variables are called directly on a class, rather than on an instance of a class. You've already seen examples of these in the Math class: the variable Math . PI and the method Math . pow ( base , exp ) can be called without declaring an instance of a Math object via the new keyword. It's important to note that static variables are shared by all instances of a given class (and thus can be used as temporary storage). Also, static methods cannot access non- static variables or methods. You can make a static method private or public by putting the visibility modifier in front of the word static , such as in public static void main ( String [] args ) .","title":"Visibility"},{"location":"strat/gamestrat/L4/#scope","text":"Our last topic is something that we've used throughout this lesson without realizing it; variable identifiers often come in conflict with each other. In that case, which value do we use? The smallest scope is in a loop: for ( int i = 1 ; i < 5 ; i ++ ){ double area = Math . pow ( i , 2 ); } In this case, both i and area have block scope and cannot be modified or accessed outside of the for loop. You'll see that a set of curly braces generally denotes scope. Note that variables with the identifier i or area cannot exist outside of the loop either. Next up are local variables, also known as method scope : public void setSideLength ( int sideLength ){ double squareArea = Math . pow ( sideLength , 2 ); this . sideLength = sideLength ; } Both sideLength and squareArea can be accessed/modified only within the method setSideLength . However, using the keyword this and the dot operator will refer to the member variable sideLength of the class, rather than the one passed in as an argument. All variables other than member variables cannot be accessed outside of a class, which then follow the visibility rules discussed before.","title":"Scope"},{"location":"strat/gamestrat/L4/#hw-modeling-bank-accounts","text":"We've discussed bank accounts throughout this lesson. Now it's time to implement one! Each BankAccount object has the following attributes, which should all be private : balance : a double indicating the amount of money in the bank account. Cannot be negative. pin : a four-digit code that authenticates a user. May contain leading zeroes (i.e. 0000 is a valid PIN) name : the name of the bank account owner interestRate : the percent of interest earned by a user in a given year, shared across all bank accounts Challenge : id : a random, five-digit code that's generated upon the creation of the bank account to identify it. Does not contain leading zeroes. You may want to refer back to the Math . random method from Lesson 2. Methods should be provided to do the following: Construct a BankAccount with a PIN, owner, and initial balance Challenge : Construct a BankAccount with a PIN, owner, and initial balance of $0.00 Get the name of the owner of an account Get the id of the account Change the PIN of the account, given the old PIN and the new PIN. Should return some form of feedback to determine if the PIN was successfully changed Withdraw money from an account, given its PIN and the amount desired. Should indicate if withdrawal was successful and should not allow it if the account doesn't have enough money Deposit a given amount of money into the account Earn interest for the year, based on the interestRate Challenge : Transfer money from one account to another, given another BankAccount object and its PIN You do not need to submit a main method as a driver for your class, though you will need to write one to test if your class works. Next lesson, you'll write one to complete specific tasks when you learn about arrays and HashMaps to create a network of bank accounts. Please email me your completed class or DM me via Slack.","title":"HW: Modeling Bank Accounts"},{"location":"strat/gamestrat/L5/","text":"","title":"Lesson 5: Picklisting"},{"location":"strat/usage/L1/","text":"Lesson 1 - Introduction to Java Raider Robotix and Java FRC Team 25, Raider Robotix , uses the Java programming language for programming both the robot and the scouting system. Java is also taught in NBTHS's computer science courses. These lessons will provide you with the building blocks of Java that are necessary to program, maintain, and understand the scouting system. It currently has two components: * Android scouting app - collects data from scouts during events and exports it in JSON (JavaScript Object Notation) files * Every year, this needs to be updated with the correct metrics, events, game manual, and other options, as necessary * Desktop scouting client - compiles the JSON files from the app and outputs spreadsheets of each scouting entry and aggregated statistics for each team * Every year, this needs to be updated with the correct metrics, which includes averages, percentages, probabilities, and standard deviations, in addition to those in the scouting app Starting from the 2017 season, Tableau is used to visualize and analyze the data from the spreadsheets generated by the client. The goal is to have you understand how the scouting system works and be comfortable with changing its code by next season's kickoff. If you want to work on robot programming instead, additional knowledge of WPILib API will be needed. Lesson Structure Generally, several concepts will be explained and grouped together to form a lesson. As each concept is taught, several practice exercises are given for you to check your understanding. At the end of the lesson, one or two problems will be assigned on HackerRank that test your understanding of all concepts in the lesson. The site allows you to check your program against several test cases and will \"grade\" it (pass or fail) instantly. Java Code Structure Java source files have a . java extension and each contain a class , which acts like an object (we'll get to this later). Each class/source file is located in a package , which acts as a folder to organize various files. Inside an executable program is a main method , in which the code inside it executes. In a desktop Java program, the method signature public static void main ( String [] args ) is used, followed by a set of curly braces. Below is an example inside a file called Example . java : // Place import statements here public class Example { public static void main ( String [] args ){ // Write your code to execute here } } As seen above line comments can be written if they are proceeded with two forward slashes ( // ). Anything following the two slashes will be ignored by the compiler when your program executes. Block comments may also be written like this: /* Hi! * I'm a block comment. */ Note the two slashes showing the beginning/end of the comment and the asterisk on each line. Variables Any data or value you use in Java is stored in a variable . A variable can have one of many different datatypes . The following are common datatypes: * int - an integer with a value between -2^31 - 1 and 2^31 -1 ( 123 , 25 , - 900 , 0 , etc.) * double - a positive or negative decimal number ( 1.23 , - 2.5 , 1.0005 , etc.) * boolean - has either a true or false value * String - a sequence of characters, enclosed in a set of quotation marks ( \"Hello World\" , \"1+1=2\" , \"Raider Robotix\" , etc.) You can declare variables with its datatype, followed by a space and its identifier , then a semicolon. The identifier must start with a letter or underscore, then be followed by more letters, underscores, or numbers, with no spaces. Valid identifiers include: * _t * motor1 * MOTOR_SPEED Generally, variables are named in a camelCase notation, where the first word is lowercase, then the remaining words are uppercase. Examples of variable declarations with camelCase naming include: int teleOpGearsCollected ; double avgKpaPerGame ; boolean baselineCrossed ; String robotComment , pilotComment ; //multiple variables can be declared with a comma separating them On the other hand, variables that are constant throughout a program should be named with only uppercase letters and underscores. Examples of these variables include: double TURN_ANGLE_TOLERANCE ; int LEFT_JOYSTICK_PORT ; String RULES_FILEPATH ; int VERSION_NUMBER ; Keep in mind that variables should not have generic identifiers like x or var1 , but ones that are descriptive. A variable can be assigned a value with its identifier followed by the assignment operator , = , and its value. This value can be literal or that of another variable. A variable may be assigned a value and declared at the same time as well. Some examples: int teleOpGearsCollected ; // declaration double avgHighGoalsTeleOp = 12.555 ; // variable declared and value of 12.555 assigned teleOpGearsCollected = 4 ; // assignment afterwards boolean baselineCrossed = true , readyTakeoff = false ; // two variables declared and assigned value String robotComment = \"This is a good robot\" ; double avgTeleOpKpa = avgHighGoalsTeleOp / 3 ; //value dependent on another variable Output Output to the console in Java can be executed with the following statement : System . out . println ( < some value > ); This calls the println method on a value, where < some value > can be a literal value or a variable. Remember to terminate the print statement with a semicolon. For example, executing System . out . println ( teleOpGearsCollected ); System . out . println ( \"gears collected in tele-op in match\" ); System . out . println ( 25 ); will result in the following output: 4 gears collected in tele - op in match 25 If you don't want a new line after the output, the System . out . print ( < some value > ) method may be used. Executing System . out . print ( teleOpGearsCollected ); System . out . println ( \" gears collected in tele-op.\" ); System . out . println ( \"Robots are cool\" ); will result in the following output: 4 gears collected in tele - op . Robots are cool An IDE An IDE (Integrated Development Environment) will be used to program in Java. It allows you to write code, execute, and debug it in one application. I recommend using Eclipse , as NBTHS and the WPILib API uses it, though alternatives like InteliJ and BlueJ exist. We will be using Android Studio as our IDE for Android development. To get started with Eclipse: 1. Download and extract the ZIP file from the link above 2. Run the executable and choose your workspace (default should work) 3. Go to File > New > Java Project and name your project 4. Close the Welcome window 5. Right click your project and go to New > Class, and name your class (without the . java extension) 6. Write your main method (see above) 7. Try replacing the comment with a statement to print Hello World 8. Press the green \"Play\" button to execute your program If there are any syntax errors in your program, Eclipse will underline them in red, and the program will not run. Try fixing them by reading the error message and reviewing your code or by using Google. A Brief Exercise : Assign the values of true , \"Raider Robotix\" , and 25 to variables. Use print statements with the variables and literal values to generate the output Hello World ! It is true that I am on Team 25 , Raider Robotix 25 is the Team Number . Input To take user input, you will need to use a Scanner object. First, you will need to import the class by placing the following import statement before the class starts (see example above): import java.util.Scanner ; The Scanner object can be declared and constructed like this to read from the system console: Scanner myScanner = new Scanner ( System . in ); The datatype is Scanner , and myScanner can be any valid identifier. Note the use of the new keyword to create a new object and the parentheses following. Several methods can be accessed through the Scanner object for different datatypes. A method essentially acts like a function and returns a value to the main program. These may be used to let users assign values to variables: int anInteger = myScanner . nextInt (); String aLine = myScanner . next (); // takes the next whole line Essentially, the dot operator ( . ) shows that the methods nextInt () and nextLine () are written in the Scanner class, and you are accessing them from an outside class. More methods for input can be found by reading the documentation for the class . If the wrong datatype is used, there will be an error in your program. By default, spaces and line breaks separating tokens in the input will result two different variables. For example, if the input is Raider Robotix executing String teamName = myScanner . next (); System . out . println ( teamName ); will output Raider while executing String teamName = myScanner . nextLine (); System . out . println ( teamName ); will output Raider Robotix Exercise Write a program that allows prompts a user to input a string, an integer, and a floating point number, then print all three once they are inputted. Operators Operators in Java allow you to interact between different datatypes. For these examples, we will declare int a = 5 , b = 4 ; double c = 2.5 ; String s = \"Hello\" ; Mathematical Evaluating these operators will result in a number of type int if both are integers, or of type double if at least one is a double : + - adds the number (an int or double ) to the left and right of it a + b is equal to 9 , a + c is equal to 7.5 - - subtracts the number on the right from the left b - a is equal to - 1 , b - c is equal to 1.5 * - multiplies the number to the left and right of it a * b is equal to 20 , b * c is equal to 10.0 / - divides the number on the left by the number on the right. However, if both numbers are int s, integer division will occur. That is, the remainder is discarded, and only the quotient remains. a / c is equal to 2.0 , b / c is equal to 1.6 a / b is equal to 1 , b / a is equal to 0 A literal int value ( 1 ) may be converted into a double value by adding a decimal point and a zero ( 1.0 ) % - the modulus operator, a % b returns the remainder of a / b a % b is equal to 1 , b % a is equal to 4 , a % c is equal to 0.0 Exercises : * Write a program that allows the user to input (integer) dimensions of a rectangular prism and outputs its surface area and volume * Write a program that prints the day of the week of a day, given the day of the week of the first day of the month (where 1=Monday, 7=Sunday) * Write a program that calculates the score of a match in FIRST Steamworks, where the user inputs the number of rotors activated during tele-op/autonomous, high/low goals in tele-op/autonomous, the times the baseline was crossed, the times robots took off, and foul points that were incurred by the opposing alliance Relational Evaluating these operators will result in a boolean value ( true or false ): < - less than, <= - less than or equal to b < a is true , 4.5 < 0 is false - 2 <= c is true , 5 <= 5 is true > - greater than, >= - greater than or equal to == - checks for equality. This can only be used for primitive datatypes, and not objects a == 5 is true , 2.0 == a / c is true false == true is false For strings, the method someString . equals ( /*another string*/ ) is used for equality because a string is an object. We'll get into this more in the next lesson. s . equals ( \"Hello\" ) is true , s . equals ( \"World\" ) is false != - checks if the two objects are not equal a != 5 is false , 1 != a / c is true false != true is true Exercise : Write a program to determine if it is true that a quadratic equation of the form 0=ax^2+bx+c has a real solution, where the user inputs a, b, and c. (Hint: For now the best way to square an integer x is x * x , as x ^ 2 will not evaluate correctly) Logical These operate on boolean values and evaluating them will also result in a boolean value: OR Operator - written as a || b , evaluates to true only if either a or b are true a b a \\ | \\ | b false false false false true true true false true true true true AND Operator - written as a && b , evaluates to true only if both a and b are true a b a && b false false false false true false true false false true true true NOT Operator - written as !a , evaluates to true only if a is false a !a false true true false Exercises * Evaluate the following expressions (without actually writing any code) for when boolean a = true , b = false and for when boolean a = true , b = true : * ( a || b ) && ( ! a || ! b ) * ! ( a && ! b ) || ( ! a && b ) * ! ( a && b ) Some Shortcuts You already learned about the assignment operator. Here are some shortcuts used for assignment with operators, if x and y are numbers and both are already declared and assigned values: x += y ; // same as x = x+y x -= y ; // same as x = x-y x /= y ; // same as x = x/y x %= y ; // same as x = x % y x ++ ; // same as x+=1 x -- ; // same as x-=1 Exercise : What is the value of x after the following is executed? int x = 60 , y = 10 ; y /= 5 ; x %= x - y ; x ++ ; x *= 4 ; Boolean Expressions A boolean expression is any expression that evaluates to true or false . It may contain literals, variables, and any of the above operators. The order of operations for evaluation are: Parentheses NOT Multiplication, division, modulus Addition, subtraction Greater/less than (or equal to) Equivalence/not equivalent AND OR The following are valid boolean expressions if x and y are numbers and b is a boolean : * x >= 5 + y && ! ( y + 5 == 7 || y < 0 || ! b ) * takeoffPercentage / avgTakeoffPercentage + 0.1 >= 1.2 && ( avgKpa >= 30 || avgGears >= 4 ) && teamNum != 25 && ! droppedGearOften Exercises * The XOR (exclusive-or) operator evaluates to be true if either A or B are true, but not both. Write an expression that is logically equivalent to \"A XOR B\" using the AND, OR, and NOT operators * Write a boolean expression to determine if at least 3 ranking points were earned by the red alliance in a match of FIRST Steamworks, given the scores of both the red and blue alliances, the number of gears delivered by the red alliance, whether or not the reserve gear was used, and the number of high/low goals into the red boiler in autonomous/tele-op. Use appropriate identifiers for variables and declare multiple, intermediate boolean expressions as necessary. Conditionals A conditional statement is one that executes if a particular boolean expression is true. The if , else , and else - if statements are written and used as follows: boolean a = < some expression > ; if ( a ){ //Code here executes if expression a is true } else if ( < some boolean expression b > ){ // Code here executes if expression b is true and a is false } else { // Code here executes if a and b are both false } Note that an if statement may be written without any else statements, but else and else - if statements must follow an if statement or an else statement. The boolean expression may also be placed inside the parentheses, rather than assigning its value to a boolean variable. These conditional statements may also be nested inside each other as follows: boolean a = < some expression > ; boolean b = < some expression > ; boolean c = < some expression > ; if ( a ){ if ( c ){ // Code here executes if a and c are true } else { //Code here executes if a is true and c is false } // Code here executes as long as a is true, no matter what the value of c is } else if ( b ){ // Code here executes if expression b is true and a is false, no matter what the value of c is if ( ! c ){ //Code here executes if a is false, b is true, and c is false } } else { // Code here executes if a and b are both false } Exercises * Write a program to determine if a number is even or odd * Write a program that prints the month, given its numerical value (1 to 12) * Write a program that converts a day of the week to a number (Monday = 1, Sunday = 7) * Write a program that converts feet to yards and vice-versa, depending on what the user wants Assignment Download Eclipse and complete the exercises above as necessary to check your understanding. Afterwards, sign up for a HackerRank account and complete the \"A School Day\" program here . I suggest that you write and test the program on Eclipse, then check if it works on HackerRank.","title":"Lesson 1: The Scouting App"},{"location":"strat/usage/L1/#lesson-1-introduction-to-java","text":"","title":"Lesson 1 - Introduction to Java"},{"location":"strat/usage/L1/#raider-robotix-and-java","text":"FRC Team 25, Raider Robotix , uses the Java programming language for programming both the robot and the scouting system. Java is also taught in NBTHS's computer science courses. These lessons will provide you with the building blocks of Java that are necessary to program, maintain, and understand the scouting system. It currently has two components: * Android scouting app - collects data from scouts during events and exports it in JSON (JavaScript Object Notation) files * Every year, this needs to be updated with the correct metrics, events, game manual, and other options, as necessary * Desktop scouting client - compiles the JSON files from the app and outputs spreadsheets of each scouting entry and aggregated statistics for each team * Every year, this needs to be updated with the correct metrics, which includes averages, percentages, probabilities, and standard deviations, in addition to those in the scouting app Starting from the 2017 season, Tableau is used to visualize and analyze the data from the spreadsheets generated by the client. The goal is to have you understand how the scouting system works and be comfortable with changing its code by next season's kickoff. If you want to work on robot programming instead, additional knowledge of WPILib API will be needed.","title":"Raider Robotix and Java"},{"location":"strat/usage/L1/#lesson-structure","text":"Generally, several concepts will be explained and grouped together to form a lesson. As each concept is taught, several practice exercises are given for you to check your understanding. At the end of the lesson, one or two problems will be assigned on HackerRank that test your understanding of all concepts in the lesson. The site allows you to check your program against several test cases and will \"grade\" it (pass or fail) instantly.","title":"Lesson Structure"},{"location":"strat/usage/L1/#java-code-structure","text":"Java source files have a . java extension and each contain a class , which acts like an object (we'll get to this later). Each class/source file is located in a package , which acts as a folder to organize various files. Inside an executable program is a main method , in which the code inside it executes. In a desktop Java program, the method signature public static void main ( String [] args ) is used, followed by a set of curly braces. Below is an example inside a file called Example . java : // Place import statements here public class Example { public static void main ( String [] args ){ // Write your code to execute here } } As seen above line comments can be written if they are proceeded with two forward slashes ( // ). Anything following the two slashes will be ignored by the compiler when your program executes. Block comments may also be written like this: /* Hi! * I'm a block comment. */ Note the two slashes showing the beginning/end of the comment and the asterisk on each line.","title":"Java Code Structure"},{"location":"strat/usage/L1/#variables","text":"Any data or value you use in Java is stored in a variable . A variable can have one of many different datatypes . The following are common datatypes: * int - an integer with a value between -2^31 - 1 and 2^31 -1 ( 123 , 25 , - 900 , 0 , etc.) * double - a positive or negative decimal number ( 1.23 , - 2.5 , 1.0005 , etc.) * boolean - has either a true or false value * String - a sequence of characters, enclosed in a set of quotation marks ( \"Hello World\" , \"1+1=2\" , \"Raider Robotix\" , etc.) You can declare variables with its datatype, followed by a space and its identifier , then a semicolon. The identifier must start with a letter or underscore, then be followed by more letters, underscores, or numbers, with no spaces. Valid identifiers include: * _t * motor1 * MOTOR_SPEED Generally, variables are named in a camelCase notation, where the first word is lowercase, then the remaining words are uppercase. Examples of variable declarations with camelCase naming include: int teleOpGearsCollected ; double avgKpaPerGame ; boolean baselineCrossed ; String robotComment , pilotComment ; //multiple variables can be declared with a comma separating them On the other hand, variables that are constant throughout a program should be named with only uppercase letters and underscores. Examples of these variables include: double TURN_ANGLE_TOLERANCE ; int LEFT_JOYSTICK_PORT ; String RULES_FILEPATH ; int VERSION_NUMBER ; Keep in mind that variables should not have generic identifiers like x or var1 , but ones that are descriptive. A variable can be assigned a value with its identifier followed by the assignment operator , = , and its value. This value can be literal or that of another variable. A variable may be assigned a value and declared at the same time as well. Some examples: int teleOpGearsCollected ; // declaration double avgHighGoalsTeleOp = 12.555 ; // variable declared and value of 12.555 assigned teleOpGearsCollected = 4 ; // assignment afterwards boolean baselineCrossed = true , readyTakeoff = false ; // two variables declared and assigned value String robotComment = \"This is a good robot\" ; double avgTeleOpKpa = avgHighGoalsTeleOp / 3 ; //value dependent on another variable","title":"Variables"},{"location":"strat/usage/L1/#output","text":"Output to the console in Java can be executed with the following statement : System . out . println ( < some value > ); This calls the println method on a value, where < some value > can be a literal value or a variable. Remember to terminate the print statement with a semicolon. For example, executing System . out . println ( teleOpGearsCollected ); System . out . println ( \"gears collected in tele-op in match\" ); System . out . println ( 25 ); will result in the following output: 4 gears collected in tele - op in match 25 If you don't want a new line after the output, the System . out . print ( < some value > ) method may be used. Executing System . out . print ( teleOpGearsCollected ); System . out . println ( \" gears collected in tele-op.\" ); System . out . println ( \"Robots are cool\" ); will result in the following output: 4 gears collected in tele - op . Robots are cool","title":"Output"},{"location":"strat/usage/L1/#an-ide","text":"An IDE (Integrated Development Environment) will be used to program in Java. It allows you to write code, execute, and debug it in one application. I recommend using Eclipse , as NBTHS and the WPILib API uses it, though alternatives like InteliJ and BlueJ exist. We will be using Android Studio as our IDE for Android development. To get started with Eclipse: 1. Download and extract the ZIP file from the link above 2. Run the executable and choose your workspace (default should work) 3. Go to File > New > Java Project and name your project 4. Close the Welcome window 5. Right click your project and go to New > Class, and name your class (without the . java extension) 6. Write your main method (see above) 7. Try replacing the comment with a statement to print Hello World 8. Press the green \"Play\" button to execute your program If there are any syntax errors in your program, Eclipse will underline them in red, and the program will not run. Try fixing them by reading the error message and reviewing your code or by using Google. A Brief Exercise : Assign the values of true , \"Raider Robotix\" , and 25 to variables. Use print statements with the variables and literal values to generate the output Hello World ! It is true that I am on Team 25 , Raider Robotix 25 is the Team Number .","title":"An IDE"},{"location":"strat/usage/L1/#input","text":"To take user input, you will need to use a Scanner object. First, you will need to import the class by placing the following import statement before the class starts (see example above): import java.util.Scanner ; The Scanner object can be declared and constructed like this to read from the system console: Scanner myScanner = new Scanner ( System . in ); The datatype is Scanner , and myScanner can be any valid identifier. Note the use of the new keyword to create a new object and the parentheses following. Several methods can be accessed through the Scanner object for different datatypes. A method essentially acts like a function and returns a value to the main program. These may be used to let users assign values to variables: int anInteger = myScanner . nextInt (); String aLine = myScanner . next (); // takes the next whole line Essentially, the dot operator ( . ) shows that the methods nextInt () and nextLine () are written in the Scanner class, and you are accessing them from an outside class. More methods for input can be found by reading the documentation for the class . If the wrong datatype is used, there will be an error in your program. By default, spaces and line breaks separating tokens in the input will result two different variables. For example, if the input is Raider Robotix executing String teamName = myScanner . next (); System . out . println ( teamName ); will output Raider while executing String teamName = myScanner . nextLine (); System . out . println ( teamName ); will output Raider Robotix Exercise Write a program that allows prompts a user to input a string, an integer, and a floating point number, then print all three once they are inputted.","title":"Input"},{"location":"strat/usage/L1/#operators","text":"Operators in Java allow you to interact between different datatypes. For these examples, we will declare int a = 5 , b = 4 ; double c = 2.5 ; String s = \"Hello\" ;","title":"Operators"},{"location":"strat/usage/L1/#mathematical","text":"Evaluating these operators will result in a number of type int if both are integers, or of type double if at least one is a double : + - adds the number (an int or double ) to the left and right of it a + b is equal to 9 , a + c is equal to 7.5 - - subtracts the number on the right from the left b - a is equal to - 1 , b - c is equal to 1.5 * - multiplies the number to the left and right of it a * b is equal to 20 , b * c is equal to 10.0 / - divides the number on the left by the number on the right. However, if both numbers are int s, integer division will occur. That is, the remainder is discarded, and only the quotient remains. a / c is equal to 2.0 , b / c is equal to 1.6 a / b is equal to 1 , b / a is equal to 0 A literal int value ( 1 ) may be converted into a double value by adding a decimal point and a zero ( 1.0 ) % - the modulus operator, a % b returns the remainder of a / b a % b is equal to 1 , b % a is equal to 4 , a % c is equal to 0.0 Exercises : * Write a program that allows the user to input (integer) dimensions of a rectangular prism and outputs its surface area and volume * Write a program that prints the day of the week of a day, given the day of the week of the first day of the month (where 1=Monday, 7=Sunday) * Write a program that calculates the score of a match in FIRST Steamworks, where the user inputs the number of rotors activated during tele-op/autonomous, high/low goals in tele-op/autonomous, the times the baseline was crossed, the times robots took off, and foul points that were incurred by the opposing alliance","title":"Mathematical"},{"location":"strat/usage/L1/#relational","text":"Evaluating these operators will result in a boolean value ( true or false ): < - less than, <= - less than or equal to b < a is true , 4.5 < 0 is false - 2 <= c is true , 5 <= 5 is true > - greater than, >= - greater than or equal to == - checks for equality. This can only be used for primitive datatypes, and not objects a == 5 is true , 2.0 == a / c is true false == true is false For strings, the method someString . equals ( /*another string*/ ) is used for equality because a string is an object. We'll get into this more in the next lesson. s . equals ( \"Hello\" ) is true , s . equals ( \"World\" ) is false != - checks if the two objects are not equal a != 5 is false , 1 != a / c is true false != true is true Exercise : Write a program to determine if it is true that a quadratic equation of the form 0=ax^2+bx+c has a real solution, where the user inputs a, b, and c. (Hint: For now the best way to square an integer x is x * x , as x ^ 2 will not evaluate correctly)","title":"Relational"},{"location":"strat/usage/L1/#logical","text":"These operate on boolean values and evaluating them will also result in a boolean value: OR Operator - written as a || b , evaluates to true only if either a or b are true a b a \\ | \\ | b false false false false true true true false true true true true AND Operator - written as a && b , evaluates to true only if both a and b are true a b a && b false false false false true false true false false true true true NOT Operator - written as !a , evaluates to true only if a is false a !a false true true false Exercises * Evaluate the following expressions (without actually writing any code) for when boolean a = true , b = false and for when boolean a = true , b = true : * ( a || b ) && ( ! a || ! b ) * ! ( a && ! b ) || ( ! a && b ) * ! ( a && b )","title":"Logical"},{"location":"strat/usage/L1/#some-shortcuts","text":"You already learned about the assignment operator. Here are some shortcuts used for assignment with operators, if x and y are numbers and both are already declared and assigned values: x += y ; // same as x = x+y x -= y ; // same as x = x-y x /= y ; // same as x = x/y x %= y ; // same as x = x % y x ++ ; // same as x+=1 x -- ; // same as x-=1 Exercise : What is the value of x after the following is executed? int x = 60 , y = 10 ; y /= 5 ; x %= x - y ; x ++ ; x *= 4 ;","title":"Some Shortcuts"},{"location":"strat/usage/L1/#boolean-expressions","text":"A boolean expression is any expression that evaluates to true or false . It may contain literals, variables, and any of the above operators. The order of operations for evaluation are: Parentheses NOT Multiplication, division, modulus Addition, subtraction Greater/less than (or equal to) Equivalence/not equivalent AND OR The following are valid boolean expressions if x and y are numbers and b is a boolean : * x >= 5 + y && ! ( y + 5 == 7 || y < 0 || ! b ) * takeoffPercentage / avgTakeoffPercentage + 0.1 >= 1.2 && ( avgKpa >= 30 || avgGears >= 4 ) && teamNum != 25 && ! droppedGearOften Exercises * The XOR (exclusive-or) operator evaluates to be true if either A or B are true, but not both. Write an expression that is logically equivalent to \"A XOR B\" using the AND, OR, and NOT operators * Write a boolean expression to determine if at least 3 ranking points were earned by the red alliance in a match of FIRST Steamworks, given the scores of both the red and blue alliances, the number of gears delivered by the red alliance, whether or not the reserve gear was used, and the number of high/low goals into the red boiler in autonomous/tele-op. Use appropriate identifiers for variables and declare multiple, intermediate boolean expressions as necessary.","title":"Boolean Expressions"},{"location":"strat/usage/L1/#conditionals","text":"A conditional statement is one that executes if a particular boolean expression is true. The if , else , and else - if statements are written and used as follows: boolean a = < some expression > ; if ( a ){ //Code here executes if expression a is true } else if ( < some boolean expression b > ){ // Code here executes if expression b is true and a is false } else { // Code here executes if a and b are both false } Note that an if statement may be written without any else statements, but else and else - if statements must follow an if statement or an else statement. The boolean expression may also be placed inside the parentheses, rather than assigning its value to a boolean variable. These conditional statements may also be nested inside each other as follows: boolean a = < some expression > ; boolean b = < some expression > ; boolean c = < some expression > ; if ( a ){ if ( c ){ // Code here executes if a and c are true } else { //Code here executes if a is true and c is false } // Code here executes as long as a is true, no matter what the value of c is } else if ( b ){ // Code here executes if expression b is true and a is false, no matter what the value of c is if ( ! c ){ //Code here executes if a is false, b is true, and c is false } } else { // Code here executes if a and b are both false } Exercises * Write a program to determine if a number is even or odd * Write a program that prints the month, given its numerical value (1 to 12) * Write a program that converts a day of the week to a number (Monday = 1, Sunday = 7) * Write a program that converts feet to yards and vice-versa, depending on what the user wants","title":"Conditionals"},{"location":"strat/usage/L1/#assignment","text":"Download Eclipse and complete the exercises above as necessary to check your understanding. Afterwards, sign up for a HackerRank account and complete the \"A School Day\" program here . I suggest that you write and test the program on Eclipse, then check if it works on HackerRank.","title":"Assignment"},{"location":"strat/usage/L2/","text":"Lesson 2 - Loops, Strings, Math After a (probably pretty long) first lesson, let's explore a couple more features of Java and see what you can do with everything that you learned. Loops Loops are used to execute a block of code enclosed in a set of braces ( {} ) multiple times. After all, computers are very good at doing the same thing over and over again! The number of times a block executes depends on a boolean expression. while Loops while loops execute as long as a boolean expression is true . It may not execute at all if the expression is false before entering the loop. while ( /*some boolean expression*/ ){ //Execute code here multiple times as long as the expression is true } Remember that the boolean expression should become false at some point during the execution of the code in the loop. Otherwise, an infinite loop will be created. For example, the following will print the numbers from 1 to 10 (inclusive): int counter = 1 ; while ( counter <= 10 ){ System . out . println ( counter ); counter ++ ; } do - while loops may also be written. The main difference between these and while loops is that the boolean expression must be true at the end of the loop, not at the beginning. The following prints the numbers from 1 to 10 (inclusive): int counter = - 1 ; do { counter ++ ; System . out . println ( counter ); } while ( counter < 10 ); for Loops for loops provide a more controlled way for iterating through a loop multiple times. There are three components to the for loop: the initial statement, the exit condition (boolean expression), and the post-excution statement. The example for ( /*initial statement*/ ; /*exit condition*/ ; /*post-execution statement*/ ){ //Code to be executed each loop } is essentially equal to the following while loop: //Initial statement while ( /*exit condition*/ ){ //Code to be executed each loop //Post-execution statement } The for loop is commonly used to execute a loop a certain number of times. Below, the loop prints the numbers from 0 to 9 (10 iterations): for ( int count = 0 ; i < 10 ; count ++ ){ System . out . println ( count ); } Keep in mind that the variable count is declared within the loop, and it cannot accessed outside it. Loops may also be placed inside each other. For example, executing for ( int row = 1 ; row <= 12 ; row ++ ){ for ( int col = 1 ; col <= 12 ; col ++ ){ System . out . print ( row * col ); System . out . print ( \" \" ); //adds a space } System . out . println (); //line break } will print a (poorly formatted) times table. Note that all three parts of a for loop are optional. That is, a loop like for (;;) { //something } will execute forever. Questions Determine the number of times the following for loops will execute. for ( int i = 4 ; i <= 8 ; i += 2 ) { /*do something*/ } for ( int i = 10 ; i >= 0 ; i -= 3 ) { /*do something*/ } for ( int j = 2 ; j >= 4 ; j ++ ) { /*do something*/ } Exercises Write a program that computes the sum of all odd integers from 1 to a number specified by the user Write a program that computes b^e (a number raised to the power of an exponent), where b and e are positive integers Write a program that allows the user to enter a number, setSize . setSize numbers, num , follow and are inputted by the user. Print the average, largest, and smallest of the numbers. Loop Control There are two control statements that are used with loops: break The break statement will immediately exit a while or for loop. This can be useful if you're looking for a specific value, and you want the loop to end after you've found that value. For instance, in the below example, the loop will terminate immediately after the value key is found: int key = 8 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( i == key ) { System . out . println ( \"Found\" ); break ; } System . out . println ( \"Not found...\" ); } As a result, Not found ... will be printed out eight times at first, followed by Found . The loop will then terminate. The break statement will be more useful after you learn about arrays. continue The continue statement will immediately go to the next iteration of a for or while loop, bypassing all statements after it. This could be used when you only want to execute a loop for some values. Of course, an if - else statement can often accomplish the same thing, but break and continue statements can prevent too many nested blocks of code. For instance, the following block of code for ( int i = 0 ; i < 4 ; i ++ ) { System . out . println ( \"Going... \" + i ); if ( i >= 2 ) { continue ; } System . out . println ( \"Here\" ); } will print Going ... 0 Here Going ... 1 Here Going ... 2 Going ... 3 Characters In addition to the primitive data types ( boolean , int , double ) we learned about before, char s represent one of the 256 ASCII characters . These include the numbers, standard symbols and punctuation on a keyboard, and both uppercase and lowercase letters. A char is assigned a value with the declaration char allianceColor = 'R' ; Note the use of single quotation marks rather than double quotation marks (which are used for String s) and that a variable of type char may only contain a single character. Escape characters are the first 32 ASCII characters, which serve special functions. The most commonly used is '\\n' , which creates a line break. In addition, quotation marks must be escaped. Thus, executing the following code char quote1 = '\\'' ; char quote2 = '\\\"' ; char newLine = '\\n' System . out . print ( quote1 ); System . out . print ( newLine ); System . out . print ( quote2 ); will print ' \" Note that strings can be thought of as a series of char s concatenated together. For instance, executing String someText = \"Kickoff, 2017 \\n As we anticipated the new game, the livestream blared, \\\" STEAM POWERED! STEAM POWERED! STEAM POWERED! \\\" \" ; System . out . println ( someText ); will print Kickoff , 2017 As we anticipated the new game , the livestream blared , \"STEAM POWERED! STEAM POWERED! STEAM POWERED!\" The value of characters may be compared with the equivalence ( == ) operator. For example, allianceColor == 'R' is true . Note, however, that a character is not equal its int equivalent. That is, '1' == 1 is false . String Manipulation The String class in Java contains many methods to manipulate strings. We will present an overview of the most useful ones, though you may read the full documentation here . Concatenation A string can be concatenated , or joined together, with other strings or primitive datatypes (and literals) with the + operator. For example, executing the following: String mascot = \"Raider\" ; int teamNum = 25 ; String teamName = mascot + \" Robotix\" ; System . out . println ( \"The year is \" + 2017 ); System . out . println ( \"I am on Team \" + teamNum + \", \" + teamName ); will print The year is 2017 I am on Team 25 , Raider Robotix You may also concatenate a string onto the end of another with the += operator. Executing String s = \"Hello\" ; s += \" World!\" ; System . out . println ( s ); will print Hello World ! . String Properties You can check the length of a string (number of characters) with the string . length () method. Executing String s = \"Hello\" ; System . out . println ( s + \" is \" + s . length () + \" characters long\" ); System . out . print ( \"World!\" . length ()); will print Hello is 5 characters long 6 You can also check if a string contains a specific character sequence with the string . contains ( < character sequence > ) method, which returns a boolean value. If String s = \"Hello\" ; is declared, s . contains ( \"ell\" ) returns true , while s . contains ( \"f\" ) returns false . Parsing a String You may want to parse through a string sometimes, or check the sequence of its characters. The string . charAt ( /*index*/ ) method will return the character currently at the index. There are two things you should know about the method: The method will return a value of type char (character), rather than String . The index is a value that is greater than or equal to 0 and less than string . length () . That is, the index of the first character in the string is 0 , and the index of the last character in the string is string . length () - 1 . If String s = \"World\" ; is declared, s . charAt ( 0 ) returns 'W' , s . charAt ( 3 ) returns 'l' , and s . charAt ( 4 ) returns 'd' . A standard way to parse through all of the characters of a string is with the following for loop: String str = \"Hello World!\" ; for ( int i = 0 ; i < str . length (); i ++ ){ char currentChar = str . charAt ( i ); //Do something here } Substrings Suppose you want to return a slice of a string, known as a substring, such as the first letter four letters of String s = \"Raider Robotix\" ; . An easy-to-understand way would be to use string parsing, similar to what we did above: String s = \"Raider Robotix\" ; String result = \"\" ; // an empty string for ( int i = 0 ; i < 4 && i < s . length (); i ++ ){ result += s . charAt ( i ); } System . out . println ( result ); This would print out Raid . Note that the expression i < s . length () was still present in the exit condition in order to prevent errors if s was an input string that was less than four characters long. However, a faster way to get result would be to use the substring ( beginIndex , endIndex ) method, in which beginIndex and endIndex are integers that represent the indicies that you want to search. Similar to the for loop above, beginIndex is inclusive, while endIndex is exclusive. Here are some examples: s . substring ( 0 , 4 ); returns Raid s . substring ( 7 , s . length ()); returns Robotix \"hamburger\" . substring ( 4 , 8 ); returns urge Miscellaneous String Functions Assume that String s = \"Hello\" ; is declared in the following examples: s . toLowerCase (); returns hello s . toUpperCase (); returns HELLO s . indexOf ( \"l\" ); returns 2 (the first occurence of l in s ), while s . lastIndexOf ( \"l\" ) returns 3 s . concat ( \"world\" ); returns Helloworld As mentioned before, string equality is checked with s . equals ( \"Hello\" ); , which would return true . On the other hand, after declaring String anotherString = \"Hello\" ; , the boolean expression s == anotherString || s == \"Hello\" would be false , as string are objects , not primitives . Exercises * Write a program to reverse a string if it has an R in it. * Write a program to check if a string is a palindrome (reads the same backward as forward, such as racecar) * Write a program to replaces all commas from a string with semicolons The Math Class The Math class contains several methods that you may find helpful. It is imported by default, and documentation is found here . For these examples, we will declare double a = 4.5 , b = - 2.5 ; Math . abs ( b ) : takes the absolute value of a number, returns 2.5 in the example Math . ceil ( a ) : takes the ceiling of a number (rounds it up if it is a decimal), returns 5 in the example Math . floor ( a ) : takes the floor of a number (rounds it down if it is a decimal), returns 4 in the example Math . pow ( a - 0.5 , - b + 0.5 ) : takes the first number to the power of the second number, returns 125.0 in the example Math . sqrt ( a - 0.5 ) : takes the square root of a number, returns 2.0 in this example Math . PI : returns the value of pi (3.141592653589793) Math . random () : returns a random double in the interval [0.0, 1.0). This can be used to generate a random integer within a particular range by clamping the number down, then casting it to an int . For example, if you want a random integer in the interval [ lower , upper ], you would declare int randInt = ( int ) ( Math . random () * ( upper - lower )) + lower ; . Try it out! Exercises * Write a program that solves quadratic equations of the form 0=ax^2+bx+c for x, where a, b, and c are coefficients given by the user * Write a program that calculates the average of a data set, given the numbers in the set and its length * Write a program to find the surface area and volume of a square pyramid, given its side length and height * Write a program to round a number to a specific number of decimal places Assignment Complete the \"Raider Robotix Printer\" and \"Binary Converter\" programs on HackerRank.","title":"Lesson 2: The Scouting Client"},{"location":"strat/usage/L2/#lesson-2-loops-strings-math","text":"After a (probably pretty long) first lesson, let's explore a couple more features of Java and see what you can do with everything that you learned.","title":"Lesson 2 - Loops, Strings, Math"},{"location":"strat/usage/L2/#loops","text":"Loops are used to execute a block of code enclosed in a set of braces ( {} ) multiple times. After all, computers are very good at doing the same thing over and over again! The number of times a block executes depends on a boolean expression.","title":"Loops"},{"location":"strat/usage/L2/#while-loops","text":"while loops execute as long as a boolean expression is true . It may not execute at all if the expression is false before entering the loop. while ( /*some boolean expression*/ ){ //Execute code here multiple times as long as the expression is true } Remember that the boolean expression should become false at some point during the execution of the code in the loop. Otherwise, an infinite loop will be created. For example, the following will print the numbers from 1 to 10 (inclusive): int counter = 1 ; while ( counter <= 10 ){ System . out . println ( counter ); counter ++ ; } do - while loops may also be written. The main difference between these and while loops is that the boolean expression must be true at the end of the loop, not at the beginning. The following prints the numbers from 1 to 10 (inclusive): int counter = - 1 ; do { counter ++ ; System . out . println ( counter ); } while ( counter < 10 );","title":"while Loops"},{"location":"strat/usage/L2/#for-loops","text":"for loops provide a more controlled way for iterating through a loop multiple times. There are three components to the for loop: the initial statement, the exit condition (boolean expression), and the post-excution statement. The example for ( /*initial statement*/ ; /*exit condition*/ ; /*post-execution statement*/ ){ //Code to be executed each loop } is essentially equal to the following while loop: //Initial statement while ( /*exit condition*/ ){ //Code to be executed each loop //Post-execution statement } The for loop is commonly used to execute a loop a certain number of times. Below, the loop prints the numbers from 0 to 9 (10 iterations): for ( int count = 0 ; i < 10 ; count ++ ){ System . out . println ( count ); } Keep in mind that the variable count is declared within the loop, and it cannot accessed outside it. Loops may also be placed inside each other. For example, executing for ( int row = 1 ; row <= 12 ; row ++ ){ for ( int col = 1 ; col <= 12 ; col ++ ){ System . out . print ( row * col ); System . out . print ( \" \" ); //adds a space } System . out . println (); //line break } will print a (poorly formatted) times table. Note that all three parts of a for loop are optional. That is, a loop like for (;;) { //something } will execute forever. Questions Determine the number of times the following for loops will execute. for ( int i = 4 ; i <= 8 ; i += 2 ) { /*do something*/ } for ( int i = 10 ; i >= 0 ; i -= 3 ) { /*do something*/ } for ( int j = 2 ; j >= 4 ; j ++ ) { /*do something*/ } Exercises Write a program that computes the sum of all odd integers from 1 to a number specified by the user Write a program that computes b^e (a number raised to the power of an exponent), where b and e are positive integers Write a program that allows the user to enter a number, setSize . setSize numbers, num , follow and are inputted by the user. Print the average, largest, and smallest of the numbers.","title":"for Loops"},{"location":"strat/usage/L2/#loop-control","text":"There are two control statements that are used with loops:","title":"Loop Control"},{"location":"strat/usage/L2/#break","text":"The break statement will immediately exit a while or for loop. This can be useful if you're looking for a specific value, and you want the loop to end after you've found that value. For instance, in the below example, the loop will terminate immediately after the value key is found: int key = 8 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( i == key ) { System . out . println ( \"Found\" ); break ; } System . out . println ( \"Not found...\" ); } As a result, Not found ... will be printed out eight times at first, followed by Found . The loop will then terminate. The break statement will be more useful after you learn about arrays.","title":"break"},{"location":"strat/usage/L2/#continue","text":"The continue statement will immediately go to the next iteration of a for or while loop, bypassing all statements after it. This could be used when you only want to execute a loop for some values. Of course, an if - else statement can often accomplish the same thing, but break and continue statements can prevent too many nested blocks of code. For instance, the following block of code for ( int i = 0 ; i < 4 ; i ++ ) { System . out . println ( \"Going... \" + i ); if ( i >= 2 ) { continue ; } System . out . println ( \"Here\" ); } will print Going ... 0 Here Going ... 1 Here Going ... 2 Going ... 3","title":"continue"},{"location":"strat/usage/L2/#characters","text":"In addition to the primitive data types ( boolean , int , double ) we learned about before, char s represent one of the 256 ASCII characters . These include the numbers, standard symbols and punctuation on a keyboard, and both uppercase and lowercase letters. A char is assigned a value with the declaration char allianceColor = 'R' ; Note the use of single quotation marks rather than double quotation marks (which are used for String s) and that a variable of type char may only contain a single character. Escape characters are the first 32 ASCII characters, which serve special functions. The most commonly used is '\\n' , which creates a line break. In addition, quotation marks must be escaped. Thus, executing the following code char quote1 = '\\'' ; char quote2 = '\\\"' ; char newLine = '\\n' System . out . print ( quote1 ); System . out . print ( newLine ); System . out . print ( quote2 ); will print ' \" Note that strings can be thought of as a series of char s concatenated together. For instance, executing String someText = \"Kickoff, 2017 \\n As we anticipated the new game, the livestream blared, \\\" STEAM POWERED! STEAM POWERED! STEAM POWERED! \\\" \" ; System . out . println ( someText ); will print Kickoff , 2017 As we anticipated the new game , the livestream blared , \"STEAM POWERED! STEAM POWERED! STEAM POWERED!\" The value of characters may be compared with the equivalence ( == ) operator. For example, allianceColor == 'R' is true . Note, however, that a character is not equal its int equivalent. That is, '1' == 1 is false .","title":"Characters"},{"location":"strat/usage/L2/#string-manipulation","text":"The String class in Java contains many methods to manipulate strings. We will present an overview of the most useful ones, though you may read the full documentation here .","title":"String Manipulation"},{"location":"strat/usage/L2/#concatenation","text":"A string can be concatenated , or joined together, with other strings or primitive datatypes (and literals) with the + operator. For example, executing the following: String mascot = \"Raider\" ; int teamNum = 25 ; String teamName = mascot + \" Robotix\" ; System . out . println ( \"The year is \" + 2017 ); System . out . println ( \"I am on Team \" + teamNum + \", \" + teamName ); will print The year is 2017 I am on Team 25 , Raider Robotix You may also concatenate a string onto the end of another with the += operator. Executing String s = \"Hello\" ; s += \" World!\" ; System . out . println ( s ); will print Hello World ! .","title":"Concatenation"},{"location":"strat/usage/L2/#string-properties","text":"You can check the length of a string (number of characters) with the string . length () method. Executing String s = \"Hello\" ; System . out . println ( s + \" is \" + s . length () + \" characters long\" ); System . out . print ( \"World!\" . length ()); will print Hello is 5 characters long 6 You can also check if a string contains a specific character sequence with the string . contains ( < character sequence > ) method, which returns a boolean value. If String s = \"Hello\" ; is declared, s . contains ( \"ell\" ) returns true , while s . contains ( \"f\" ) returns false .","title":"String Properties"},{"location":"strat/usage/L2/#parsing-a-string","text":"You may want to parse through a string sometimes, or check the sequence of its characters. The string . charAt ( /*index*/ ) method will return the character currently at the index. There are two things you should know about the method: The method will return a value of type char (character), rather than String . The index is a value that is greater than or equal to 0 and less than string . length () . That is, the index of the first character in the string is 0 , and the index of the last character in the string is string . length () - 1 . If String s = \"World\" ; is declared, s . charAt ( 0 ) returns 'W' , s . charAt ( 3 ) returns 'l' , and s . charAt ( 4 ) returns 'd' . A standard way to parse through all of the characters of a string is with the following for loop: String str = \"Hello World!\" ; for ( int i = 0 ; i < str . length (); i ++ ){ char currentChar = str . charAt ( i ); //Do something here }","title":"Parsing a String"},{"location":"strat/usage/L2/#substrings","text":"Suppose you want to return a slice of a string, known as a substring, such as the first letter four letters of String s = \"Raider Robotix\" ; . An easy-to-understand way would be to use string parsing, similar to what we did above: String s = \"Raider Robotix\" ; String result = \"\" ; // an empty string for ( int i = 0 ; i < 4 && i < s . length (); i ++ ){ result += s . charAt ( i ); } System . out . println ( result ); This would print out Raid . Note that the expression i < s . length () was still present in the exit condition in order to prevent errors if s was an input string that was less than four characters long. However, a faster way to get result would be to use the substring ( beginIndex , endIndex ) method, in which beginIndex and endIndex are integers that represent the indicies that you want to search. Similar to the for loop above, beginIndex is inclusive, while endIndex is exclusive. Here are some examples: s . substring ( 0 , 4 ); returns Raid s . substring ( 7 , s . length ()); returns Robotix \"hamburger\" . substring ( 4 , 8 ); returns urge","title":"Substrings"},{"location":"strat/usage/L2/#miscellaneous-string-functions","text":"Assume that String s = \"Hello\" ; is declared in the following examples: s . toLowerCase (); returns hello s . toUpperCase (); returns HELLO s . indexOf ( \"l\" ); returns 2 (the first occurence of l in s ), while s . lastIndexOf ( \"l\" ) returns 3 s . concat ( \"world\" ); returns Helloworld As mentioned before, string equality is checked with s . equals ( \"Hello\" ); , which would return true . On the other hand, after declaring String anotherString = \"Hello\" ; , the boolean expression s == anotherString || s == \"Hello\" would be false , as string are objects , not primitives . Exercises * Write a program to reverse a string if it has an R in it. * Write a program to check if a string is a palindrome (reads the same backward as forward, such as racecar) * Write a program to replaces all commas from a string with semicolons","title":"Miscellaneous String Functions"},{"location":"strat/usage/L2/#the-math-class","text":"The Math class contains several methods that you may find helpful. It is imported by default, and documentation is found here . For these examples, we will declare double a = 4.5 , b = - 2.5 ; Math . abs ( b ) : takes the absolute value of a number, returns 2.5 in the example Math . ceil ( a ) : takes the ceiling of a number (rounds it up if it is a decimal), returns 5 in the example Math . floor ( a ) : takes the floor of a number (rounds it down if it is a decimal), returns 4 in the example Math . pow ( a - 0.5 , - b + 0.5 ) : takes the first number to the power of the second number, returns 125.0 in the example Math . sqrt ( a - 0.5 ) : takes the square root of a number, returns 2.0 in this example Math . PI : returns the value of pi (3.141592653589793) Math . random () : returns a random double in the interval [0.0, 1.0). This can be used to generate a random integer within a particular range by clamping the number down, then casting it to an int . For example, if you want a random integer in the interval [ lower , upper ], you would declare int randInt = ( int ) ( Math . random () * ( upper - lower )) + lower ; . Try it out! Exercises * Write a program that solves quadratic equations of the form 0=ax^2+bx+c for x, where a, b, and c are coefficients given by the user * Write a program that calculates the average of a data set, given the numbers in the set and its length * Write a program to find the surface area and volume of a square pyramid, given its side length and height * Write a program to round a number to a specific number of decimal places","title":"The Math Class"},{"location":"strat/usage/L2/#assignment","text":"Complete the \"Raider Robotix Printer\" and \"Binary Converter\" programs on HackerRank.","title":"Assignment"},{"location":"strat/usage/L3/","text":"Lesson 3 - Methods Here's a short lesson on one of the building blocks of Java that will prepare you for object-orientated programming: methods. Method signature A method (also known as a function in other languages) is essentially a function, very similar to one that you would encounter in math class. It has an input, an output, and a name (or identifier), though these must have specific data types (think a limited domain/range). Here is a sample method ( isEven ) being declared within a class: public class Example { public boolean isEven ( int num ){ if ( num % 2 == 0 ){ return true ; } return false ; } public static void main ( String [] args ){ //main method //code executed here first } } In this example, the method signature is simply public boolean isEven ( int num ) . It consists of visibility modifiers ( public , private , protected , etc.), a return type ( boolean ), a method identifier ( isEven ), and a set of parameters ( int num ). These parameters must each have a datatype, followed by an identifier, similar to declaring a variable. To list multiple parameters, list each one individually within the parentheses, then separate them with a comma, like in the following example: public int getNumRpPowerUp ( int redScore , int blueScore , boolean autoQuestComplete , int numClimbs , boolean levitateUsed ){ int totalRp = 0 ; if ( redScore > blueScore ) totalRp += 2 ; if ( redScore == blueScore ) totalRp ++ ; if ( autoQuestComplete ) totalRp ++ if ( numClimbs == 3 || numClimbs == 2 && levitateUsed ) totalRp ++ return totalRp ; } Note that a value with the same type as the specified return type ( int in this case) must be returned by the method. This is accomplished by typing the word return followed by a variable or literal value of the specified return type. For instance, the statement return 0 ; would be valid in getNumRpPowerUp as well. Note that the method immediately ends once a return statement is executed. It it possible for a method to have no parameters and/or return type as well. With no parameters, simply leave the contents of the parentheses following the method name blank: public String getInfoString (){ return \"Hello World!\" ; } If you don't want to return a value from the method, the return type should be specified as void . A return statement is not necessary: public void printInfo ( int currentMatchNum , String scoutName ){ System . out . println ( scoutName + \" - Match \" + currentMatchNum ); } You've already used methods to find properties of an object or to compute values, such as with str . length () or Math . pow ( base , power ) . In general, a method call is accomplished by typing the method name, followed by its parameters. The return value (if there is one) can then be used, either within a conditional statement, loop, or assigned to a variable: int red = 200 , blue = 30 , climbs = 1 ; boolean levitated = true ; int rpGained = getNumRpPowerUp ( red , blue , true , climbs , levitated ); while ( isEven ( rpGained )){ //do something } Why methods? So, why are methods so important if they're just executing a block of pre-written code? Well, creating multiple methods in an application or program allows you to break down a problem and do certain tasks repeatedly. For instance, if you wanted to test if a series of numbers were even in different parts of a program, it would be easier to make a call to isEven ( num ) rather than remembering that if a number mod 2 is 0, it is even. Another way to structure an application is to have methods responsible for specific tasks, such as saving a file or verifying if a password matches the one that was stored. As long as you test a method after you write it and ensure it gives the correct output for a variety of input parameters, you can use it throughout an application without needing to refer back to the actual method's source code. That also makes it easy to collaborate with each other, as each person working on a project could be responsible for writing and testing one method; as long as those work independently, you could implement them together in the final product. Overloading methods Sometimes, a method should be able to have different set of parameters, of different data types. In this case, the parameter list will need to be modfied: public double average ( int num1 , int num2 ){ return ( num1 + num2 ) / 2.0 ; } public double average ( double a , double b ){ return ( a + b ) / 2.0 ; } Depending on the datatypes of the parameters when you make the method call, the compiler will know which method to execute. Note that the return type for a particular method name must always be the same, and a method cannot be overloaded if its signature is otherwise identical (parameters have the same datatypes, in the same order). Recursion Like in math, methods can call themselves or other methods within the body of their code. For instance, the following returns the n th Fibonacci number (1, 1, 2, 3, 5, ...): int fib ( int n ){ if ( n == 1 ) return 1 ; if ( n == 2 ) return 1 ; return fib ( n - 1 ) + fib ( n - 2 ); } Recursion is useful for creating simple methods, but their running time can sometimes be slow, and you must always ensure that you reach a base case ( n == 1 or n == 2 in this example) that returns a literal value. Refer to the binary search method if you want to see a more complex example of recursion. Algorithmic challenges Do as many as you want, until you get a good feel of when to implement methods and how to break down a problem: Write a recursive method to compute the factorial of a number. Note that 0! is equal to 1. Write a program that takes any English sentence without punctuation as an input, then converts it to Pig Latin . Implement a more efficient (non-recursive) algorithm to find the n th Fibonacci number Determine the sum of all prime numbers from 2 to a number specified by the user. A number is superb if and only if the sum of all of its factors (excluding itself) is less than a number. Write a program to determine the number of superb numbers between two numbers (e.g. 1 and 100) that are specified by the user. Given a series of variable identifiers in camelCase, identify the number of actual words in the string (e.g. numberOfRankingPoints has four actual words). Given the length of a set of integers S, followed the elements (numbers) of S, determine if S contains only consecutive integers, without repeats (e.g. {3, 5, 4, 6} does, while {6, 4, 3} and {1, 2, 2, 3} do not). Given a series of lowercase strings without spaces or punctuation, determine if any two adjacent strings (inputted right after each other) are anagrams of each other. Write a program to determine if a number is a palindrome. Write methods that compute the least common multiple and greatest common factor of two positive integers. Please email or DM me via Slack any challenges that you finish for feedback!","title":"Lesson 3: Tableau"},{"location":"strat/usage/L3/#lesson-3-methods","text":"Here's a short lesson on one of the building blocks of Java that will prepare you for object-orientated programming: methods.","title":"Lesson 3 - Methods"},{"location":"strat/usage/L3/#method-signature","text":"A method (also known as a function in other languages) is essentially a function, very similar to one that you would encounter in math class. It has an input, an output, and a name (or identifier), though these must have specific data types (think a limited domain/range). Here is a sample method ( isEven ) being declared within a class: public class Example { public boolean isEven ( int num ){ if ( num % 2 == 0 ){ return true ; } return false ; } public static void main ( String [] args ){ //main method //code executed here first } } In this example, the method signature is simply public boolean isEven ( int num ) . It consists of visibility modifiers ( public , private , protected , etc.), a return type ( boolean ), a method identifier ( isEven ), and a set of parameters ( int num ). These parameters must each have a datatype, followed by an identifier, similar to declaring a variable. To list multiple parameters, list each one individually within the parentheses, then separate them with a comma, like in the following example: public int getNumRpPowerUp ( int redScore , int blueScore , boolean autoQuestComplete , int numClimbs , boolean levitateUsed ){ int totalRp = 0 ; if ( redScore > blueScore ) totalRp += 2 ; if ( redScore == blueScore ) totalRp ++ ; if ( autoQuestComplete ) totalRp ++ if ( numClimbs == 3 || numClimbs == 2 && levitateUsed ) totalRp ++ return totalRp ; } Note that a value with the same type as the specified return type ( int in this case) must be returned by the method. This is accomplished by typing the word return followed by a variable or literal value of the specified return type. For instance, the statement return 0 ; would be valid in getNumRpPowerUp as well. Note that the method immediately ends once a return statement is executed. It it possible for a method to have no parameters and/or return type as well. With no parameters, simply leave the contents of the parentheses following the method name blank: public String getInfoString (){ return \"Hello World!\" ; } If you don't want to return a value from the method, the return type should be specified as void . A return statement is not necessary: public void printInfo ( int currentMatchNum , String scoutName ){ System . out . println ( scoutName + \" - Match \" + currentMatchNum ); } You've already used methods to find properties of an object or to compute values, such as with str . length () or Math . pow ( base , power ) . In general, a method call is accomplished by typing the method name, followed by its parameters. The return value (if there is one) can then be used, either within a conditional statement, loop, or assigned to a variable: int red = 200 , blue = 30 , climbs = 1 ; boolean levitated = true ; int rpGained = getNumRpPowerUp ( red , blue , true , climbs , levitated ); while ( isEven ( rpGained )){ //do something }","title":"Method signature"},{"location":"strat/usage/L3/#why-methods","text":"So, why are methods so important if they're just executing a block of pre-written code? Well, creating multiple methods in an application or program allows you to break down a problem and do certain tasks repeatedly. For instance, if you wanted to test if a series of numbers were even in different parts of a program, it would be easier to make a call to isEven ( num ) rather than remembering that if a number mod 2 is 0, it is even. Another way to structure an application is to have methods responsible for specific tasks, such as saving a file or verifying if a password matches the one that was stored. As long as you test a method after you write it and ensure it gives the correct output for a variety of input parameters, you can use it throughout an application without needing to refer back to the actual method's source code. That also makes it easy to collaborate with each other, as each person working on a project could be responsible for writing and testing one method; as long as those work independently, you could implement them together in the final product.","title":"Why methods?"},{"location":"strat/usage/L3/#overloading-methods","text":"Sometimes, a method should be able to have different set of parameters, of different data types. In this case, the parameter list will need to be modfied: public double average ( int num1 , int num2 ){ return ( num1 + num2 ) / 2.0 ; } public double average ( double a , double b ){ return ( a + b ) / 2.0 ; } Depending on the datatypes of the parameters when you make the method call, the compiler will know which method to execute. Note that the return type for a particular method name must always be the same, and a method cannot be overloaded if its signature is otherwise identical (parameters have the same datatypes, in the same order).","title":"Overloading methods"},{"location":"strat/usage/L3/#recursion","text":"Like in math, methods can call themselves or other methods within the body of their code. For instance, the following returns the n th Fibonacci number (1, 1, 2, 3, 5, ...): int fib ( int n ){ if ( n == 1 ) return 1 ; if ( n == 2 ) return 1 ; return fib ( n - 1 ) + fib ( n - 2 ); } Recursion is useful for creating simple methods, but their running time can sometimes be slow, and you must always ensure that you reach a base case ( n == 1 or n == 2 in this example) that returns a literal value. Refer to the binary search method if you want to see a more complex example of recursion.","title":"Recursion"},{"location":"strat/usage/L3/#algorithmic-challenges","text":"Do as many as you want, until you get a good feel of when to implement methods and how to break down a problem: Write a recursive method to compute the factorial of a number. Note that 0! is equal to 1. Write a program that takes any English sentence without punctuation as an input, then converts it to Pig Latin . Implement a more efficient (non-recursive) algorithm to find the n th Fibonacci number Determine the sum of all prime numbers from 2 to a number specified by the user. A number is superb if and only if the sum of all of its factors (excluding itself) is less than a number. Write a program to determine the number of superb numbers between two numbers (e.g. 1 and 100) that are specified by the user. Given a series of variable identifiers in camelCase, identify the number of actual words in the string (e.g. numberOfRankingPoints has four actual words). Given the length of a set of integers S, followed the elements (numbers) of S, determine if S contains only consecutive integers, without repeats (e.g. {3, 5, 4, 6} does, while {6, 4, 3} and {1, 2, 2, 3} do not). Given a series of lowercase strings without spaces or punctuation, determine if any two adjacent strings (inputted right after each other) are anagrams of each other. Write a program to determine if a number is a palindrome. Write methods that compute the least common multiple and greatest common factor of two positive integers. Please email or DM me via Slack any challenges that you finish for feedback!","title":"Algorithmic challenges"},{"location":"strat/usage/L4/","text":"Lesson 4 - Object Orientated Design We explored String s in previous lessons, which was your first look at an object in Java. In fact, you've been writing programs inside of a main function, which is a method inside a function! In this lesson, we'll see what an object really is and why they're so useful. Why objects? Objects have both state , variables that remain constant until you modify them, and behavior , which are seen through callable methods that either feed your main method information about that object or operate on its state. As programmers, you need to design objects so that their state and behavior are appropriate for what you're trying to accomplish, while breaking down code into testable and understandable building blocks. It's probably easiest to think of an object like an object in the real world, such as a person or a dog. It could have states like a name, age, favorite color, and friends. Similarly, a Person object could have behaviors like befriending another person if they have the same favorite color, increasing its age every year, or saying its name. Objects may also want to keep some state variables private , such as a credit card number. These are just examples, but you'll see as we go about modeling a person in this lesson. In essence, objects make programming real-world mechanisms and representing real-world entities a lot easier. You could have a Robot object drive a certain distance, deposit and earn interest in a BankAccount , or read the state of an Actuator on a Robot . Constructors and member variables A class is the blueprint behind an object, which is something you should already be familiar with from writing programs. Each class should generally be in its own . java file, called ClassName . java . It's possible to have multiple classes within a file, but we'll get to that later. Inside Person . java : // Import statements come first import java.util.Scanner ; public class Person { public static void main ( String [] args ){ // do stuff here } } This is probably what you're familiar with right now. Now, we'll add in some fields, called member variables , to the Person class that will help identify it: public class Person { String name , favoriteColor ; int age , numFriends ; } To initialize these attributes, we'll also need a constructor , which is essentially a method that returns an instance of that class while assigning values to as many member variables as you'd like. public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } Note that the identifier for a constructor is simply the name of the class, though the parameters can be any datatype, and there is no return statement. Like other methods, constructors can also be overloaded with arguments of different datatypes. An empty constructor is automatically created if no constructor is declared for a class, which simply doesn't set any member variables. To access member variables, we use the keyword this , referring to the new instance of the object, followed by the dot operator and the identifiers of the variables you want to modify. This also distinguishes the name variable in the parameter of the constructor with the name variable that's part of the object's state. Member variables must be assigned a value, either explicitly through the code of the class or via a constructor, before their value can be accessed. They can also either be objects or primitive values. Declaring objects So, how exactly do you create an object with the constructor? Well, it's similar to declaring any other variable in Java, complete with a datatype and identifier, except you'll need to use the new keyword: public static void main ( String [] args ){ Person mentor = new Person ( \"Cokeley\" ); } This creates an instance of a Person , which is stored in mentor . Now, if you want to access or modify attributes of mentor , you'll use the same dot operator that was used in the constructor: mentor . age = 25 ; System . out . println ( mentor . name + \" is \" + mentor . age + \" years old\" ); This will print out Cokeley is 25 years old . Class methods While having objects as a simple data structure with various attributes is useful, sometimes you want a little more interactivity. That's when we can create our own methods in a class. We can spice up the Person class by adding in the following: public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } boolean makeFriends ( Person possibleFriend ){ if ( possibleFriend . favoriteColor . equals ( this . favoriteColor )){ this . numFriends ++ ; possibleFriend . numFriends ++ ; return true ; } return false ; } } This makeFriends method mutually has two people become friends if their favoriteColor is the same, then returns true if they've become friends, or false otherwise. Another example can be seen with this RightTriangle class: class RightTriangle { double legOne , legTwo , hypotenuse ; RightTriangle ( double side1 , double side2 , double side3 ){ this . hypotenuse = Math . max ( Math . max ( side1 , side2 ), side3 ); this . legOne = Math . min ( Math . min ( side1 , side2 ), side3 ); this . legTwo = side1 + side2 + side3 - this . legOne - this . hypotenuse ; } double getArea (){ return 0.5 * this . legOne * this . legTwo ; } double getPerimeter (){ return this . legOne + this . legTwo + this . hypotenuse ; } // Returns smaller acute angle in radians double getSmallerAngle (){ return Math . atan ( this . legOne / this . legTwo ); } // Returns larger acute angle in radians double getLargerAngle (){ return Math . PI / 2 - this . getSmallerAngle (); } // Extends the length of the shorter leg and // adjusts the length of the hypotenuse accordingly void extendLegOne ( double newLength ){ if ( newLength > this . legTwo ){ this . legOne = this . legTwo ; this . legTwo = newLength ; } else this . legOne = newLength ; this . hypotenuse = Math . sqrt ( Math . pow ( this . legOne , 2 ) + Math . pow ( this . legTwo , 2 )); } } Here, after initializing a RightTriangle object, we can use its different instance methods to get and modify its properties. For instance, executing the following in the main method RightTriangle tri = new RightTriangle ( 4 , 3 , 5 ); System . out . println ( \"Perimeter: \" + tri . getPerimeter ()); System . out . println ( \"Area: \" + tri . getArea ()); System . out . println ( \"Smaller Angle: \" + tri . getSmallestAngle () + \" rad\" ); tri . extendLegOne ( 10 ); System . out . println ( \"New Perimeter: \" + tri . getPerimeter ()); will print Perimeter : 12.0 Area : 6.0 Smallest Angle : 0.6435011087932844 rad New Perimeter : 24.77032961426901 Visibility Sometimes it is desirable to reduce the access and visibility of object methods or instance variables. For example, you generally wouldn't want a main method to be able to change a Person object's name explicitly, or perhaps you want to modify a BankAccount object's balance only through withdrawal and deposit methods, each requiring a PIN code. In that case, it's best to leave member variables private instead of public . To do this, simply put the visibility modifier in front of the variable identifier, like so: public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } That way, private level access only allows those variables to be accessed and modified within the same class (such as within the constructor or other class methods). On the other hand, public level access allows all classes to modify a variable or call a method, while default access (not putting any modifier) only allows classes of the same package to access variables/methods. We'll get into packages later on, but just know that they're ways of grouping similar classes for now. So, how are we supposed to modify and access attributes like favoriteColor so the method makeFriends can still function properly? For the first case, we'll use a special type of method called a setter , while we create a getter to do the latter: private public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } public void setFavoriteColor ( String favoriteColor ){ this . favoriteColor = favoriteColor ; } public String getFavoriteColor (){ return this . favoriteColor ; } } It's pretty simple: a setter has an argument datatype that's the same as the member variable, sets the member variable, then returns nothing. Meanwhile, a getter has the same return type as the member variable, has no parameters, and simply returns the value of the member variable. In fact, these methods are so common (as it's good practice to set variables as private ) that most IDEs (including Eclipse) have a way to automatically generate setters and getters for a class. Finally, static methods and variables are called directly on a class, rather than on an instance of a class. You've already seen examples of these in the Math class: the variable Math . PI and the method Math . pow ( base , exp ) can be called without declaring an instance of a Math object via the new keyword. It's important to note that static variables are shared by all instances of a given class (and thus can be used as temporary storage). Also, static methods cannot access non- static variables or methods. You can make a static method private or public by putting the visibility modifier in front of the word static , such as in public static void main ( String [] args ) . Scope Our last topic is something that we've used throughout this lesson without realizing it; variable identifiers often come in conflict with each other. In that case, which value do we use? The smallest scope is in a loop: for ( int i = 1 ; i < 5 ; i ++ ){ double area = Math . pow ( i , 2 ); } In this case, both i and area have block scope and cannot be modified or accessed outside of the for loop. You'll see that a set of curly braces generally denotes scope. Note that variables with the identifier i or area cannot exist outside of the loop either. Next up are local variables, also known as method scope : public void setSideLength ( int sideLength ){ double squareArea = Math . pow ( sideLength , 2 ); this . sideLength = sideLength ; } Both sideLength and squareArea can be accessed/modified only within the method setSideLength . However, using the keyword this and the dot operator will refer to the member variable sideLength of the class, rather than the one passed in as an argument. All variables other than member variables cannot be accessed outside of a class, which then follow the visibility rules discussed before. HW: Modeling Bank Accounts We've discussed bank accounts throughout this lesson. Now it's time to implement one! Each BankAccount object has the following attributes, which should all be private : balance : a double indicating the amount of money in the bank account. Cannot be negative. pin : a four-digit code that authenticates a user. May contain leading zeroes (i.e. 0000 is a valid PIN) name : the name of the bank account owner interestRate : the percent of interest earned by a user in a given year, shared across all bank accounts Challenge : id : a random, five-digit code that's generated upon the creation of the bank account to identify it. Does not contain leading zeroes. You may want to refer back to the Math . random method from Lesson 2. Methods should be provided to do the following: Construct a BankAccount with a PIN, owner, and initial balance Challenge : Construct a BankAccount with a PIN, owner, and initial balance of $0.00 Get the name of the owner of an account Get the id of the account Change the PIN of the account, given the old PIN and the new PIN. Should return some form of feedback to determine if the PIN was successfully changed Withdraw money from an account, given its PIN and the amount desired. Should indicate if withdrawal was successful and should not allow it if the account doesn't have enough money Deposit a given amount of money into the account Earn interest for the year, based on the interestRate Challenge : Transfer money from one account to another, given another BankAccount object and its PIN You do not need to submit a main method as a driver for your class, though you will need to write one to test if your class works. Next lesson, you'll write one to complete specific tasks when you learn about arrays and HashMaps to create a network of bank accounts. Please email me your completed class or DM me via Slack.","title":"Lesson 4: Excel"},{"location":"strat/usage/L4/#lesson-4-object-orientated-design","text":"We explored String s in previous lessons, which was your first look at an object in Java. In fact, you've been writing programs inside of a main function, which is a method inside a function! In this lesson, we'll see what an object really is and why they're so useful.","title":"Lesson 4 - Object Orientated Design"},{"location":"strat/usage/L4/#why-objects","text":"Objects have both state , variables that remain constant until you modify them, and behavior , which are seen through callable methods that either feed your main method information about that object or operate on its state. As programmers, you need to design objects so that their state and behavior are appropriate for what you're trying to accomplish, while breaking down code into testable and understandable building blocks. It's probably easiest to think of an object like an object in the real world, such as a person or a dog. It could have states like a name, age, favorite color, and friends. Similarly, a Person object could have behaviors like befriending another person if they have the same favorite color, increasing its age every year, or saying its name. Objects may also want to keep some state variables private , such as a credit card number. These are just examples, but you'll see as we go about modeling a person in this lesson. In essence, objects make programming real-world mechanisms and representing real-world entities a lot easier. You could have a Robot object drive a certain distance, deposit and earn interest in a BankAccount , or read the state of an Actuator on a Robot .","title":"Why objects?"},{"location":"strat/usage/L4/#constructors-and-member-variables","text":"A class is the blueprint behind an object, which is something you should already be familiar with from writing programs. Each class should generally be in its own . java file, called ClassName . java . It's possible to have multiple classes within a file, but we'll get to that later. Inside Person . java : // Import statements come first import java.util.Scanner ; public class Person { public static void main ( String [] args ){ // do stuff here } } This is probably what you're familiar with right now. Now, we'll add in some fields, called member variables , to the Person class that will help identify it: public class Person { String name , favoriteColor ; int age , numFriends ; } To initialize these attributes, we'll also need a constructor , which is essentially a method that returns an instance of that class while assigning values to as many member variables as you'd like. public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } Note that the identifier for a constructor is simply the name of the class, though the parameters can be any datatype, and there is no return statement. Like other methods, constructors can also be overloaded with arguments of different datatypes. An empty constructor is automatically created if no constructor is declared for a class, which simply doesn't set any member variables. To access member variables, we use the keyword this , referring to the new instance of the object, followed by the dot operator and the identifiers of the variables you want to modify. This also distinguishes the name variable in the parameter of the constructor with the name variable that's part of the object's state. Member variables must be assigned a value, either explicitly through the code of the class or via a constructor, before their value can be accessed. They can also either be objects or primitive values.","title":"Constructors and member variables"},{"location":"strat/usage/L4/#declaring-objects","text":"So, how exactly do you create an object with the constructor? Well, it's similar to declaring any other variable in Java, complete with a datatype and identifier, except you'll need to use the new keyword: public static void main ( String [] args ){ Person mentor = new Person ( \"Cokeley\" ); } This creates an instance of a Person , which is stored in mentor . Now, if you want to access or modify attributes of mentor , you'll use the same dot operator that was used in the constructor: mentor . age = 25 ; System . out . println ( mentor . name + \" is \" + mentor . age + \" years old\" ); This will print out Cokeley is 25 years old .","title":"Declaring objects"},{"location":"strat/usage/L4/#class-methods","text":"While having objects as a simple data structure with various attributes is useful, sometimes you want a little more interactivity. That's when we can create our own methods in a class. We can spice up the Person class by adding in the following: public class Person { String name , favoriteColor ; int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } boolean makeFriends ( Person possibleFriend ){ if ( possibleFriend . favoriteColor . equals ( this . favoriteColor )){ this . numFriends ++ ; possibleFriend . numFriends ++ ; return true ; } return false ; } } This makeFriends method mutually has two people become friends if their favoriteColor is the same, then returns true if they've become friends, or false otherwise. Another example can be seen with this RightTriangle class: class RightTriangle { double legOne , legTwo , hypotenuse ; RightTriangle ( double side1 , double side2 , double side3 ){ this . hypotenuse = Math . max ( Math . max ( side1 , side2 ), side3 ); this . legOne = Math . min ( Math . min ( side1 , side2 ), side3 ); this . legTwo = side1 + side2 + side3 - this . legOne - this . hypotenuse ; } double getArea (){ return 0.5 * this . legOne * this . legTwo ; } double getPerimeter (){ return this . legOne + this . legTwo + this . hypotenuse ; } // Returns smaller acute angle in radians double getSmallerAngle (){ return Math . atan ( this . legOne / this . legTwo ); } // Returns larger acute angle in radians double getLargerAngle (){ return Math . PI / 2 - this . getSmallerAngle (); } // Extends the length of the shorter leg and // adjusts the length of the hypotenuse accordingly void extendLegOne ( double newLength ){ if ( newLength > this . legTwo ){ this . legOne = this . legTwo ; this . legTwo = newLength ; } else this . legOne = newLength ; this . hypotenuse = Math . sqrt ( Math . pow ( this . legOne , 2 ) + Math . pow ( this . legTwo , 2 )); } } Here, after initializing a RightTriangle object, we can use its different instance methods to get and modify its properties. For instance, executing the following in the main method RightTriangle tri = new RightTriangle ( 4 , 3 , 5 ); System . out . println ( \"Perimeter: \" + tri . getPerimeter ()); System . out . println ( \"Area: \" + tri . getArea ()); System . out . println ( \"Smaller Angle: \" + tri . getSmallestAngle () + \" rad\" ); tri . extendLegOne ( 10 ); System . out . println ( \"New Perimeter: \" + tri . getPerimeter ()); will print Perimeter : 12.0 Area : 6.0 Smallest Angle : 0.6435011087932844 rad New Perimeter : 24.77032961426901","title":"Class methods"},{"location":"strat/usage/L4/#visibility","text":"Sometimes it is desirable to reduce the access and visibility of object methods or instance variables. For example, you generally wouldn't want a main method to be able to change a Person object's name explicitly, or perhaps you want to modify a BankAccount object's balance only through withdrawal and deposit methods, each requiring a PIN code. In that case, it's best to leave member variables private instead of public . To do this, simply put the visibility modifier in front of the variable identifier, like so: public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } } That way, private level access only allows those variables to be accessed and modified within the same class (such as within the constructor or other class methods). On the other hand, public level access allows all classes to modify a variable or call a method, while default access (not putting any modifier) only allows classes of the same package to access variables/methods. We'll get into packages later on, but just know that they're ways of grouping similar classes for now. So, how are we supposed to modify and access attributes like favoriteColor so the method makeFriends can still function properly? For the first case, we'll use a special type of method called a setter , while we create a getter to do the latter: private public class Person { private String name , favoriteColor ; private int age , numFriends ; public Person ( String name ){ this . age = 0 ; this . numFriends = 0 ; this . name = name ; } public void setFavoriteColor ( String favoriteColor ){ this . favoriteColor = favoriteColor ; } public String getFavoriteColor (){ return this . favoriteColor ; } } It's pretty simple: a setter has an argument datatype that's the same as the member variable, sets the member variable, then returns nothing. Meanwhile, a getter has the same return type as the member variable, has no parameters, and simply returns the value of the member variable. In fact, these methods are so common (as it's good practice to set variables as private ) that most IDEs (including Eclipse) have a way to automatically generate setters and getters for a class. Finally, static methods and variables are called directly on a class, rather than on an instance of a class. You've already seen examples of these in the Math class: the variable Math . PI and the method Math . pow ( base , exp ) can be called without declaring an instance of a Math object via the new keyword. It's important to note that static variables are shared by all instances of a given class (and thus can be used as temporary storage). Also, static methods cannot access non- static variables or methods. You can make a static method private or public by putting the visibility modifier in front of the word static , such as in public static void main ( String [] args ) .","title":"Visibility"},{"location":"strat/usage/L4/#scope","text":"Our last topic is something that we've used throughout this lesson without realizing it; variable identifiers often come in conflict with each other. In that case, which value do we use? The smallest scope is in a loop: for ( int i = 1 ; i < 5 ; i ++ ){ double area = Math . pow ( i , 2 ); } In this case, both i and area have block scope and cannot be modified or accessed outside of the for loop. You'll see that a set of curly braces generally denotes scope. Note that variables with the identifier i or area cannot exist outside of the loop either. Next up are local variables, also known as method scope : public void setSideLength ( int sideLength ){ double squareArea = Math . pow ( sideLength , 2 ); this . sideLength = sideLength ; } Both sideLength and squareArea can be accessed/modified only within the method setSideLength . However, using the keyword this and the dot operator will refer to the member variable sideLength of the class, rather than the one passed in as an argument. All variables other than member variables cannot be accessed outside of a class, which then follow the visibility rules discussed before.","title":"Scope"},{"location":"strat/usage/L4/#hw-modeling-bank-accounts","text":"We've discussed bank accounts throughout this lesson. Now it's time to implement one! Each BankAccount object has the following attributes, which should all be private : balance : a double indicating the amount of money in the bank account. Cannot be negative. pin : a four-digit code that authenticates a user. May contain leading zeroes (i.e. 0000 is a valid PIN) name : the name of the bank account owner interestRate : the percent of interest earned by a user in a given year, shared across all bank accounts Challenge : id : a random, five-digit code that's generated upon the creation of the bank account to identify it. Does not contain leading zeroes. You may want to refer back to the Math . random method from Lesson 2. Methods should be provided to do the following: Construct a BankAccount with a PIN, owner, and initial balance Challenge : Construct a BankAccount with a PIN, owner, and initial balance of $0.00 Get the name of the owner of an account Get the id of the account Change the PIN of the account, given the old PIN and the new PIN. Should return some form of feedback to determine if the PIN was successfully changed Withdraw money from an account, given its PIN and the amount desired. Should indicate if withdrawal was successful and should not allow it if the account doesn't have enough money Deposit a given amount of money into the account Earn interest for the year, based on the interestRate Challenge : Transfer money from one account to another, given another BankAccount object and its PIN You do not need to submit a main method as a driver for your class, though you will need to write one to test if your class works. Next lesson, you'll write one to complete specific tasks when you learn about arrays and HashMaps to create a network of bank accounts. Please email me your completed class or DM me via Slack.","title":"HW: Modeling Bank Accounts"}]}